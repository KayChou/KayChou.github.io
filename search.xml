<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>InfluxDB+Grafana可视化</title>
    <url>/2021/05/02/InfluxDB-Grafana%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>InfluxDB是一个用于存储和分析时间序列数据的开源数据库，Grafana是一款采用 go 语言编写的开源应用，主要用于大规模指标数据的可视化展现。两者结合可以方便的进行系统资源监控。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>使用docker分别安装influxDB与grafana</p>
<ul>
<li><p>docker pull influxdb</p>
</li>
<li><p>docker pull grafana/grafana</p>
</li>
</ul>
</li>
</ul>
<h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><ul>
<li><p>docker run -d -p 8083:8083 -p 8086:8086 –name influxdb influxdb</p>
</li>
<li><p>docker run -d -p 3000:3000 –name grafana grafana/grafana:latest</p>
</li>
</ul>
<h2 id="配置InfluxDB"><a href="#配置InfluxDB" class="headerlink" title="配置InfluxDB"></a>配置InfluxDB</h2><ul>
<li><p>使用浏览器打开<a href="http://localhost:8086/" target="_blank" rel="noopener">http://localhost:8086</a>，看到以下界面即安装成功</p>
<p><img src="https://api2.mubu.com/v3/document_image/73cfcef2-7ddf-4550-b5ee-d108b9e71ebf-5720288.jpg" alt="img"></p>
</li>
<li><p>点击开始，输入Username，password，Org，Bucket名称等信息</p>
<ul>
<li>假设用户名和密码为medialab，Org为SJTU，Bucket为demo</li>
</ul>
</li>
<li><p>点击Quick Start，进入主界面</p>
<p><img src="https://api2.mubu.com/v3/document_image/52f1cc41-c92f-4b39-b0bb-fb290962a780-5720288.jpg" alt="img"></p>
</li>
<li><p>点击左侧边栏Data选项，其中Buckets中可以看到创建的demo，也可以另外新建/删除，Tokens中可以复制到访问所需的token</p>
</li>
<li><p>python脚本写入数据示例</p>
<p><img src="https://api2.mubu.com/v3/document_image/4584b374-14fe-46c5-961b-3d8aac96efd7-5720288.jpg" alt></p>
<ul>
<li><p>此即向数据库中写入一条数据，写入后能在浏览器中查询到该数据</p>
<p><img src="https://api2.mubu.com/v3/document_image/c7a1b249-beea-47ac-a36b-2fd908d53b24-5720288.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h2 id="配置Grafana"><a href="#配置Grafana" class="headerlink" title="配置Grafana"></a>配置Grafana</h2><ul>
<li><p>在浏览器中输入<a href="http://localhost:3000/，看到以下界面即为安装成功" target="_blank" rel="noopener">http://localhost:3000/，看到以下界面即为安装成功</a></p>
<p><img src="https://api2.mubu.com/v3/document_image/f7ef9cbf-2314-47b6-aa7c-e023d94302aa-5720288.jpg" alt="img"></p>
</li>
<li><p>输入用户名和密码，初始均为admin，登录后会要求立即修改密码</p>
</li>
<li><p><strong>添加数据源，与InfluxDB联通</strong></p>
<ul>
<li><p>进入Settings-Data Source，点击Add Data Source，选择InfluxDB，配置页面参考下图：</p>
<p><img src="https://api2.mubu.com/v3/document_image/0f065361-5b4c-4994-9193-d0f0db5e2f21-5720288.jpg" alt></p>
<ul>
<li>其中172.16.7.131是宿主机IP地址</li>
</ul>
</li>
<li><p><strong>新建Dashboard</strong></p>
<ul>
<li><p>依次选择Create-New dashboard-Add an empty panel</p>
</li>
<li><p>配置界面格式，添加筛选条件，参考</p>
<ul>
<li><p>from(bucket: “demo”)</p>
</li>
<li><p>|&gt; range(start: v.timeRangeStart, stop: v.timeRangeStop)</p>
</li>
<li><p>|&gt; filter(fn: (r) =&gt; r[“_measurement”] == “mem”)</p>
</li>
<li><p>|&gt; filter(fn: (r) =&gt; r[“_field”] == “encoder”)</p>
</li>
<li><p>|&gt; aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)</p>
</li>
<li><p>|&gt; yield(name: “mean”)</p>
</li>
</ul>
</li>
<li><p>例如添加两个Dashboard，得到的最终效果如图所示<img src="https://api2.mubu.com/v3/document_image/cc885f4c-20f6-4d75-bd46-cc200a789edf-5720288.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>H.265/HEVC学习笔记</title>
    <url>/2019/10/15/H-265-HEVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>《新一代高效视频编码H.265HEVC》学习笔记</p>
<a id="more"></a>
<h3 id="1-视频编码标准"><a href="#1-视频编码标准" class="headerlink" title="1.视频编码标准"></a>1.视频编码标准</h3><h4 id="1-1-制定视频编码标准的两大组织："><a href="#1-1-制定视频编码标准的两大组织：" class="headerlink" title="1.1 制定视频编码标准的两大组织："></a>1.1 制定视频编码标准的两大组织：</h4><p>  ITU-T：（International Telecommunication Union-Telecommunication Standardization Sector）国际电信联盟电信标准化部门</p>
<p>  ISO/IEC：（International Organization for Standardization）国际标准化组织与（International Electrotechnical Commission）国际电工委员会</p>
<h4 id="1-2-H-26X系列标准"><a href="#1-2-H-26X系列标准" class="headerlink" title="1.2 H.26X系列标准"></a>1.2 H.26X系列标准</h4><h5 id="1-2-1-H-261标准："><a href="#1-2-1-H-261标准：" class="headerlink" title="1.2.1 H.261标准："></a>1.2.1 H.261标准：</h5><p>  于1990年由ITU-T制定，设计目的是为了在带宽为64kbits/s的倍数的综合业务数字网（Integrated Services Digital Network，ISDN）上传输质量可接受的视频信号，所以被称为p×64 bits/s编码器。<br>  采用的编码方法包括基于运动补偿的帧间预测，DCT，量化，zig-zag扫描和熵编码等。</p>
<h5 id="1-2-2-H-263标准"><a href="#1-2-2-H-263标准" class="headerlink" title="1.2.2 H.263标准"></a>1.2.2 H.263标准</h5><p>  由ITU-T制定，仍以混合编码框架为核心，原始组织和码流组织与H.261十分相似。同时，H.263也吸收了一些MPEG等一些其他国际标准的技术，如半像素精度的运动估计，PB帧预测，无限制运动矢量和8×8的帧间预测。</p>
<p>  H.263后来发展出两个增强版本：H.263+和H.263++。</p>
<h5 id="1-2-3-H-264标准"><a href="#1-2-3-H-264标准" class="headerlink" title="1.2.3 H.264标准"></a>1.2.3 H.264标准</h5><p> 由ITU-T的VCEG和ISO/IEC的MPEG组成的联合视频组（JVT）共同开发。也称H.264/AVC。</p>
<p> H.264/AVC仍然沿用了混合编码的概念，在此基础上支持了许多先进编码的技术，并获得了远超以往标准的编码性能。在相同重建质量的条件下，H.264/AVC比H.263+减少了50%的码率。</p>
<h4 id="1-3-MPEG系列标准"><a href="#1-3-MPEG系列标准" class="headerlink" title="1.3 MPEG系列标准"></a>1.3 MPEG系列标准</h4><h5 id="1-3-1-MPEG-1标准"><a href="#1-3-1-MPEG-1标准" class="headerlink" title="1.3.1 MPEG-1标准"></a>1.3.1 MPEG-1标准</h5><p>是由MPEG指定的第一个视频和音频有损压缩的标准，原本主要目标是针对数字存储媒体（CD光盘），后来成为VCD的核心技术。</p>
<h5 id="1-3-2-MPEG-2标准"><a href="#1-3-2-MPEG-2标准" class="headerlink" title="1.3.2 MPEG-2标准"></a>1.3.2 MPEG-2标准</h5><p>于1994年面世，应用范围包括卫星电视，有线电视等，经过少量修改后成为DVD的主要技术。MPEG-2视频编码标准由MPEG与ITU-T联合制定，与H.262完全相同。</p>
<h5 id="1-3-3-MPEG-4标准"><a href="#1-3-3-MPEG-4标准" class="headerlink" title="1.3.3 MPEG-4标准"></a>1.3.3 MPEG-4标准</h5><p>于1998年被ISO/IEC批准，相比于MPEG-1和MPEG-2，MPEG-4涵盖的内容非常丰富。包括多达31个部分。MPEG-4分别定义了系统，音视频编码，多媒体传输集成框架等，其中第10部分就是H.264/AVC。</p>
<h4 id="1-4-H-265-HEVC简介"><a href="#1-4-H-265-HEVC简介" class="headerlink" title="1.4 H.265/HEVC简介"></a>1.4 H.265/HEVC简介</h4><p>2010年4月VCEG和MPEG再次组建视频编码联合组（JCT-VC），联手制定H.265/HEVC（High Efficiency Video Coding）。<br>从根本上说，H.265/HEVC视频编码标准的编码框架并没有革命性的改变，仍采用混合编码框架，包括变换，量化，熵编码，帧内预测，帧间预测以及环路滤波等模块，但在几乎每个模块都引入了新的编码技术。<br>（1）帧内预测：去除空间冗余。<br>（2） 帧间预测：去除时间冗余。<br>（3）变换量化：通过对残差数据进行变换量化以去除频域相关性，对数据进行有损压缩。将图形变换至频域，将能量集中在低频区域。<br>（4）去方块滤波：基于块的视频编码形成的重构图像会出现方块效应，采用方块滤波可以削弱甚至消除方块效应。<br>（5）样点自适应补偿：解析去方块滤波后的像素的统计特性，为像素添加相应的偏移值，在一定程度上削弱振铃效应。<br>（6）熵编码：将编码控制数据，量化变化系数，帧内预测数据以及运动数据编码为二进制流进行存储或传输。熵编码模块的输出即为原始视频压缩后的码流。<br>相对于以往的视频编码标准，H.264/HEVC的编码性能有了很大的提升，这源于新编码工具的使用和自身独居特色的核心技术。例如基于四叉树的灵活块分割结构，不同角度的帧内预测模式，自适应的运动矢量预测，合并技术Merge，可变尺寸的DCT，模式依赖的DST和性能更好的CABAC，以及新的样点自适应补偿滤波器等。<br>（7）编码单元：H.264/AVC标准中的核心编码单元是宏块，包含一个16×16的亮度块采样，对于一般的视频信源，会伴随两个8×8的色度块采样。而H.265/HEVC采用了编码树单元和编码树块，大小可以由编码器设定，并且可以超越16×16。<br>（8）改进的帧内预测技术：H.264/AVC对4×4的编码块采用9种预测模式，对16×16的编码块采用4种预测模式。H.265/HEVC提供了35种帧内预测模式。<br>（9）先进的帧间预测技术：H.265/HEVC中引入了新的帧间预测技术，包括运动信息融合技术，先进的运动矢量预测技术以及基于Merge的Skip模式。<br>（10）RQT（Residual Quad-tree Transform）技术是基于四叉树结构的自适应变换技术。<br>（11）ACS（Adaptive Cofficient Scanning）技术包括三类：对角扫描，水平扫描和垂直扫描。<br>（12）SAO像素自适应补偿技术。位于去块效率滤波器之后，用于补偿重构像素值，达到减少振铃效应失真的目的。<br>（13） IBDI（Internal Bit Depth Increase）技术，在编码器的输入端将未压缩图像的像素深度由P比特增加到Q比特，在解码器输出端再恢复到P比特。</p>
<h3 id="2-颜色空间"><a href="#2-颜色空间" class="headerlink" title="2 颜色空间"></a>2 颜色空间</h3><h4 id="2-1-RGB"><a href="#2-1-RGB" class="headerlink" title="2.1 RGB"></a>2.1 RGB</h4><h4 id="2-2-YUV"><a href="#2-2-YUV" class="headerlink" title="2.2 YUV"></a>2.2 YUV</h4><p>主要用于优化彩色视频信号的传输，并使其向后兼容老式黑白电视。其中Y表示明亮度，U和V表示色度。色度U反映的是RGB信号蓝色部分与亮度值之间的差异，V反映的是RGB信号红色部分与信号亮度值之间的差异。</p>
<h4 id="2-3-YCbCr：与YUV类似，Y表示明亮度。"><a href="#2-3-YCbCr：与YUV类似，Y表示明亮度。" class="headerlink" title="2.3 YCbCr：与YUV类似，Y表示明亮度。"></a>2.3 YCbCr：与YUV类似，Y表示明亮度。</h4><p>（1）4:4:4：每4个亮度样本都对应4个Cb和4个Cr色度样本。<br>（2） 4:2:2：每2个亮度样本都对应1个Cb和1个Cr色度样本。<br>（3） 4:1:1：水平方向上每4个亮度样本都对应1个Cb和1个Cr色度样本。垂直方向分辨率相同。<br>（4）4:2:0：水平和垂直方向上每4个亮度样本都对应1个Cb和1个Cr色度样本。</p>
<h3 id="3-H-265-HEVC编码视频格式"><a href="#3-H-265-HEVC编码视频格式" class="headerlink" title="3 H.265/HEVC编码视频格式"></a>3 H.265/HEVC编码视频格式</h3><p>不同格式的源视频通过前处理模块转换成统一的数据格式，经过编解码器后再转换成源视频格式。</p>
<h4 id="3-1-编码图像格式"><a href="#3-1-编码图像格式" class="headerlink" title="3.1 编码图像格式"></a>3.1 编码图像格式</h4><p>主要包括矩阵数量及空间关系，图像空间分辨率，像素两化深度等。承载编码图像格式的语法元素属于SPS（序列参数集），SPS表征一组图像CVS（编码视频序列）的共有参数。</p>
<h4 id="3-2-解码图像格式"><a href="#3-2-解码图像格式" class="headerlink" title="3.2 解码图像格式"></a>3.2 解码图像格式</h4><p>除包含图像携带的格式信息，还包括扫描类型、图像类型、色彩空间等信息。</p>
<h3 id="4-编码结构"><a href="#4-编码结构" class="headerlink" title="4 编码结构"></a>4 编码结构</h3><p>视频序列由若干时间连续的图像构成，在压缩之前，先将视频序列分割为若干个小的图像组（GOP）。GOP又分为封闭式GOP和开放式GOP。封闭式GOP以IDR（Instantaneous Decoding Refresh）图像开始，各个GOP之间独立编解码。开放式GOP，第一个GOP中的第一个帧内编码图像为IDR图像，后面GOP中的帧内编码图像可以越过non-IDR图像使用前一个GOP的已编码图像做参考图像。<br>每个GOP又分为很多片（slice），片与片之间进行独立编解码，每个片由一个或多个片段（Slice Segment，SS）组成。此外，H.265/HEVC又引入了树形结构单元（CTU）。每个CTU包括一个亮度树形编码块（CTB）和两个色差树形编码块。<br>一个SS在编码时，先被分割成大小相同的CTU，每一个CTU按照四叉树分割方式被划分为不同类型的编码单元（Coding Unit，CU）。<br>在码流结构方面，H.265/HEVC将属于GOP，Slice层中共用的大部分语法元素游离出来，组成序列参数集（SPS）和图像参数集（PPS）。SPS大致包括解码相关信息，如档次级别，分辨率，时域可分级信息等。PPS包含了一幅图像所用的公共参数，即一幅图像中的所有SS引用同一个PPS。大致内容包括初始图像控制信息，如初始量化参数（QP）、分块信息等。此外，为了兼容标准在其他应用上的拓展，H.265/HEVC的语法架构增加了视频参数集（VPS）。其内容大致包括多个子层共享的语法元素。<br>对于一个SS，通过引用它的PPS，该PPS又引用其对应的SPS，该SPS再引用它所对应的VPS，最终得到SS的公用信息。</p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/1.png" alt="image"></p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/2.png" alt="image"></p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/3.png" alt="image"></p>
<h4 id="4-1-视频参数集（VPS）"><a href="#4-1-视频参数集（VPS）" class="headerlink" title="4.1 视频参数集（VPS）"></a>4.1 视频参数集（VPS）</h4><p>主要用于传输视频分级信息，一个给定的视频序列，无论其每一层的SPS是否相同，都参考相同的VPS。VPS包含的信息主要有：多个子层和操作点共享的语法元素；会话所需要的有关操作点的关键信息，如档次、级别；其他不属于SPS的操作点特性信息。</p>
<h4 id="4-2-序列参数集（SPS）"><a href="#4-2-序列参数集（SPS）" class="headerlink" title="4.2 序列参数集（SPS）"></a>4.2 序列参数集（SPS）</h4><p>对于一段视频码流，其可能包含一个或者多个编码视频序列CVS。SPS的作用就是包含一个CVS中所有编码图像的共享编码参数，SPS通过被PPS引用而作用于编码图像。一个CVS中所有使用的PPS都引用同一个SPS。内容主要包括：1）图像格式信息，如采样格式，图像分辨率，量化深度，裁剪参数等；2）编码参数信息，包括编码块、变换块的最大最小尺寸等；3）与参考图像相关的信息，包括短期参考图像的设置，长期参考图像的使用和数目；4）档次，层和级相关参数；5）时域分集信息，包括时域子层的最大数目，控制传输POC仅为参数；6）可视化可用信息；7）其他信息如当前SPS引用的VPS编好，SPS标识号和SPS扩展信息。</p>
<h4 id="4-3-图像参数集（PPS）"><a href="#4-3-图像参数集（PPS）" class="headerlink" title="4.3 图像参数集（PPS）"></a>4.3 图像参数集（PPS）</h4><p>在编码视频流中，一个CVS包含多幅图像，每幅图像可能包括一个或多个SS，每个SS提供了其所引用的PPS标识号，依次得到相应PPS中的共用信息。对于同一幅图像，其内所有SS都用一个PPS。PPS的主要内容有：1）编码工具的可用性标志，编码工具主要包括符号位隐藏，帧内预测受限，去方块滤波等；2）量化过程相关句法元素；3）Tile相关句法元素；4）去方块滤波相关句法元素；5）片头控制信息；6）其他编码一幅图像可以共用的信息。</p>
<h4 id="4-4-片段层（SS）"><a href="#4-4-片段层（SS）" class="headerlink" title="4.4 片段层（SS）"></a>4.4 片段层（SS）</h4><p>一幅图像可以被分割为一个或多个片（Slice），每个片的压缩数据都是独立的。Slice不能跨过边界来进行帧内或帧间预测，但允许环路滤波器跨过边界进行滤波。使用Slice的目的是为了当数据丢失后能在此保证解码同步。根据编码类型不同，Slice可以分为：<br>（1）I Slice：该Slice的所有CU的编码过程都使用帧内预测。<br>（2）P Slice：P帧中的CU可以使用帧间预测，每个预测块（PB）使用至多一个运动补偿预测信息。<br>（3）B Slice：B帧的CU也可以使用帧间预测，但是每个PB可以使用至多两个运动补偿预测信息。<br>一个独立的Slice可以进一步划分为若干SS，包括一个独立SS和若干个依赖SS，并且以独立SS作为该Slice的开始。独立SS是指它所涉及的句法元素可以由自身确定，依赖SS是指它所涉及的某些句法元素由已解码的独立SS推导得到。一个SS包含整数个CTU，并且这些CTU分布在同一个NAL单元中。<br>H.265/HEVC编码的最高层为SS层，SS层所需要的图像层信息可以通过引用相应的PPS来获得。SS头包含其引用的PPS标识号，同一幅图像中的所有SS引用同一个PPS。</p>
<h4 id="4-5-Tile单元"><a href="#4-5-Tile单元" class="headerlink" title="4.5 Tile单元"></a>4.5 Tile单元</h4><p>H.265/HEVC相对于H.264/AVC的改进之处还在于Tile的提出。一幅图像不仅可以划分为若干个Slice，也可以划分为若干个Tile。即从水平和数值方向将一幅图像分割为若干个矩形区域，每个矩形区域都是一个Tile。每个Tile包含整数个CTU，可以独立解码。Tile提供比CTB更大程度上的并行。<br>通常情况下，每个Tile中包含的CTU的数据是近似相等的。在一幅图像中，可以同时存在某些Slice包含多个Tile和某些Tile中包含多个Slice的情况。</p>
<h4 id="4-6-Slice与Tile"><a href="#4-6-Slice与Tile" class="headerlink" title="4.6 Slice与Tile"></a>4.6 Slice与Tile</h4><p>Slice与Tile划分的目的都是为了进行独立解码，但二者划分方式有所不同。Tile形状基本上为矩形，Slice则为条带状。Slice由一系列的SS组成，一个SS由一系列的CTU组成。Tile则直接由一系列的CTU组成。每个Slice/SS和Tile至少要满足一下两个条件之一：1）一个Slice/SS中的所有CTU属于同一个Tile；2）一个Tile中的所有CTU属于同一个Slice/SS。</p>
<h4 id="4-7-树形编码块（CTU）"><a href="#4-7-树形编码块（CTU）" class="headerlink" title="4.7 树形编码块（CTU）"></a>4.7 树形编码块（CTU）</h4><p>传统的视频编码都是基于宏块实现的。H.265/HEVC标准中引入了树形编码单元CTU，其尺寸由编码器指定，可以大于宏块尺寸。为了灵活高效地表示视频场景中的不同纹理细节、运动变化的视频内容或者视频对象，H.265/HEVC为图像划分定义了一套全新的语法单元，包括编码单元（CU）、预测单元（PU）和变换单元（TU）。</p>
<h5 id="编码单元CU"><a href="#编码单元CU" class="headerlink" title="编码单元CU"></a>编码单元CU</h5><p>在H.264/AVC中，编码块CB的大小是固定的，而在H.265/HEVC中，一个CTB可以直接作为一个CB，也可以进一步以四叉树的形式划分为多个小的CB。亮度CB最大为64×64，最小为8×8。一个亮度CB和相应的色度CB及它们相关的句法元素共同组成一个编码单元CU。</p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/4.png" alt="image"></p>
<h5 id="预测单元PU"><a href="#预测单元PU" class="headerlink" title="预测单元PU"></a>预测单元PU</h5><p>一切与预测有关的信息都定义在预测单元部分，比如帧内预测的方向、帧间预测的分割方式、运动矢量预测以及帧间预测参考图像索引号等都属于PU的范畴。对于一个2N×2N的CU模式，帧内预测单元PU的可选模式有两种，帧间预测单元PU的可选模式有8种：4种对称模式和4种非对称模式。如下图所示。此外还有skip模式，skip模式是帧间预测的一种，当需要编码的运动信息只有运动参数集索引，编码残差信息不需要编码时，为2N×2N skip模式。</p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/5.png" alt="image"></p>
<h5 id="变换单元TU"><a href="#变换单元TU" class="headerlink" title="变换单元TU"></a>变换单元TU</h5><p>是独立完成变换和量化的基本单元。H.265/HEVC突破了原有的变换尺寸限制，可支持大小为4×4~32×32的编码变换。TU的大小依赖于CU，在一个CU内，以四叉树的形式递归划分TU。</p>
<h4 id="4-8-档次、层和级别"><a href="#4-8-档次、层和级别" class="headerlink" title="4.8 档次、层和级别"></a>4.8 档次、层和级别</h4><p>H.264中已经有对档次（profile）和级别（level）的划分，而H.265/HEVC在此基础上又定义了新的概念：层（Tier）。档次主要规定编码器可以采用哪些编码工具或算法，级别则根据解码器负载和存储空间情况对关键参数加以限制。考虑到应用可以根据最大码率和CPB（解码缓冲区）大小来区分，因此有些Level定义了两个Tier：主层（Main Tier）和高层（High Tier）。主层用于大多数应用，高层用于最苛刻的应用。<br>档次：H.265/HEVC中提出了三种档次：Main, Main 10和Main Still Picture。限制条件如下：1）只支持4:2:0色度采样信号；2）使用了Tiles便不能使用WPP，每一个Tile的亮度分辨率至少要256×64；3）Main和Main Still Picture档次支持8位像素深度，Main 10档次则支持10位像素深度，Main Still Picture档次不支持帧间预测。<br>层和级别：H.265/HEVC定义了两个层和13个级，两个层分别为Main Tier和High Tier。4和4以上的8个Level支持High Tier。</p>
<h3 id="5预测编码"><a href="#5预测编码" class="headerlink" title="5预测编码"></a>5预测编码</h3><p>对于视频信号来说，一幅图像的邻近像素之间有着较强的空间相关性，相邻图像之间有很强的时间相关性。采用帧内预测和帧间预测的方式，有效去除视频空域和时域的相关性，编码器对预测后的残差而不是原始像素值进行变换、量化、熵编码由此大幅提高编码效率。</p>
<h4 id="5-1-预测编码原理"><a href="#5-1-预测编码原理" class="headerlink" title="5.1 预测编码原理"></a>5.1 预测编码原理</h4><p>预测编码是指利用已编码的一个或几个样本值，根据某种模型或方法，对当前的样本值进行预测，并对样本真实值和预测值之间的差值进行编码。联合编码和条件编码时两种有记忆信源的有效编码方式。联合编码通常将图像分割成固定的块，将每一个块作为一个信源符号来考察，对每一个块内的像素进行联合编码。联合编码充分利用一个块内像素间的相关性，但未能利用相邻块之间的相关性。条件编码中当前像素的编码依赖于邻近已邻近编码像素，各像素将以滑动窗口的形式进行条件编码，这种方式改善了联合编码的缺陷，图像内邻近像素之间的相关性得到了充分利用。<br>预测编码技术通过预测模型消除橡塑件的相关性，得到的差值信号可以认为没有相关性或相关性很小，因此可以作为无记忆信源进行编码。预测编码的基本过程如下图所示。</p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/6.png" alt="image"></p>
<p>视频预测编码技术主要分为两大类：帧内预测和帧间预测。</p>
<h5 id="5-1-1-帧内预测编码"><a href="#5-1-1-帧内预测编码" class="headerlink" title="5.1.1 帧内预测编码"></a>5.1.1 帧内预测编码</h5><p>Harrison首先在图像编码中研究了帧内预测方法，方法师用先前已编码的像素进行加权平均作为当前像素的预测值。这一基本思想最终被应用于JPEG-LS标准的LOCO-I算法中。后来随着DCT在图像、视频编码中的广泛应用，帧内预测转为在频域进行，如JPEG，H.261，MPEG-I，MPEG-2和H.263等。<br>H.264/AVC标准规定了若干种预测模式，每一种模式都对应一种纹理方向，当前块预测像素由其预测方向上相邻块的边界重建像素生成。为了选择最合适的帧内预测模式，H.264/AVC使用拉格朗日率失真优化（RDO）进行模式选择。H.264/AVC标准以及后来的FRExt扩展层一共规定了3种大小的亮度帧内预测模块：4×4、8×8和16×16。其中4×4、8×8块包含9种预测模式，16×16块包含4种预测模式。色度分量的帧内帧内预测都是基于8×8大小的块进行的，也有4种预测模式。<br>（1）亮度分量的帧内16×16模式<br>帧内16×16模式包含4种预测模式：垂直模式、水平模式、DC模式和Plane模式，如下图所示。垂直模式：当前块预测像素由上方相邻块重建像素产生；水平模式：当前块预测像素由左侧相邻块重建像素产生；DC模式：当前块预测像素都为其所有参考像素的平均值；Plane模式。</p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/7.png" alt="image"></p>
<p>（2）亮度分量帧内4×4模式<br>帧内4×4和8×8块都包含9种预测模式，且两者方法类似。以帧内4×4的9种预测模式为例，包含了8种不同的预测方向以及DC模式：1）垂直模式；2）水平模式；3）DC模式；4）左下对角线模式；5）右下对角线模式；6）垂直向右模式；7）水平向下模式；8）垂直向左模式；9）水平向上模式。<br>（3）8×8色度帧内预测模式<br>色度帧内预测包含4中模式：DC模式、水平模式、垂直模式和Plane模式。<br>最新的H.265/HEVC标准对其进行了进一步发展。一方面，H.265/HEVC使用了更多大小的预测块，以适应高清视频的内容特征；另一方面，H.265/HEVC规定了更多种预测模式，对应于更多种不同的预测方向，以适应更加丰富的纹理。</p>
<h5 id="5-1-2-帧间预测编码"><a href="#5-1-2-帧间预测编码" class="headerlink" title="5.1.2 帧间预测编码"></a>5.1.2 帧间预测编码</h5><p>由于视频序列通常包括较强的时域相关性，因此预测残差通常是“平坦的”，即很多残差值接近于0。将残差信号作为后续模块的输入进行变换、量化、扫描及熵编码，可实现对视频信号的高效压缩。<br>目前主要的视频编码标准帧间预测都采用了基于块的运动补偿技术。主要原理是为当前图像的每个像素块在之前已编码图像中寻找一个最佳匹配块，该过程称为运动估计。其中用于预测的图像称为参考图像，参考块到当前像素块的唯一称为运动向量，当前像素块与参考快的差值称为预测残差。<br>早期的H.261定义了两种类型的图像——I图像和P图像。其中I只能使用帧内编码，而P则可以利用帧间预测编码。此外，为了去除相邻块运动向量之间的相关性，H.261对MV进行了差分编码。在H.261中，P图像的预测方式必须是由前一幅图像预测当前图像，这称为“前向预测”，但实际场景旺旺会产生不可不预测的运动和遮挡，因此当前图像的某些像素块可能无法从之前的图像中找到匹配块。为此，MPEG-1标准中定义了第三类图像——B图像，并规定B可以使用三种预测方式：前向预测、后向预测以及双向预测。这样，B中的一个宏块可以对应两个MV：一个由前向预测得来，另一个由后向预测得来。此外，MPEG-1首次使用了半像素精度的运动估计，其半像素位置的参考像素值可由双线性差值方法产生。<br>面向数字广播电视的标准MPEG-2首次支持了隔行扫描视频，一帧图像包含两个场——顶场和底场。为了适应这种情况，每个帧图像的宏块需要被拆分为两个16×8的块分别进行预测。<br>H.263标准沿用了MPEG-1的双向预测与半像素精度运动估计，并进一步发展了MPEG-2中将一个宏块分成更小的块进行预测的思想。此外，H.263改进了MV的预测机制——用当前块左方、上方及右上方的3个MV的中值来预测当前块的MV。<br>H.264/AVC标准在集成以往标准帧间预测成熟技术和框架的同时，对其进行了进一步细化和改善。为了提高运动补偿的精度，H.264/AVC规定了7种大小的运动补偿块，并且一个宏块内部允许存在不同大小块的组合。编码器可以根据视频内容自适应的选择块大小。此外还使用了1/4像素精度运动估计（色度为1/8像素精度）、多参考图像预测、加权预测以及空域/时域MV预测等。</p>
<h5 id="5-1-3-帧间预测编码关键技术"><a href="#5-1-3-帧间预测编码关键技术" class="headerlink" title="5.1.3 帧间预测编码关键技术"></a>5.1.3 帧间预测编码关键技术</h5><p>（1） 运动估计<br>运动估计准则：1）最小均方误差MSE准则；2）绝对误差和SAD准则；3）最大匹配像素数MPC准则。<br>搜索算法：常用的搜索算法有：全搜索算法，二维对数走索，三步搜索算法等。<br>亚像素精度估计：亚像素精度运动估计意味着需要对参考图像进行插值，好的插值方法能够大幅改善运动补偿的性能。<br>（2） MV预测<br>在大多数图像和视频中，一个运动物体可能会覆盖多个运动补偿块，因此空间域相邻块的运动向量具有较强的相关性。若使用相邻已编码块对当前块MV进行预测，将二者差值进行进行编码，则会大幅节省编码MV所需的比特数。H.264/AVC使用了空域和时域两种MV的预测模式。<br>（3） 多参考图像加权预测<br>对于某些场景，如物理周期性变化，多参考图像可以大幅提高预测精度。早起视频编码标准只支持单个参考图像，H.263+开始支持多参考图像预测技术，而H.264/AVC标准最多支持15个参考图像。为了权衡编码效率与编码时间，一般情况下都采用4~6个参考图像。<br>此外，H.264/AVC还使用了加权预测技术，加权预测表示预测像素可以用一个或两个参考图像中的像素与加权系数相乘得出。</p>
<h4 id="5-2-H-265-HEVC帧内预测"><a href="#5-2-H-265-HEVC帧内预测" class="headerlink" title="5.2 H.265/HEVC帧内预测"></a>5.2 H.265/HEVC帧内预测</h4><h5 id="5-2-1-亮度帧内预测模式"><a href="#5-2-1-亮度帧内预测模式" class="headerlink" title="5.2.1 亮度帧内预测模式"></a>5.2.1 亮度帧内预测模式</h5><p>H.265/HEVC亮度分量帧内预测支持5中大小的PU：4×4，8×8，16×16，32×32和64×64，其中每一种大小的PU都对应35种预测模式，包括Planar模式，DC模式以及33种角度模式。所有的预测模式都是用相同的模板。</p>
<p>（1）Planar模式：由H.264/AVC中的Plane模式发展而来，它适用于像素值缓慢变化的区域，Planar模式使用水平和垂直方向的两个线性滤波器，并将二者的平均值作为当前块像素的预测值。<br>（2）DC模式：适用于大面积平坦区域，其做法与H.264/AVC基本相同。当前块预测值可由其左侧和上方参考像素的平均值得到。</p>
<p>（3）角度模式：相比于H.264/AVC使用了8种不同的预测方向想，H.265/HEVC则进一步细化了这些预测方向，规定了33中角度预测模式。上图给出了这33种预测角度模式。</p>
<h5 id="5-2-2-亮度模式编码"><a href="#5-2-2-亮度模式编码" class="headerlink" title="5.2.2 亮度模式编码"></a>5.2.2 亮度模式编码</h5><p>H.265/HEVC建立了一个帧内预测模式候选列表candModeList，表中有三个候选预测模式，用于存储相邻PU的预测模式。</p>
<h5 id="5-2-3-色度模式编码"><a href="#5-2-3-色度模式编码" class="headerlink" title="5.2.3 色度模式编码"></a>5.2.3 色度模式编码</h5><p>H.265/HEVC色度分量帧内预测一共有5种模式：Planar模式，垂直模式，水平模式，DC模式以及对应亮度分量的预测模式。</p>
<h5 id="5-2-4-帧内预测过程"><a href="#5-2-4-帧内预测过程" class="headerlink" title="5.2.4 帧内预测过程"></a>5.2.4 帧内预测过程</h5><p>在H.265/HEVC中，35种预测模式是在PU的基础上定义的，而具体帧内预测过程的实现则是以TU为单位的。标准规定PU可以以四叉树的形式划分TU，且一个PU内的所有TU共享同一种预测模式。H.265/HEVC帧内预测可以分为3个步骤：1）判断当前TU相邻参考像素是否可用并做相应处理；2）对参考像素进行滤波；3）根据滤波后的参考像素计算当前TU的预测像素值。<br>（1）相邻参考像素的获取<br>对于一个N×N的TU，参考像素区域可分为5个部分：左下，左侧，左上，上方和右上，一共4N+1个像素点。若该TU位于图像边界，或Slice、Tile的边界（H.265/HEVC规定帧内编码中相邻Slice和Tile不能相互参考），则相邻参考像素可能不存在或不可用。另外在某些情况下左下和右上区域尚未编码时，这些参考像素也是不可用的。<br>当参考像素不存在或者不可用时，H.265/HEVC标准会使用最相邻的像素进行填充。若所有区域参考像素都不可用，则参考像素都用固定值填充。<br>（2）参考像素的滤波<br>H.264/AVC在帧内预测时对某些模式下的参考像素进行了滤波，以更好地利用临近像素之间的相关性，提高预测精度。H.265/HEVC沿用了这一做法。<br>一方面，H.265/HEVC针对大小不同的TU选择了不同数量的模式进行滤波。DC模式以及4×4大小的TU都不需要进行参考像素滤波，32×32的TU除水平模式，垂直模式之外的所有角度模式以及Planar模式，其他都需要参考像素滤波，16×16TU进一步除去最接近水平和垂直方向的四个模式。8×8TU仅对3个45°倾斜方向的模式以及Planar模式进行参考像素滤波。<br>另一方面，H.265/HEVC增加使用了一种强滤波方法。<br>（3）预测像素的计算</p>
<h4 id="5-3-H-265-HEVC帧间预测"><a href="#5-3-H-265-HEVC帧间预测" class="headerlink" title="5.3 H.265/HEVC帧间预测"></a>5.3 H.265/HEVC帧间预测</h4><h5 id="5-3-1-运动估计"><a href="#5-3-1-运动估计" class="headerlink" title="5.3.1 运动估计"></a>5.3.1 运动估计</h5><p>在基于块运动补偿的视频编码框架中，运动搜索是最为重要的环节之一，同时也是编码端最耗时的模块。H.265/HEVC官方测试编码器HM10.0给出了两种搜索算法：全搜索和TZSearch算法。TZSearch是H.265/HEVC新出现的技术，步骤为：1）确定其实搜索点：H.265/HEVC采用AMVP，AMVP给出若干个候选测试MV，编码器从中选择率失真代价最小的的作为预测MV。将其指向的位置作为起始搜索点。2）以步长1开始，按照菱形模板或正方形模板在搜索范围内进行搜索，其中步长以2的幂次递增，选出率失真代价最小的点作为该步骤的搜索结果。3）若上一步得到的最优点步长为1，则需要在该店周围做两点搜索，主要目的是补充搜索最优点周围尚未搜索的点。4）若最优点步长大于一定的阈值，则以该最优点为中心，在一定范围内做全搜索。5）以最优点为新的启示搜索点，重复2~4，细化搜索。TZSearch与全搜索算法相比性能上略有降低，但搜索时间仅为全搜索的一半。<br>在实际场景中，由于物体运动距离不一定是像素的整数倍，因此需要将运动估计的精度提升到亚像素级别。H.265/HEVC沿用了上一代标准H.264/AVC所使用的1/4像素精度运动估计，并进一步发展了其亚像素差值算法，如亮度分量差值算法，色度分量插值算法等。</p>
<h5 id="5-3-2-MV预测技术"><a href="#5-3-2-MV预测技术" class="headerlink" title="5.3.2 MV预测技术"></a>5.3.2 MV预测技术</h5><p>空域上相邻块的MV具有较强的相关性，同时MV在时域上也有一定的相关性。若利用空域或时域上相邻块的MV对当前MV进行预测，仅对残差进行编码，则能够大幅节省MV的编码比特数。H.265/HEVC在MV的预测方面提出了两种技术——Merge技术和AMVP技术。<br>（1）Merge技术：Merge模式会为当前PU建立一个MV候选列表，列表中存在5个候选MV，通过遍历这5个候选MV，并进行率失真代价的计算，最终选取率失真代价最小的一个作为该Merge模式的最优MV。Merge模式建立的MV候选列表中包含了空域和时域两种情形。<br>（2）AMVP技术：高级运动向量预测利用空域时域上运动向量的相关性为当前PU建立了候选MV列表，编码器从中选出最优的预测MV，并对MV进行差分编码，解码器通过建立相同的列表，仅需要运动向量残差（MVD）与预测MV在该列表中的序号即可计算当前PU的MV。</p>
<h5 id="5-3-3-加权预测"><a href="#5-3-3-加权预测" class="headerlink" title="5.3.3 加权预测"></a>5.3.3 加权预测</h5><p>加权预测可以 用于修正P帧或B帧中的运动补偿预测像素，H.265/HEVC标准规定了两种加权预测方法——默认加权预测以及Explicit加权预测。</p>
<h4 id="5-4-PCM模式"><a href="#5-4-PCM模式" class="headerlink" title="5.4 PCM模式"></a>5.4 PCM模式</h4><p>H.265/HEVC中有一种特殊的编码模式——PCM模式。在该模式下，编码器直接传输一个CU的像素值，而不经过预测、变换等其他操作。对一些特殊的情况，如图像内容极不规则或量化参数QP非常小时，该模式与传统的“帧内—变换—量化—熵编码”相比编码效率可能更高，此外，PCM模式还适用于无损编码情形。</p>
<h3 id="6-变换编码"><a href="#6-变换编码" class="headerlink" title="6 变换编码"></a>6 变换编码</h3><h4 id="6-1-离散余弦变换"><a href="#6-1-离散余弦变换" class="headerlink" title="6.1 离散余弦变换"></a>6.1 离散余弦变换</h4><p>傅里叶变换表明，任何信号都能表示为多个不同振幅和频率的正弦波或余弦波信号的叠加。对二维DCT基图像来说，其中左上角小图像表示水平和垂直空间频率均为零时的基图像，其余分别对应于不同水平和垂直空间频率的基图像。对于灰度值变化缓慢的像素块来说，经过DCT后绝大部分能量都集中在在左上角的低频系数中。实际上，大多数图像包含更多的低频分量，并且可以利用人眼对图像高频细节相对不敏感的特性，对高能量的低频系数进行较为精细的量化和处理，而对低能量的高频系数进行粗略的量化或掩盖，这样可以较好地压缩图像而不会造成明显的主观质量下降。<br>随着变换尺寸的增大，DCT去相关性能越来越好，但提升幅度逐渐变缓。考虑到DCT的计算复杂度会随着变换尺寸的增大而大幅提高，因此许多较早的图像与食品编码标准都采用8×8 DCT作为其变换编码方案。</p>
<h5 id="6-1-1-整数DCT"><a href="#6-1-1-整数DCT" class="headerlink" title="6.1.1 整数DCT"></a>6.1.1 整数DCT</h5><p>DCT中余弦函数的存在使得DCT过程必须使用浮点数，这样不可避免地会带来舍入误差以及编解码正反变换失配的问题。针对该问题，从H.264/AVC开始采用整数DCT。<br>H.265/HEVC沿用了H.264/AVC所采用的的整数DCT技术，但其变换矩阵与H.264/AVC相比有所不同。H.265/HEVC使用了4种不同尺寸的整数DCT。</p>
]]></content>
      <categories>
        <category>视频编码</category>
      </categories>
      <tags>
        <tag>H.265/HEVC</tag>
        <tag>视频编码</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode专题--DFS</title>
    <url>/2022/05/02/Leetcode%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94DFS/</url>
    <content><![CDATA[<p>Leetcode 专题训练：<strong>数组深度优先搜索（DFS）</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#94">94</a></td>
<td style="text-align:center"><font color="green">简单</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#98">98</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#99">99</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">恢复二叉搜索树</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#113">113</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">路径总和 II</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#114">114</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#116">116</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">填充每个节点的下一个右侧节点指针</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#124">124</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">二叉树中的最大路径和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#297">297</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化与反序列化</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#329">329</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener"> 矩阵中的最长递增路径</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#685">685</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/redundant-connection-ii/" target="_blank" rel="noopener">冗余连接 II</a></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历<span id="94"></span></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<p>解法：<strong>递归（DFS）</strong></p>
<ul>
<li>先递归遍历左子树，将当前节点加入 vector，然后递归遍历右子树</li>
<li>终止条件：当前节点为 NULL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        traverse(node-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        result.push_back(node-&gt;val); <span class="comment">// 将当前值加入到 vector</span></span><br><span class="line">        traverse(node-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树<span id="98"></span></h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 小于 当前节点的数。</li>
<li>节点的右子树只包含 大于 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>解法：<strong>中序遍历</strong></p>
<ul>
<li>注意到二叉搜索树 BST 的中序遍历序列是升序的</li>
<li>不需要记录整个遍历序列，只需要依次比较当前值与前一个值即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre_val = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> left = check(node-&gt;left); <span class="comment">// 检查左子树是不是 BST</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &gt; pre_val) &#123; <span class="comment">// 若中序遍历序列不是升序，则 false</span></span><br><span class="line">            pre_val = node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> right = check(node-&gt;right); <span class="comment">// 检查右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树<span id="99"></span></h2><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。</p>
<p><strong>解法：中序遍历</strong></p>
<ul>
<li>中序遍历 BST，得到的数组原本应该是有序的，由于交换了两个位置：<ul>
<li>交换位置相邻：则有一个逆序对</li>
<li>交换位置不相邻：则有两个逆序对</li>
</ul>
</li>
<li>使用 pair&lt; TreeNode*, TreeNode*&gt; rev_pair 来记录逆序对<ul>
<li>若有一对，则交换两个 node 的值</li>
<li>若有两对，则交换第一对的第一个，和第二对的第二个节点值 </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre_node = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; rev_pair; <span class="comment">// 存储逆序的节点对</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        traverse_inorder(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rev_pair.size() == <span class="number">1</span>) &#123; <span class="comment">// 相邻的位置被交换，只有一对逆序对</span></span><br><span class="line">            TreeNode* node1 = rev_pair[<span class="number">0</span>].first;</span><br><span class="line">            TreeNode* node2 = rev_pair[<span class="number">0</span>].second;</span><br><span class="line">            swap(node1-&gt;val, node2-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rev_pair.size() == <span class="number">2</span>) &#123; <span class="comment">// 不相邻的位置被交换，有两个逆序对</span></span><br><span class="line">            TreeNode* node1 = rev_pair[<span class="number">0</span>].first;</span><br><span class="line">            TreeNode* node2 = rev_pair[<span class="number">1</span>].second;</span><br><span class="line">            swap(node1-&gt;val, node2-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse_inorder</span><span class="params">(TreeNode* node)</span> </span>&#123; <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        traverse_inorder(node-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre_node &amp;&amp; node-&gt;val &lt; pre_node-&gt;val) &#123;</span><br><span class="line">            rev_pair.push_back(&#123;pre_node, node&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        pre_node = node;</span><br><span class="line"></span><br><span class="line">        traverse_inorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a>路径总和 II<span id="113"></span></h2><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p><strong>解法：DFS + 递归</strong></p>
<ul>
<li>定义路径 path 和 当前路径总和 sum，以及 返回值 result</li>
<li>若 当前节点为 NULL，return，若当前为叶子节点，特殊处理</li>
<li>否则，遍历左节点，回溯一次</li>
<li>遍历右节点，回溯</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 记录遍历的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        traverse(root, <span class="number">0</span>, targetSum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="keyword">int</span> sum, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 叶子节点，终止迭代</span></span><br><span class="line">            sum += node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(sum == targetSum) &#123;</span><br><span class="line">                path.emplace_back(node-&gt;val);</span><br><span class="line">                result.emplace_back(path);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) traverse(node-&gt;left, sum + node-&gt;val, targetSum);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) traverse(node-&gt;right, sum + node-&gt;val, targetSum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表<span id="114"></span></h2><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>
<p><strong>解法一：前序遍历</strong></p>
<ul>
<li>使用前序遍历，将遍历的数组保存下来</li>
<li>将遍历的数组重建成单链表</li>
<li>空间复杂度 O(N)，与 O(1) 要求不符</li>
</ul>
<p><strong>解法二：前序遍历 + 同步展开</strong></p>
<ul>
<li>前序遍历使用 stack 进行辅助，每次从栈中 pop 出一个节点，如果当前节点不为空，则<ul>
<li>将右节点 push 到栈中</li>
<li>将左节点 push 到栈中</li>
</ul>
</li>
<li>同步展开，维护上一个访问的节点 prev，每次访问一个节点 curr<ul>
<li>prev 左节点设置为 NULL，右节点指向 curr</li>
<li>更新 prev</li>
</ul>
</li>
<li>时间复杂度 O(N)，空间复杂度 O(n)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line"></span><br><span class="line">        TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty()) &#123;</span><br><span class="line">            TreeNode* curr = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right) stk.push(curr-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left) stk.push(curr-&gt;left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                prev-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                prev-&gt;right = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法三：寻找前驱结点</strong></p>
<p>前序遍历都需要存储节点，因此不满足空间复杂度 O(1) 的要求。</p>
<ul>
<li>对于当前节点，如果其左子树不为空，则在其左子树中找到最右边的节点，作为<strong><em>前驱结点</em></strong></li>
<li>将当前节点 curr 的右指针指向前驱结点的右子节点</li>
<li>然后将 curr 的左节点 变成 右节点，并将左节点置空</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                TreeNode* pre_node = curr-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(pre_node-&gt;right != <span class="literal">NULL</span>) &#123; <span class="comment">// 找到左子树的最右节点（前驱结点）</span></span><br><span class="line">                    pre_node = pre_node-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pre_node-&gt;right = curr-&gt;right; <span class="comment">// 将右子树接到前驱结点</span></span><br><span class="line">                curr-&gt;right = curr-&gt;left; <span class="comment">// 左子树换到右边</span></span><br><span class="line">                curr-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针<span id="116"></span></h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<p><strong>解法一：层序遍历</strong></p>
<ul>
<li>借助队列，进行层序遍历</li>
<li>时间复杂度 O(N)，空间复杂度 O(1)</li>
</ul>
<p><strong>解法二：借助 next 指针</strong></p>
<ul>
<li>对于当前节点<ul>
<li>有两个子节点的情况，将下一层的左节点指向右节点</li>
<li>当前 next 不为 NULL 的情况，将 curr 右节点 指向 curr-&gt;next 的左节点</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        Node* left_first = root; <span class="comment">// 每一层最左边的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left_first-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node* head = left_first;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                head-&gt;left-&gt;next = head-&gt;right; <span class="comment">// 同一个父节点的两个节点</span></span><br><span class="line">                <span class="keyword">if</span>(head-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 不同父节点的两个相邻节点</span></span><br><span class="line">                    head-&gt;right-&gt;next = head-&gt;next-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            left_first = left_first-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和<span id="124"></span></h2><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><strong>解法：递归</strong></p>
<ul>
<li>递推关系式：当前节点的路径最长 = max( 当前 val, 左节点最长 + val，val + 右节点最长，左节点最长 + val + 右节点最长)</li>
<li>对于当前节点，如果是叶子节点，则返回当前 val</li>
<li>计算左子树最长路径 left 和右子树最长路径 right</li>
<li>结果取 max(result, val, val + left, val + right, val + left + right) 的最大值</li>
<li>返回值取 max(val, val + left, val + right) 的最大值，这是因为一旦返回，意味着当前不能左右子树都访问而只能选择一路</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> result = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        longest_path(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longest_path</span><span class="params">(TreeNode* node)</span> </span>&#123; <span class="comment">// 以 node 为中间节点的最长路径</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 叶子节点返回当前 val</span></span><br><span class="line">            result = max(node-&gt;val, result);</span><br><span class="line">            <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) left = longest_path(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) right = longest_path(node-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = max(node-&gt;val, max(node-&gt;val + left, max(node-&gt;val + right, node-&gt;val + left + right)));</span><br><span class="line">        result = max(length, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(node-&gt;val, max(node-&gt;val + left, node-&gt;val + right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化<span id="297"></span></h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>解法：层次遍历</strong></p>
<ul>
<li>使用队列辅助进行层次遍历，不同元素用 “,” 分隔，空节点用 # 标识</li>
<li>序列化<ul>
<li>前序遍历整个树，先存当前节点，再存左节点，然后是右节点</li>
</ul>
</li>
<li>反序列化<ul>
<li>根据 “,” 分割当前 string，以 list 存储</li>
<li>以 list 第一个元素为当前节点，新建一个节点</li>
<li>去除首个元素后，递归建立左子树和右子树</li>
<li>遇到 “#” 后返回 NULL</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str + <span class="string">","</span> + serialize(root-&gt;left) + <span class="string">","</span> + serialize(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123; <span class="comment">// 将序列化字符串转成字符串数组</span></span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; nums; </span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] == <span class="string">','</span>) &#123;</span><br><span class="line">                nums.push_back(str);</span><br><span class="line">                str.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> str += data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!str.empty()) &#123; <span class="comment">// 将最后一个元素放入数组</span></span><br><span class="line">            nums.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; &amp;data)</span> </span>&#123; <span class="comment">// 对字符串数组反序列化</span></span><br><span class="line">        <span class="keyword">if</span>(data.front() == <span class="string">"#"</span>) &#123;</span><br><span class="line">            data.erase(data.begin());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* curr = <span class="keyword">new</span> TreeNode(stoi(data.front()));</span><br><span class="line">        data.erase(data.begin());</span><br><span class="line">        curr-&gt;left = deserialize(data);</span><br><span class="line">        curr-&gt;right = deserialize(data);</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a>矩阵中的最长递增路径<span id="329"></span></h2><p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p>
<p><strong>解法：记忆化 DFS</strong></p>
<ul>
<li>从矩阵中每一个单元格进行 DFS，即找到从当前单元格开始的最长递增路径</li>
<li>对于当前单元格，尝试遍历四个方向，在每一个合理的方向上：<ul>
<li>若移动后的值 大于 当前值，则返回 移动后的最大路径 + 1</li>
<li>在遍历时，使用 length 矩阵进行记忆，若当前单元格已经遍历过，直接返回当前单元格的最长路径</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">length</span><span class="params">(matrix.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                result = max(result, dfs(matrix, i, j, length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回以单元格 (row, col) 为起点的最长递增路径</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length[row][col] &gt; <span class="number">0</span>) <span class="keyword">return</span> length[row][col]; <span class="comment">// 若当前已经遍历过，则直接返回</span></span><br><span class="line">        length[row][col]++; <span class="comment">// 长度至少为 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next_row = row + direction[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> next_col = col + direction[i][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(next_row &gt;= <span class="number">0</span> &amp;&amp; next_row &lt; matrix.size() &amp;&amp; next_col &gt;= <span class="number">0</span> &amp;&amp; next_col &lt; matrix[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[next_row][next_col] &gt; matrix[row][col]) &#123;</span><br><span class="line">                    length[row][col] = max(length[row][col], <span class="number">1</span> + dfs(matrix, next_row, next_col, length));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="冗余连接-II"><a href="#冗余连接-II" class="headerlink" title="冗余连接 II"></a>冗余连接 II<span id="685"></span></h2><p>在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode经典算法</title>
    <url>/2022/04/30/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Leetcode中常用算法：KMP算法 + 树状数组 + 并查集</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">例题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#1">KMP算法</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><a href="#2">树状数组</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><a href="#3">并查集</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/redundant-connection-ii/" target="_blank" rel="noopener">685. 冗余连接 II</a></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法<span id="1"></span></h2><p>KMP算法是一种字符串匹配算法，时间复杂度为 O(m + n)，具体实现通过一个 next 数组实现。</p>
<p>KMP算法的核心是一个成为部分匹配表（Partial Match Table，PMT）的数组，一般叫做 next 数组，next 数组长度与待匹配的模式字符串长度相同。</p>
<p>首先定义两个名词：</p>
<ul>
<li>前缀：“Harry” 的前缀 包括：{“H”, “Ha”, “Har”, “Harr”}</li>
<li>后缀：”Harry” 的后缀包括：{“array”, “rry”, “ry”, “y”}</li>
</ul>
<h3 id="next-数组的含义"><a href="#next-数组的含义" class="headerlink" title="next 数组的含义"></a>next 数组的含义</h3><p>next 数组：在当前位置 i 失配的情况下，跳到第 next[i] 个位置。 next[i] 也是前缀和后缀最长的公共元素长度，从而使得当当前位置不匹配时，将前缀直接移动到后缀所在的位置。</p>
<p>例如下表所示，对于index = 3，字符串为 “ababa”，相同的前缀和后缀为 “aba”，所以 next[3] = 3.</p>
<p>距离：“abababca”</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>char</strong></td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>a</td>
</tr>
<tr>
<td><strong>next</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>对于一个模式串，求解 next 数组的算法为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// generate next for a pattern</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(s[i] != s[j] &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>]; <span class="comment">// prev elem</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>next 数组构造的规则：</p>
<ul>
<li>初始化：next[0] = 0; j = 0; 然后从 1 遍历到模式串末尾。<ul>
<li>遍历索引 <strong>i</strong> 表示当前模式串的索引</li>
<li>索引 <strong>j</strong> 表示前面 j 个字符是已经匹配了的   </li>
</ul>
</li>
<li>若当前字符与前一个字符匹配，也就是 s[i] == s[j]<ul>
<li>当前位置的 next 值是前一个 字符的 next 加一：next[i] = j + 1;</li>
<li>更新 j : j++</li>
</ul>
</li>
<li>若当前字符与 j 对应的不匹配，则 j 跳到前一个字符匹配的位置：j = next[ j - 1 ]</li>
<li>若 j == 0，说明前面都不匹配，next[i] = 0</li>
</ul>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组<span id="2"></span></h2><p><strong>树状数组</strong>是一种可以动态维护序列前缀和的数据结构，主要功能有：</p>
<ul>
<li>单点更新：update(i, val)：把序列 i 位置的数字加上一个值 val。</li>
<li>区间查询：prefixSum(i)：查询 [1, i] 区间的区间和，即 i 的位置的前缀和。</li>
<li>区间求和：sumRange(int i, int j)：求原数组闭区间 [i, j] 的和</li>
</ul>
<p>本质上并不是一棵树，而是根据数字的二进制表示来对数组中的元素进行逻辑上的分层存储。</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_b76dd0db487add64877ef27de65496a4.png" alt="image-20200927095842317" style="zoom:60%;"></p>
<p>从图中可以看出，每一层的末尾 0 的个数是相同的，且 0 的个数与前置 1 代表了覆盖的长度。如第一层只有 0 个0，代表覆盖长度为 1，第二层末尾都是1 个 0，覆盖长度均为 2。归纳发现</p>
<ul>
<li>t[x] 节点的覆盖长度等于 lowbit(x)</li>
<li>t[x] 父亲节点为 t[x + lowbit(x)]  // 用于更新一个值</li>
<li>t[x] 左侧上一级节点为 t[x - lowbit(x)] //用于计算前缀和</li>
<li>整棵树的深度为 logn + 1</li>
</ul>
<p>修改和查询的时间复杂度都是 O(log n )，其中 n 是需要维护的前缀和的序列的长度。</p>
<p>解析链接：<a href="https://www.cnblogs.com/xenny/p/9739600.html" target="_blank" rel="noopener">https://www.cnblogs.com/xenny/p/9739600.html</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// """树状数组的模板"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit_tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; origin;  <span class="comment">// 记录原始数组，从而能够在update的时候计算出位置i处的值的变化量</span></span><br><span class="line">                         <span class="comment">// bit_tree是该数组的反应</span></span><br><span class="line">    <span class="comment">// C[i] = A[i - 2^k+1] + A[i - 2^k+2] + ... + A[i];   //k为i的二进制中从最低位到高位连续零的长度</span></span><br><span class="line">    <span class="comment">// 其中 C 为 bit_tree 的数值，A 为 origin 的数值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">low_bit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 二进制表达式中最低位的 1 所代表的值，比如 6 = 0110, 则lowbit(6) = 0010 = 2</span></span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定原数据有边界下标值，求其前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">prefixSum</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result += <span class="keyword">this</span>-&gt;bit_tree[index];</span><br><span class="line">            index -= low_bit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BIT(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;origin.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;origin.insert(<span class="keyword">this</span>-&gt;origin.end(), nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;bit_tree.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;bit_tree.insert(<span class="keyword">this</span>-&gt;bit_tree.end(), nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化bit_tree</span></span><br><span class="line">        <span class="comment">// 即根据给定i，更新所有能管到i的右边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bit_tree.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + low_bit(i);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; bit_tree.size()) bit_tree[j] += bit_tree[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意此处是将i下标的值更新为val，而不是在原基础上增加val</span></span><br><span class="line">    <span class="comment">// 但是原理还是一样的，先求出其变化值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dec = val - <span class="keyword">this</span>-&gt;origin[i];  <span class="comment">// 注意bit_tree中记录的是区间和，origin记录的才是bit_tree对应的原始数组</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;origin[i] = val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="keyword">this</span>-&gt;bit_tree.size())&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;bit_tree[i] += dec;</span><br><span class="line">            i += low_bit(i); <span class="comment">// 找到当前节点 i 的父亲节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求原数组闭区间[i,j]的和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefixSum(j) - prefixSum(i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集<span id="3"></span></h2><p>并查集是一种树形的数据结构，用于处理一些不相交的集合的合并和查询问题。</p>
<p><a href="https://blog.csdn.net/weixin_44176696/article/details/106434770" target="_blank" rel="noopener">CSDN 教程</a></p>
<p><strong>思想</strong>：用一个数组表示整片森林，树的根节点标识了一个集合，只需要找到某个元素的树根，就能确定其在哪个集合里。</p>
<p>并查集的功能：</p>
<ul>
<li>合并两个集合</li>
<li>将一个元素并入某一个集合</li>
<li>判断两个元素是否属于同一个集合</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line">    UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; </span><br><span class="line">            parent[i] = i; <span class="comment">// 初始化，每个人的最终父节点都是自己</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 查找 index 节点的最终父节点，也即其所在的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == parent[idx]) <span class="keyword">return</span> idx; <span class="comment">// 若该节点的最终父节点是自己，返回</span></span><br><span class="line">        <span class="keyword">return</span> find(parent[idx]); <span class="comment">// 否则不断去查找父节点的最终父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        parent[find(u)] = find(v); <span class="comment">// 认新的父节点，即让 u 的最终父节点认 v 的最终父节点当父亲</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch入门之MNIST分类实例</title>
    <url>/2018/09/03/Pytorch%E5%85%A5%E9%97%A8%E4%B9%8BMNIST%E5%88%86%E7%B1%BB%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>手写体数字识别，MNIST分类实例。<br><a id="more"></a></p>
<p>初学机器学习，尝试做了一个简单的手写数字识别。本实例选用的是MNIST数据集，基于卷积神经网络，通过两个卷积层，两个池化层和两个全连接层，实现了手写体数字识别。实际测试识别准确率达到98%。这里分享一下我的思路和代码，以期为其他初学者提供一点简单的思路。</p>
<p>点击查看<a href="https://github.com/KayChou/KayChou.github.io/blob/master/2018/09/03/Pytorch%E5%85%A5%E9%97%A8%E4%B9%8BMNIST%E5%88%86%E7%B1%BB%E5%AE%9E%E4%BE%8B/MNIST.py" target="_blank" rel="noopener"> Source Code</a></p>
<p>本实例主要有以下四个步骤：</p>
<blockquote>
<ul>
<li>导入MNIST数据集。</li>
<li>定义网络模型。</li>
<li>模型训练。</li>
<li>模型测试。</li>
</ul>
</blockquote>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>本实例运行环境为：python3 + torch。需要导入的库如下所示。在运行本实例前，请确保以下库均安装成功。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torchvision.datasets <span class="keyword">as</span> datasets</span><br><span class="line"><span class="keyword">import</span> torch.utils.data</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br></pre></td></tr></table></figure>
<h2 id="导入MNIST数据集"><a href="#导入MNIST数据集" class="headerlink" title="导入MNIST数据集"></a>导入MNIST数据集</h2><p>MNIST（Mixed National Institute of Standards and Technology database）是一个计算机视觉数据集，它包含70000张手写数字的灰度图片，其中每一张图片包含 28*28 个像素点（如下图所示）。每一张图片都有对应的标签，也就是图片对应的数字。</p>
<p><img src="/2018/09/03/Pytorch入门之MNIST分类实例/MNIST-Matrix.png" alt="image"></p>
<p>数据集被分成两部分：60000 行的训练数据集（mnist.train）和10000行的测试数（mnist.test）。<br>其中：60000 行的训练集分拆为 55000 行的训练集和 5000 行的验证集。</p>
<p><img src="/2018/09/03/Pytorch入门之MNIST分类实例/mnist-train-xs.png" alt="image"></p>
<p>导入MNIST数据集的函数定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load training and test data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(path)</span>:</span></span><br><span class="line">​    train_data = datasets.MNIST(root=path,</span><br><span class="line">​                                train=<span class="literal">True</span>,</span><br><span class="line">​                                transform=transforms.Compose(</span><br><span class="line">​                                    [transforms.ToTensor(),</span><br><span class="line">​                                     transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))]),</span><br><span class="line">​                                target_transform=<span class="literal">None</span>,</span><br><span class="line">​                                download=<span class="literal">True</span>)</span><br><span class="line">​    train = torch.utils.data.DataLoader(train_data,</span><br><span class="line">​                                        batch_size=<span class="number">64</span>,</span><br><span class="line">​                                        shuffle=<span class="literal">True</span>,</span><br><span class="line">​                                        num_workers=<span class="number">0</span>)</span><br><span class="line">​    test_data = datasets.MNIST(root=path,</span><br><span class="line">​                               train=<span class="literal">False</span>,</span><br><span class="line">​                               transform=transforms.Compose(</span><br><span class="line">​                                   [transforms.ToTensor(),</span><br><span class="line">​                                    transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))]),</span><br><span class="line">​                               target_transform=<span class="literal">None</span>,</span><br><span class="line">​                               download=<span class="literal">True</span>)</span><br><span class="line">​    test = torch.utils.data.DataLoader(test_data,</span><br><span class="line">​                                       batch_size=<span class="number">64</span>,</span><br><span class="line">​                                       shuffle=<span class="literal">True</span>,</span><br><span class="line">​                                       num_workers=<span class="number">0</span>)</span><br><span class="line">​    <span class="keyword">return</span> train, test</span><br></pre></td></tr></table></figure>
<p>该函数传入参数为MNIST数据集的存放路径，输出分别为训练数据集和测试数据集。这里每次训练的图片数量batch_size选为64.</p>
<h2 id="定义网络模型"><a href="#定义网络模型" class="headerlink" title="定义网络模型"></a>定义网络模型</h2><p>本实例中用到的网络模型由两个卷积层，两个池化层和两个全连接层组成。</p>
<p>第一层卷积层输入channel数为1，输出channel数选为10，卷积核大小为5*5。输入为64*1*28*28的张量，输出为64*10*24*24的张量。经过一个2*2的最大池化层，输出张量规模为64*10*12*12。</p>
<p>第二层卷积层输入channel数为10，输出channel数选为20，卷积核大小为5*5。输入为64*10*12*12的张量，输出为64*20*8*8的张量。经过一个2*2的最大池化层，输出张量规模为64*10*4*4。</p>
<p>经过两层卷积后，将所得张量经过两个全连接层，线性映射为1*10的张量，其中每个元素表示该张图片属于相应类别的概率。</p>
<p>网络模型的定义如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">​    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">​        super(Net, self).__init__()</span><br><span class="line">​        self.conv1 = nn.Conv2d(in_channels=<span class="number">1</span>,</span><br><span class="line">​                               out_channels=<span class="number">10</span>,</span><br><span class="line">​                               kernel_size=<span class="number">5</span>)</span><br><span class="line">​        self.conv2 = nn.Conv2d(in_channels=<span class="number">10</span>,</span><br><span class="line">​                               out_channels=<span class="number">20</span>,</span><br><span class="line">​                               kernel_size=<span class="number">5</span>)</span><br><span class="line">​        self.conv2_drop = nn.Dropout2d()</span><br><span class="line">​        self.fc1 = nn.Linear(<span class="number">320</span>, <span class="number">50</span>)</span><br><span class="line">​        self.fc2 = nn.Linear(<span class="number">50</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = F.max_pool2d(x, kernel_size=<span class="number">2</span>)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">    </span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.max_pool2d(x, kernel_size=<span class="number">2</span>)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">    </span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">320</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.dropout(x, training=self.training)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Train the net</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(model, epoch, train_loader, optimizer)</span>:</span></span><br><span class="line">​    model.train()</span><br><span class="line">​    <span class="keyword">for</span> idx, (data, target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">​        optimizer.zero_grad()</span><br><span class="line">​        output = model(data)</span><br><span class="line">​        loss = F.nll_loss(output, target)</span><br><span class="line">​        loss.backward()</span><br><span class="line">​        optimizer.step()</span><br><span class="line">​        <span class="keyword">if</span> idx % <span class="number">50</span> == <span class="number">49</span>:</span><br><span class="line">​            print(<span class="string">'Train epoch: %d   Loss: %.3f    '</span> % (epoch+<span class="number">1</span>, loss))</span><br></pre></td></tr></table></figure>
<p>该函数输入参数为网络模型model，训练轮次epoch，训练数据集train_loader和优化方式optimizer。<br>训练过程中损失函数使用负对数似然函数。</p>
<h2 id="模型测试"><a href="#模型测试" class="headerlink" title="模型测试"></a>模型测试</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Test the net</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(model, test_loader)</span>:</span></span><br><span class="line">​    model.eval()</span><br><span class="line">​    correct = <span class="number">0</span></span><br><span class="line">​    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">​        output = model(data)</span><br><span class="line">​        predict = output.data.max(<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">​        correct = correct + predict.eq(target.data).sum()</span><br><span class="line">​    print(<span class="string">'Accuracy: %2d'</span> % (<span class="number">100</span>*correct/<span class="number">10000</span>), <span class="string">'%'</span>)</span><br></pre></td></tr></table></figure>
<p>该函数传入参数为网络模型model，测试数据集test_loader，并将当前模型识别准确率打印在屏幕上。</p>
<p>到这里，整个实例已经全部定义完成，在主函数中依次调用相应的函数，即可实现手写体数字识别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">​    data_base = <span class="string">'./Datasets'</span></span><br><span class="line">​    mnist_path = os.path.join(data_base, <span class="string">'MNIST'</span>)</span><br><span class="line">​    train_loader, test_loader = load_data(mnist_path)</span><br><span class="line"></span><br><span class="line">    model = Net()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.5</span>)</span><br><span class="line">    epochs = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        train(model, epoch, train_loader, optimizer)</span><br><span class="line">        test(model, test_loader)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">​    main()</span><br></pre></td></tr></table></figure>
<p>运行实例，笔者的测试准确率可以达到98%。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>初学者刚接触机器学习，自身理解和认知有限，欢迎大家在评论区指正和评论。有任何问题也可以在评论区提出。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Pytorch</tag>
        <tag>MNIST</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 3配置anaconda编译环境</title>
    <url>/2018/10/07/Sublime-Text-3%E9%85%8D%E7%BD%AEanaconda%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>Ubuntu16.04下配置Sublime Text 3的anaconda编译环境。</p>
<a id="more"></a>
<p>默认的Sublime Text 3 编译系统中只有python编译，没有anaconda编译，但是很多情况下，我们总是希望能在sublime text 下支持anaconda编译。在已经安装好anaconda的前提下，配置方式如下所述。</p>
<ol>
<li><p>打开sublime text 3,点击上部菜单栏Tools-&gt;Build System-&gt;new Build System,如下图所示。</p>
<p><img src="/2018/10/07/Sublime-Text-3配置anaconda编译环境/sublime.png" alt="image"></p>
</li>
<li><p>点击后，会打开一个新的配置文件，在空白配置文件中拷贝以下代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"cmd"</span>: [<span class="string">"/home/benjamin/anaconda3/bin/python"</span>, <span class="string">"-u"</span>, <span class="string">"$file"</span>],</span><br><span class="line">    <span class="string">"file_regex"</span>: <span class="string">"^[ ]*File \"(...*?)\", line ([0-9]*)"</span>,</span><br><span class="line">    <span class="string">"selector"</span>: <span class="string">"source.python"</span> </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中，”/home/benjamin/anaconda3/bin/python”为anaconda所在的环境路径，需要读者自己修改为自己电脑上的环境。</p>
<ol start="3">
<li>保存配置文件，命名为anaconda。</li>
<li>至此，在sublime text3下的anaconda编译环境就配好了，可以在Tools-&gt;build System中进行选择。</li>
</ol>
]]></content>
      <categories>
        <category>Ubuntu装机</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加评论系统Valine</title>
    <url>/2018/08/11/Hexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9FValine/</url>
    <content><![CDATA[<p>一款简洁，方便，好用的评论系统。</p>
<a id="more"></a>
<h2 id="Step1：注册Leancloud"><a href="#Step1：注册Leancloud" class="headerlink" title="Step1：注册Leancloud"></a>Step1：注册Leancloud</h2><hr>
<p>我们的评论系统是放在Leancloud上的,所以首先需要注册一个Leancloud账号。</p>
<p>点击进入<a href="https://leancloud.cn/" target="_blank" rel="noopener">Leancloud官网</a>。</p>
<p>注册完成后需要先创建应用。点击创建应用，弹出如下界面：</p>
<p><img src="/2018/08/11/Hexo添加评论系统Valine/create.JPG" alt="image"></p>
<p>应用名称可以随意取，笔者此处取名为Blog_comment，创建完成后单击进入应用。进入<font color="#0099ff" size="3" face="黑体">设置—应用Key </font>，可以看到APP ID 与 APP Key。</p>
<p><img src="/2018/08/11/Hexo添加评论系统Valine/set.JPG" alt="image"></p>
<h2 id="Step2：修改主题配置文件"><a href="#Step2：修改主题配置文件" class="headerlink" title="Step2：修改主题配置文件"></a>Step2：修改主题配置文件</h2><hr>
<p>打开主题配置文件 搜索 valine，填入appid 和 appkey。在对应位置填上步骤一中的APP ID 与 APP Key。  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">your</span> <span class="string">appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">your</span> <span class="string">appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure>
<p>保存后退出。在git bash 中执行:<br>    <code>hexo server -p 2333</code><br>在浏览器中输入 <a href="http://localhost:2333" target="_blank" rel="noopener">http://localhost:2333</a> ，可以看到添加评论系统后的博客。</p>
]]></content>
      <categories>
        <category>Hexo配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>评论</tag>
        <tag>Leancloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode专题——数组</title>
    <url>/2022/05/02/Leetcode%E4%B8%93%E9%A2%98%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>Leetcode 专题训练：<strong>数组</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#1">1</a></td>
<td style="text-align:center"><font color="green">简单</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#15">15</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#16">16</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">最接近的三数之和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#18">18</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/4sum" target="_blank" rel="noopener">四数之和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#31">31</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#33">33</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#34">34</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#36">36</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">有效的数独</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#37">37</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">解数独</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#41">41</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数</a></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和<span id="1"></span></h2><p><strong>题目</strong>：</p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p><strong>解法：</strong></p>
<ul>
<li>使用一个 map 记录遍历过的数组，第一个整数为 （ target - 当前值），第二个整数为 index</li>
<li>遍历数组，对每个 nums[i] 查找 map 中是否存在 ( target - nums[i] )，若存在，则添加到结果中。</li>
<li>复杂度 O(N)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">// int: nums[i], int: index</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(target - nums[i]) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back(<span class="built_in">map</span>[target - nums[i]]);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和<span id="15"></span></h2><p><strong>题目</strong>：</p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>解法：排序 + 双指针</strong></p>
<ul>
<li>先对数组进行从小到大排序</li>
<li>第一层循环遍历第一个数：first，并在当前循环进行去重，即当前值 == 前一个值时，需要跳过</li>
<li>第二层循环使用双指针，second 指向 first + 1， third 指向数组末尾，并判断三个数之和，有三种情况：<ul>
<li>sum &gt; 0 ：三个数之和大于 0，需要将右边界左移，使得总和减小，即 third–;</li>
<li>sum &lt; 0：三个数之和小于 0，需要将左边界右移，即 second++</li>
<li>sum == 0：三个数之和等于 0，将当前结果记录到 result，并同时移动左右边界，并且在移动的时候进行去重</li>
</ul>
</li>
<li>复杂度 O(N^2^)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; nums.size() - <span class="number">2</span>; first++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> second = first + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> third = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = - nums[first];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(second &lt; third) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[second] + nums[third];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target) &#123; <span class="comment">// 三数之和大于 0 ，右边界左移</span></span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123; <span class="comment">// 三数之和小于 0 ，左边界右移</span></span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 三数之和等于 0 ，同时移动左右边界</span></span><br><span class="line">                    result.push_back(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">                    second++;</span><br><span class="line">                    third--;</span><br><span class="line">                    </span><br><span class="line">					<span class="comment">// 对 second 进行去重</span></span><br><span class="line">                    <span class="keyword">while</span>(second &lt; nums.size() - <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) second++; </span><br><span class="line">                    <span class="comment">// 对 third 进行去重</span></span><br><span class="line">                    <span class="keyword">while</span>(third &gt; first &amp;&amp; nums[third] == nums[third + <span class="number">1</span>]) third--; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和<span id="16"></span></h2><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p>
<p>返回这三个数的和。</p>
<p><strong>解法：排序 + 双指针</strong>（与三数之和类似）</p>
<ul>
<li>在遍历过程中使用 min_diff 记录与目标值的最小差距，并且当发现有更小的 min_diff 时，更新 result</li>
<li>复杂度 O(N^2^)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end()); <span class="comment">// 从大到小排序</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_diff = INT_MAX; <span class="comment">// 记录 (sum - target) 的最小值</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; nums.size(); first++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> second = first + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> third = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(second &lt; third) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[first] + nums[second] + nums[third];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(sum - target) &lt; min_diff) &#123;</span><br><span class="line">                    min_diff = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">                    result = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target) third--;</span><br><span class="line">                <span class="keyword">else</span> second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和<span id="18"></span></h2><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ol>
<li>0 &lt;= a, b, c, d &lt; n</li>
<li>a、b、c 和 d 互不相同</li>
<li>nums[a] + nums[b] + nums[c] + nums[d] == target</li>
</ol>
<p><strong>解法：排序 + 双指针</strong>（与三数之和类似）</p>
<ul>
<li>先对数组进行从小到大排序</li>
<li>第一层循环遍历第一个数：first，并在当前循环进行去重，即当前值 == 前一个值时，需要跳过</li>
<li>第二层遍历第二个数：second，并在当前层进行去重</li>
<li>第二层循环使用双指针，third 指向 first + 1， fourth 指向数组末尾，并判断四个数之和，有三种情况：<ul>
<li>sum &gt; 0 ：四个数之和大于 0，需要将右边界左移，使得总和减小，即 fourth–;</li>
<li>sum &lt; 0：四个数之和小于 0，需要将左边界右移，即 third++</li>
<li>sum == 0：四个数之和等于 0，将当前结果记录到 result，并同时移动左右边界，并且在移动的时候进行去重</li>
</ul>
</li>
<li>复杂度 O(N^3^)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">4</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; nums.size() - <span class="number">3</span>; first++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 对 a 去重</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; nums.size() - <span class="number">2</span>; second++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 对 b 去重</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> third = second + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> fourth = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> sum_ab = nums[first] + nums[second];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(third &lt; fourth) &#123;</span><br><span class="line">                    <span class="keyword">long</span> sum_cd = nums[third] + nums[fourth];</span><br><span class="line">                    <span class="keyword">if</span>(sum_ab + sum_cd &gt; target) &#123;</span><br><span class="line">                        fourth--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum_ab + sum_cd &lt; target) &#123;</span><br><span class="line">                        third++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.push_back(&#123;nums[first], nums[second], nums[third], nums[fourth]&#125;);</span><br><span class="line">                        third++;</span><br><span class="line">                        fourth--;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(third &lt; nums.size() &amp;&amp; nums[third] == nums[third - <span class="number">1</span>]) third++; <span class="comment">// 对 c 去重</span></span><br><span class="line">                        <span class="keyword">while</span>(fourth &gt; second &amp;&amp; nums[fourth] == nums[fourth + <span class="number">1</span>]) fourth--; <span class="comment">// 对 d 去重</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列<span id="31"></span></h2><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 <code>下一个排列</code> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 <code>原地</code> 修改，只允许使用额外常数空间。</p>
<p><strong>解法</strong></p>
<ul>
<li>先从后向前遍历数组，找到第一组顺序的数字，位置记为 idx 和 idx + 1 <ul>
<li>若未能找到一组顺序，则说明整个数组是逆序的，则将数组从小到大排序后进行返回</li>
</ul>
</li>
<li>在 idx 右边找到第一个大于 nums[idx] 的值，与 nums[idx] 交换位置</li>
<li>将 idx 后的元素按照从小到大进行排列</li>
<li>复杂度 O(N)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.size() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin() + i + <span class="number">1</span>, nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组<span id="33"></span></h2><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。你可以设计一个时间复杂度为 <code>O(log n)</code> 的解决方案吗？</p>
<p><strong>解法：二分查找</strong></p>
<ul>
<li>分析：数组排列方式为：左半部分若干个数升序排列，右半部分也是升序排列，且左半部分所有数均大于右半部分的值</li>
<li>初始化 left 和 right，分别指向数组起点与终点</li>
<li>查找当前 mid 对应的值<ul>
<li>若 nums[mid] == target，return mid</li>
<li>若 [nums[left], nums[mid]]  是有序数组<ul>
<li>若 target 在区间 [nums[mid], nums[right]] 之间，则在 [left, mid - 1] 中进行查找</li>
<li>否则在 [mid + 1, right] 中查找</li>
</ul>
</li>
<li>若 [nums[mid], nums[right]]  是有序数组<ul>
<li>若 target 在区间 [nums[mid + 1], nums[right]] 之间，则在 [mid +1, right] 中进行查找</li>
<li>否则在 [left, mid - 1] 中查找</li>
</ul>
</li>
</ul>
</li>
<li>复杂度：O( logN )</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[left]) &#123;<span class="comment">// mid 在左边升序区间中</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt;= nums[right]) &#123; <span class="comment">// mid 在右边升序区间中</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置<span id="34"></span></h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p>
<p><strong>解法：二分查找</strong></p>
<ul>
<li>两次二分，一次查找左边，一次查找右边;</li>
<li>不同之处在于：在查找过程中比较 nums[left] 和 nums[right] 是否和 target 相等，而不是 nums[mid]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = binary_search_left(nums, target);</span><br><span class="line">        <span class="keyword">int</span> right = binary_search_right(nums, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary_search_left</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] == target) &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[right] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary_search_right</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] == target) &#123;</span><br><span class="line">                left = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独<span id="36"></span></h2><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<p><strong>解法：遍历 + 哈希表</strong></p>
<ul>
<li>使用三个哈希表<ul>
<li>rows[9][9]：第一维表示 第 i 行，第二维表示数字 j ，对应的值表示出现的次数</li>
<li>cols[9][9]：与 rows 同理</li>
<li>sub_box[3][3][9]：第 i 行 第 j 列的小方格中数组 k 出现的次数</li>
</ul>
</li>
<li>复杂度： O(N)，只对整个数组遍历一遍</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> cols[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> sub_box[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> str = board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(str != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = str - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    rows[i][idx]++;</span><br><span class="line">                    cols[j][idx]++;</span><br><span class="line">                    sub_box[i / <span class="number">3</span>][j / <span class="number">3</span>][idx]++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(rows[i][idx] &gt; <span class="number">1</span> || cols[j][idx] &gt; <span class="number">1</span> || sub_box[i / <span class="number">3</span>][j / <span class="number">3</span>][idx] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独<span id="37"></span></h2><p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p><strong>解法：回溯</strong></p>
<ul>
<li>对每一个需要填充的位置<ul>
<li>遍历1 - 9 进行填充，填入某个值 i ，检查当前填充值是否有效<ul>
<li>若有效，则进行递归，填充下一个位置</li>
<li>否则回溯一步，将当前填充位置置空</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;        <span class="comment">// 遍历行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++) &#123; <span class="comment">// 遍历列</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">'1'</span>; k &lt;= <span class="string">'9'</span>; k++) &#123;     <span class="comment">// (i, j) 这个位置放k是否合适</span></span><br><span class="line">                    <span class="keyword">if</span> (isValid(i, j, k, board)) &#123;</span><br><span class="line">                        board[i][j] = k;                <span class="comment">// 放置k</span></span><br><span class="line">                        <span class="keyword">if</span> (backtracking(board)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果找到合适一组立刻返回</span></span><br><span class="line">                        board[i][j] = <span class="string">'.'</span>;              <span class="comment">// 回溯，撤销k</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> val, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123; <span class="comment">// 判断行里是否重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[row][i] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123; <span class="comment">// 判断列里是否重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[j][col] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> startRow = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> startCol = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startRow; i &lt; startRow + <span class="number">3</span>; i++) &#123; <span class="comment">// 判断9方格里是否重复</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = startCol; j &lt; startCol + <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == val ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数<span id="41"></span></h2><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程之TCP协议实现</title>
    <url>/2022/05/01/Socket%E7%BC%96%E7%A8%8B%E4%B9%8BTCP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Socket编程之实现一个简单的 TCP 通信。</p>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="Socket-理解"><a href="#Socket-理解" class="headerlink" title="Socket 理解"></a>Socket 理解</h2><p>Socket 即套接字，是网络编程的一个抽象概念。Socket 是一个抽象层，应用程序可以通过它发送或接收数据，可以对其<strong>像对文件一样的打开、读写和关闭</strong>等操作。Socket 允许应用程序将 I/O 插入到网络中，并与网络中的其他应用程序进行通信。通常我们用一个 socket 表示打开了一个网络连接，网络 socket 是 IP 地址与端口的组合，所以打开一个 socket 需要知道目标计算机的 IP 地址和端口号，并指定协议类型。</p>
<h2 id="什么是TCP协议？"><a href="#什么是TCP协议？" class="headerlink" title="什么是TCP协议？"></a>什么是TCP协议？</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，数据可以准确发送，数据丢失会重发。TCP是因特网中的<strong>传输层</strong>协议，使用<strong>三次握手</strong>协议建立连接。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p><strong>TCP 三次握手</strong>的过程如下：</p>
<ul>
<li><p>客户端发送 SYN （SEQ = x）报文给服务器端，进入 SYN_SEND 状态；</p>
</li>
<li><p>服务器端收到 SYN 报文，回应一个 SYN （SEQ = y）ACK（ACK = x+1）报文，进入 SYN_RECV 状态；</p>
</li>
<li>客户端收到服务器端的 SYN 报文，回应一个ACK（ACK = y+1）报文，进入 Established 状态。</li>
</ul>
<p><img src="/2022/05/01/Socket编程之TCP协议实现/TCP建立连接.png" alt="TCP建立连接"></p>
<h3 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止"></a>连接终止</h3><p>建立一个连接需要三次握手，而终止一次连接需要经过四次握手，这是由 TCP 的半关闭造成的，具体过程如下：</p>
<ul>
<li>某个应用进程首先调用 close，称该端执行“主动关闭”（active close）。该端的 TCP 于是发送一个 FIN 分节，表示数据发送完毕；</li>
<li>接收到这个 FIN 的对端执行 “被动关闭”（passive close），这个 FIN 由 TCP 确认；</li>
<li>一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的 TCP 也发送一个FIN</li>
<li>接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。</li>
</ul>
<p><img src="/2022/05/01/Socket编程之TCP协议实现/TCP结束连接.png" alt="TCP关闭连接"></p>
<h2 id="TCP-协议的实现"><a href="#TCP-协议的实现" class="headerlink" title="TCP 协议的实现"></a>TCP 协议的实现</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端主要包括以下几个步骤：</p>
<ul>
<li>创建&amp;设置套接字</li>
<li>绑定</li>
<li>监听</li>
<li>接收连接</li>
<li>接收数据</li>
<li>发送数据</li>
</ul>
<p>完整实现代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt)); <span class="comment">// 端口重用</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9000</span>);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">"0.0.0.0"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = listen(sockfd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有新连接时，该接口会阻塞</span></span><br><span class="line">    <span class="keyword">int</span> newsockfd = accept(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(newsockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"accept"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ret = recv(newsockfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"recv"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"peer shutdown\n"</span>); <span class="comment">// 对端关闭</span></span><br><span class="line">            close(newsockfd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cli say: %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"i am server"</span>; <span class="comment">// str是临时变量</span></span><br><span class="line">        <span class="built_in">strncpy</span>(buf, str, <span class="built_in">strlen</span>(str)); <span class="comment">// 不会越界</span></span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ret = send(newsockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"send"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(newsockfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建-amp-设置套接字"><a href="#创建-amp-设置套接字" class="headerlink" title="创建&amp;设置套接字"></a>创建&amp;设置套接字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// domain：该参数一般被设置为 AF_INET，表示使用的是 IPv4 地址。还有更多选项可以利用 man 查看该函数</span></span><br><span class="line"><span class="comment">// type：该参数也有很多选项，例如 SOCK_STREAM 表示面向流的传输协议，SOCK_DGRAM 表示数据报，我们这里实现的是 TCP，因此选用 SOCK_STREAM，如果实现 UDP 可选 SOCK_DGRAM</span></span><br><span class="line"><span class="comment">// protocol：协议类型，一般使用默认，设置为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span> <span class="params">(<span class="keyword">int</span> socket, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line"><span class="comment">// socket：被设置的套接字</span></span><br><span class="line"><span class="comment">// level：选项所在的协议层</span></span><br><span class="line"><span class="comment">// optname：需要访问的选项名</span></span><br><span class="line"><span class="comment">// optval：指向包含新选项值的缓冲</span></span><br><span class="line"><span class="comment">// optlen：选项值的长度</span></span><br></pre></td></tr></table></figure>
<h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：服务器打开的 sock</span></span><br><span class="line"><span class="comment">// addr：常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。</span></span><br><span class="line"><span class="comment">// addrlen：地址长度</span></span><br></pre></td></tr></table></figure>
<h4 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// sockfd 的含义与 bind 中的相同。</span></span><br><span class="line"><span class="comment">// backlog 参数解释为内核为次套接口排队的最大数量，这个大小一般为 5~10，不宜太大（是为了防止 SYN 攻击）</span></span><br></pre></td></tr></table></figure>
<h4 id="接收连接"><a href="#接收连接" class="headerlink" title="接收连接"></a>接收连接</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* addr,<span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="comment">// addrlen是一个传入传出型参数，传入的是调用者的缓冲区 cliaddr 的长度，以避免缓冲区溢出问题；传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给 cliaddr 参数传 NULL，表示不关心客户端的地址。</span></span><br></pre></td></tr></table></figure>
<p>当没有新连接时，该接口会阻塞。</p>
<h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 接收对方发送的数据</span></span><br><span class="line"><span class="comment">// sockfd: 通信文件描述符</span></span><br><span class="line"><span class="comment">// buf: 缓存，用于存放要发送的数据</span></span><br><span class="line"><span class="comment">// len: buf 的大小</span></span><br><span class="line"><span class="comment">// flags: 一般设置为 0，此时为阻塞式发送，即发送不成功会直接阻塞。</span></span><br></pre></td></tr></table></figure>
<h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 向对方发送数据</span></span><br><span class="line"><span class="comment">// sockfd: 通信文件描述符</span></span><br><span class="line"><span class="comment">// buf: 缓存，用于存放要发送的数据</span></span><br><span class="line"><span class="comment">// len: buf 的大小</span></span><br><span class="line"><span class="comment">// flags: 一般设置为 0，此时为阻塞式发送，即发送不成功会直接阻塞。</span></span><br></pre></td></tr></table></figure>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端完整实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_addr</span>;</span></span><br><span class="line">    dest_addr.sin_family = AF_INET;</span><br><span class="line">    dest_addr.sin_port = htons(<span class="number">9000</span>);</span><br><span class="line">    dest_addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = connect(sockfd, (struct sockaddr*)&amp;dest_addr, <span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"connect"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, <span class="string">"i am client"</span>);</span><br><span class="line">        ret = send(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"send"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        ret = recv(sockfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"recv"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"peer shutdown\n"</span>);</span><br><span class="line">            close(sockfd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"svr say: %s\n"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16.04配置shadowsocks-qt5客户端</title>
    <url>/2018/09/16/Ubuntu16-04%E9%85%8D%E7%BD%AEshadowsocks-qt5%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<p>Ubuntu16.04下配置shadowsocks客户端实现浏览器翻墙。</p>
<a id="more"></a>
<h3 id="安装shadowsocks-qt5"><a href="#安装shadowsocks-qt5" class="headerlink" title="安装shadowsocks-qt5"></a>安装shadowsocks-qt5</h3><p>首先安装shadowsocks的图形化界面。在终端中依次输入以下三行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure>
<p>在开始菜单中搜索shadowsocks-qt5，图标如下图所示，点击打开。</p>
<p><img src="/2018/09/16/Ubuntu16-04配置shadowsocks-qt5客户端/ss-qt5.png" alt="image"></p>
<p>打开后，点击上方菜单栏Edit，在弹出框如图所示，在弹出框中依次填写相应的服务器IP地址和密码。</p>
<p><img src="/2018/09/16/Ubuntu16-04配置shadowsocks-qt5客户端/edit.png" alt="image"></p>
<p>配置完成后，点击Connect，即可连接成功。</p>
<p>注意，虽然此时已经翻墙，但是Ubuntu此时不会实现全局代理。这是因为shadowsocks只能代理SOCKS5的流量，但Ubuntu走的是https的流量。因此，还需要浏览器搭配相应的插件才能实现翻墙。这里只讲最常用的浏览器chrome。</p>
<p>若Ubuntu中尚未安装chrome，可以到<a href="http://www.ubuntuchrome.com/" target="_blank" rel="noopener">Ubuntu Chrome</a>下载安装。</p>
<p>Chrome需要安装相应的插件，最常用的是<a href="https://www.switchyomega.com/download/" target="_blank" rel="noopener">SwitchyOmega</a>。下载到本地后，将下载下来的crx文件拖动到Chrome浏览器中即可实现安装。安装完成后会自动弹出SwitchyOmega的配置界面。</p>
<p><img src="/2018/09/16/Ubuntu16-04配置shadowsocks-qt5客户端/swi.png" alt="image"></p>
<p>点击New Profile，命名可以随便取，这里笔者命名为vultr（为VPN供应商的名称），里面内容按上图中填写即可。最后点击Apply changes退出即可。</p>
<p>在shadowsocks中点击connect连接成功后，在浏览器中右上角插件中找到SwitchyOmega，单击后弹出以下界面：</p>
<p><img src="/2018/09/16/Ubuntu16-04配置shadowsocks-qt5客户端/switch.png" alt="image"></p>
<p>此时默认的是直接连接，不会走任何代理，在需要翻墙时，切换到相应的代理（笔者这里是vultr）即可实现翻墙。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>欢迎大家在评论区指正和评论。有任何问题也可以在评论区提出。</p>
]]></content>
      <categories>
        <category>Ubuntu装机</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>Shadowsocks GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下通过pip安装PyTorch导入报错</title>
    <url>/2018/09/07/Windows%E4%B8%8B%E9%80%9A%E8%BF%87pip%E5%AE%89%E8%A3%85PyTorch%E5%AF%BC%E5%85%A5%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h2 id="报错详情"><a href="#报错详情" class="headerlink" title="报错详情"></a>报错详情</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"C:\Users\username\Code\Python\Test\venv_pytorch\lib\site-packages\torch\__init__.py"</span>, line <span class="number">78</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">   <span class="keyword">from</span> torch._C <span class="keyword">import</span> *</span><br><span class="line">ImportError: DLL load failed: 找不到指定的模块</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>该问题是由于Numpy和当前python版本不兼容造成的。在安装pytorch时，执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install torchvision </span><br></pre></td></tr></table></figure>

该安装命令会自动安装依赖包numpy。主动卸载安装的numpy

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 uninstall numpy </span><br></pre></td></tr></table></figure>
<p>点击访问<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">非官方python拓展库</a>，下拉找到numpy:</p>
<p><img src="/2018/09/07/Windows下通过pip安装PyTorch导入报错/numpy_whl.PNG" alt="image"></p>
<p>选择与自己电脑python对应版本相同的numpy包，点击下载。以笔者的安装环境为例：python版本为64位python35，则选择下载 numpy‑1.15.1+mkl‑cp35‑cp35m‑win_amd64.whl 。</p>
<p>打开下载文件的存储路径，在当前路径下，通过命令行执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install numpy‑<span class="number">1.15</span><span class="number">.1</span>+mkl‑cp35‑cp35m‑win_amd64.whl </span><br></pre></td></tr></table></figure>
<p>等待安装完成，再次导入torch，成功导入！</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>欢迎大家在评论区指正和评论。有任何问题也可以在评论区提出。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《视觉SLAM十四讲》知识点</title>
    <url>/2021/04/30/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%E3%80%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>SLAM 是 Simultaneous Localization and Mapping 的缩写，中文译作“<strong>同时定位与**</strong>地图构建**” 。它是指搭载特定传感器的主体，在没有环境先验信息的情况下，于运动过程中建立环境的模型，同时估计自己的运动。</p>
<p>完整的 SLAM 分为以下几个模块：<strong>视觉里程计</strong>、<strong>后端优化</strong>、<strong>建图</strong>和<strong>回环检测</strong>。</p>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="三维空间刚体运动"><a href="#三维空间刚体运动" class="headerlink" title="三维空间刚体运动"></a>三维空间刚体运动</h2><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p>旋转矩阵 <strong>R</strong> 可以描述相机的旋转，它是一个<strong>正交阵</strong>，且<strong>行列式为1</strong>。在欧式变换中，除了旋转之外还有平移，考虑在世界坐标系中的向量 a ，经过一次旋转和一次平移之后，得到了 a’ ，则有表达式：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/1.png"></p>
<p>上面的变换不是一个线程关系，当进行多次变换之后，表达式会变得复杂，因此引入齐次坐标和变换矩阵重写：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/2.png" style="zoom:80%;"></p>
<p>这里的矩阵 <strong>T</strong> 称为<strong>变换矩阵</strong>。</p>
<h3 id="旋转向量"><a href="#旋转向量" class="headerlink" title="旋转向量"></a>旋转向量</h3><p>任何旋转都可以用一个<strong>旋转轴</strong>和一个<strong>旋转角</strong>来描述，可以使用一个向量，其方向与旋转轴一致，而长度等于旋转角，这个向量就称为<strong>旋转向量</strong>。</p>
<p>由旋转向量到旋转矩阵转移的过程由 罗德里格斯公式 给出。</p>
<h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>欧拉角将一个旋转分解成三次绕不同轴的旋转，例如航空中的“偏航-俯仰-滚转(yaw - pitch - roll)” 来描述一个旋转，相当于分别绕着 ZYX 轴进行旋转（正前方为 X，右侧为 Y，上方为 Z）。</p>
<p>欧拉角的重大缺点是会碰到著名的<strong>万向锁</strong>问题：例如在俯仰角为 ± 90° 时，第一次旋转和第三次旋转将使用同一个轴，这导致系统丢失了一个自由度。</p>
<h3 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h3><p>四元数既是紧凑的，也没有奇异性。</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/3.png" style="zoom:50%;"></p>
<p>假设某个旋转是绕着单位向量 <strong>n</strong> 进行了角度为 <strong>θ</strong> 的旋转，那么旋转的四元数形式为：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/4.png"></p>
<h3 id="相似、仿射、射影（透视）变换"><a href="#相似、仿射、射影（透视）变换" class="headerlink" title="相似、仿射、射影（透视）变换"></a>相似、仿射、射影（透视）变换</h3><p><strong>相似变换</strong>比欧式变化多了一个自由度，允许物体进行均匀的缩放。</p>
<p><strong>仿射变换</strong>是平移、旋转、放缩、反射和剪切变换的有机组合。</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/5.png"></p>
<p>射影变换是最一般的变换，从真实世界到相机照片的变换是一个射影变换，也叫作<strong>透视变换</strong>。</p>
<p><strong>正交变换</strong>：是线性空间的一种，欧式空间的正交变换只包括旋转、反射和他们的组合。</p>
<center>常见变换性质比较</center>

<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/6.png"></p>
<hr>
<h2 id="李群与李代数"><a href="#李群与李代数" class="headerlink" title="李群与李代数"></a>李群与李代数</h2><h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><p>群（Group）是一种 <strong>“一种集合 + 一种运算”</strong> 的代数结构，将集合记作 A，运算记作 · ，则群可以记作 G= （A, · )。群要求这个运算满足以下几个条件：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/7.png"></p>
<p>举例：旋转矩阵集合 和 矩阵乘法构成群，变换矩阵 和 矩阵乘法 也构成群，索引可以称为 旋转矩阵群和变换矩阵群。</p>
<p>常见的群有：</p>
<ul>
<li>一般线性群 <strong>GL(n)</strong>：指 n x n 的可逆矩阵，对矩阵乘法成群。</li>
<li>特殊正交群 <strong>SO(n)</strong>：旋转矩阵群，其中以 <strong>SO(2)</strong> 和 <strong>SO(3)</strong> 最为常见。</li>
<li>特殊欧式群 <strong>SE(n)</strong>：n 维欧式变换。</li>
</ul>
<p><strong>李群</strong>：具有连续（光滑）性质的群。SO(n) 和 SE(n) 都是连续的，因为我们能够直观地想象一个刚体能够连续地在空间中运动，因此他们都是李群。</p>
<h3 id="李代数"><a href="#李代数" class="headerlink" title="李代数"></a>李代数</h3><p>李代数由一个集合，一个数域 F 和一个二元运算 [, ] 组成，若他们满足：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/16.png"></p>
<p>则称集合，数域和二元运算为一个李代数。</p>
<p>考虑任意旋转矩阵 <strong>R</strong>，其随着时间连续的变化，记为 <strong>R(t)</strong> 满足：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/8.png"></p>
<p>两边求导，并整理：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/9.png"></p>
<p>可以看出<img src="/2021/04/30/《视觉SLAM十四讲》知识点/10.png"> 是一个<strong>反对称矩阵</strong>。已知任意一个反对称矩阵，我们可以找到一个向量，经过符号 <strong>^</strong> 运算后，与该矩阵相同。其中：</p>
<p> <strong>^</strong> 运算为：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/11.png"></p>
<p>由于<img src="/2021/04/30/《视觉SLAM十四讲》知识点/10.png">是反对称矩阵，因此可以找到一个三维向量 <strong>φ(t)</strong> ，满足： <strong>φ(t)</strong> = <img src="/2021/04/30/《视觉SLAM十四讲》知识点/10.png">。</p>
<p>整理得：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/12.png"></p>
<p>上述表达式表明，每对旋转矩阵求一次导数，只需要左乘一个矩阵即可。进一步，设 φ 在零时刻保持常数且为 φ0，则有：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/13.png"></p>
<p>这是一个关于 R(t) 的微分方程，其解的形式为：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/15.png"></p>
<p>根据上式，给定某个时刻的 <strong>R</strong> ，我们可以求得一个 <strong>φ</strong>，它描述了 <strong>R</strong> 在局部的导数关系。</p>
<p> <strong>φ</strong> 事实上是一种李代数，SO(3) 对应的李代数是定义在 R^3^ 上的向量。</p>
]]></content>
      <categories>
        <category>3D 视觉</category>
      </categories>
      <tags>
        <tag>3D 视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/07/02/My%20First%20Blog/</url>
    <content><![CDATA[<p>Hello，这是我的第一篇博客。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>爱狗</tag>
      </tags>
  </entry>
  <entry>
    <title>体素拍摄调研</title>
    <url>/2022/05/04/%E4%BD%93%E7%B4%A0%E6%8B%8D%E6%91%84%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">公司</th>
<th style="text-align:center">设备</th>
<th style="text-align:center">价格</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>Intel Studios</strong></td>
<td style="text-align:center">120 路定制相机</td>
<td style="text-align:center">100K +</td>
</tr>
<tr>
<td style="text-align:center"><strong>8i</strong></td>
<td style="text-align:center">41 路定制相机</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>Dimension</strong></td>
<td style="text-align:center">106 路定制相机</td>
<td style="text-align:center">100K +</td>
</tr>
<tr>
<td style="text-align:center"><strong>DoubleMe</strong></td>
<td style="text-align:center">1 路定制相机</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p><a href="https://www.volumetric-video.com/volumetric-capture-companies/" target="_blank" rel="noopener">Top Volumetric Capture companies list</a></p>
<h2 id="Intel-Studios"><a href="#Intel-Studios" class="headerlink" title="Intel Studios"></a><strong>Intel Studios</strong></h2><p>Intel 在洛杉矶的体积捕捉工作室，拥有一个 4 层，10000 平方英尺的圆顶建筑。</p>
<p>于 2018 年初开放了该设施，其中心是一个巨大的圆形绿幕平台，上面装有 100 多台 8K 摄像机，所得数据能够用于创建 AR 体验所需要的的 3D 全息图或沉浸式的 VR 视频。目前已经于 2020 年 10 月关闭。</p>
<p><img src="/2022/05/04/体素拍摄调研/intel-studios-dome.png" alt="intel-studios-dome"></p>
<h2 id="8i"><a href="#8i" class="headerlink" title="8i"></a><a href="https://8i.com/" target="_blank" rel="noopener">8i</a></h2><h3 id="拍摄"><a href="#拍摄" class="headerlink" title="拍摄"></a>拍摄</h3><p>24 - 60 台同步相机，提供 2K 或 4K 分辨率。整个舞台的灯光控制。</p>
<p><img src="https://8i.com/wp-content/uploads/2021/06/CH5_5556-2048x1366.jpg" alt></p>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>重建 + 压缩 + 编辑，生成 3D 内容。</p>
<ul>
<li><p><strong>融合</strong>：使用机器学习，超快速深度求解和 CG 技术快速重建多个视频源。可通过任意数量的 GPU 进行扩展，并使用摄影测量方法确保准确重建人类、动物和道具，不需要任何人工干预</p>
</li>
<li><p><strong>压缩</strong>：超过 1000x 的压缩比，基于 mesh 的输出</p>
</li>
<li><strong>编辑</strong>：提供编辑软件，对 3D 内容进行编辑。</li>
</ul>
<p><img src="/2022/05/04/体素拍摄调研/8i.gif" alt></p>
<h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>支持 VOD，CDN 分发。还直接与 Unity、Unreal 和 8th Wall 集成。 </p>
<h2 id="Dimension"><a href="#Dimension" class="headerlink" title="Dimension"></a><a href="https://www.dimensionstudio.co/studios" target="_blank" rel="noopener">Dimension</a></h2><p>在各地都有工作室，包括华盛顿，伦敦，加州新城堡和移动工作室等。</p>
<p><img src="/2022/05/04/体素拍摄调研/dimension.png" alt></p>
<h2 id="DoubleMe"><a href="#DoubleMe" class="headerlink" title="DoubleMe"></a><a href="https://www.doubleme.me/" target="_blank" rel="noopener">DoubleMe</a></h2><p><img src="/2022/05/04/体素拍摄调研/doubleme.png" alt></p>
<p>三个产品：</p>
<ul>
<li><p><strong>HoloPort</strong>：</p>
<p>HoloPort™ 是一个简单的软件解决方案，可以记录和流式传输具有颜色和深度的人物。 使用任何 3D 相机和 PC 在世界任何地方使用 HoloPort™ - 就像在计算机上安装网络摄像头一样简单。</p>
</li>
<li><p><strong>Hologram Room</strong>：</p>
<p>全息图室，融合了真实与虚拟世界的体验中心。</p>
</li>
<li><p><strong>HoloPortal</strong>：</p>
<p>HoloPortal 位于伦敦和首尔，是一个身临其境的立体工作室，捕捉和流式传输 3D 人物和对象，为下一代媒体创建持久的数字内容。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>3D 视觉</category>
      </categories>
      <tags>
        <tag>3D 视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法》知识点</title>
    <url>/2022/04/30/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>《计算机网络-自顶向下方法》的知识点整理。</p>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h2><p>协议分层具有概念化和结构化的特点，使得更新系统组件更为容易。</p>
<p><strong>因特网的协议栈</strong>由五个层次组成：应用层、运输层、网络层、链路层和物理层。</p>
<table>
<thead>
<tr>
<th style="text-align:center">层次</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center">网络应用程序及应用层协议存留的地方。<br>典型协议有：<strong>HTTP</strong>（web 报文），<strong>SMTP</strong>（电子邮件） 和 <strong>FTP</strong>（文件传输） 等</td>
</tr>
<tr>
<td style="text-align:center">运输层</td>
<td style="text-align:center">在应用程序端点之间传送应用层报文，有两种协议：<strong>TCP</strong> 和 <strong>UDP</strong></td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">运输层向网络层递交报文及目的 IP，网络层进行 <strong>IP</strong> 传输</td>
</tr>
<tr>
<td style="text-align:center">链路层</td>
<td style="text-align:center">主要包括<strong>以太网</strong>、<strong>WiFi</strong>、和<strong>电缆</strong>接入等，对数据进行<strong>分组传输</strong></td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">与实际传输介质相关，将一个一个<strong>比特</strong>通过链路（双绞线、光纤等）进行传输</td>
</tr>
</tbody>
</table>
<p>在 20 世纪 70 年代后期，国际标准化组成（ISO）提出计算机网络围绕 7 层进行组织，称为开放系统互联（OSI）模型。</p>
<p>OSI 七层模型分为是：应用层、表示层、会话层、运输层、网络层、链路层和物理层。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>纯ipv6服务器搭建v2ray方法</title>
    <url>/2022/05/05/ipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAv2ray%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>基于 <a href="https://github.com/233boy/v2ray/tree/master" target="_blank" rel="noopener">233boy</a> 项目进行适当修改，在 ipv6 机器上进行部署。</p>
<a id="more"></a>
<h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p>纯 ipv6 机器不具有 NAT4 访问的能力，因此连基本的 github 都无法直接访问。此时可以通过 <strong>NAT64</strong> 进行转换，NAT64 是一种有状态的网络地址与协议转换技术，一般只支持通过 IPv6网络侧用户发起连接访问 IPv4侧网络资源。 </p>
<p>DNS64是与NAT64搭配使用的，原理很简单，修改你的DNS到DNS64提供者的DNS，当你发出向解析到IPv4的域名的请求后，DNS会将IPv4地址按照一定格式嵌入IPv6地址中；这个返回IPv6地址会指向NAT64的服务器，NAT64网关会按照它包含的信息获取IPv4的数据并转发给你，这样一来你就能够直接访问IPv4的网站了。</p>
<p>一键写入 DNS:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"nameserver 2001:67c:2b0::4\nnameserver 2001:67c:2b0::6"</span> &gt; /etc/resolv.conf</span><br></pre></td></tr></table></figure>
<p>然后下载代码，注意不要下载到 <code>/etc/v2ray/233boy/</code>下，因为后续会安装到这里</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/<span class="number">233</span>boy/v2ray -b <span class="keyword">master</span> <span class="title">v2ray</span> --<span class="attr">depth=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="修改-get-ip-以支持-ipv6"><a href="#修改-get-ip-以支持-ipv6" class="headerlink" title="修改 get_ip() 以支持 ipv6"></a>修改 get_ip() 以支持 ipv6</h2><p>进入下载路径 <code>v2ray</code>，需要修改两个文件：<code>install.sh</code> 和 <code>v2ray.sh</code>，找到 get_ip 函数，修改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">get_ip</span></span>() &#123;</span><br><span class="line">	ip=$(curl -s 6.ipw.cn)</span><br><span class="line">	<span class="comment"># ip=$(curl -s https://ipinfo.io/ip)</span></span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s https://api.ip.sb/ip)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s https://api.ipify.org)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s https://ip.seeip.org)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s https://ifconfig.co/ip)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s https://api.myip.com | grep -oE <span class="string">"([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;"</span>)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s icanhazip.com)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s myip.ipip.net | grep -oE <span class="string">"([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;"</span>)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"\n<span class="variable">$red</span> 这垃圾小鸡扔了吧！<span class="variable">$none</span>\n"</span> &amp;&amp; <span class="built_in">exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要改动内容为，将第一行注释，并添加一个能够返回 ipv6 地址的网址。</p>
<h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><p>使用本地安装模式进行安装：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bash </span><span class="keyword">install.sh </span>local</span><br></pre></td></tr></table></figure>
<p>根据提示进行配置即可。</p>
<h2 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙"></a>开启防火墙</h2><p>若是无法使用，说明端口可能被防火墙禁用，开启对应端口的防火墙即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo ufw status <span class="comment">// 查看防火墙状态</span></span><br><span class="line">sudo ufw allow <span class="number">2333</span> <span class="comment">// 允许 2333 端口通过</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>基于BASYS2的音乐盒的制作与调试</title>
    <url>/2018/07/03/%E5%9F%BA%E4%BA%8EBASYS2%E7%9A%84%E9%9F%B3%E4%B9%90%E7%9B%92%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>摘要：基于BASYS2开发板，外接蜂鸣器，设计、调试并制作一个简易音乐盒。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>关键词：BASYS2，Verilog，音乐发生器</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><ul>
<li>在基本掌握verilog语法和掌握BASYS2开发板的流程的基础上，通过自行设计、调试并制作一个简易音乐盒，进一步巩固自己所学的知识，掌握稍复杂电路的设计方法和制作流程，深化工程开发的体验，提高自身提出问题、分析问题和解决问题的能力。</li>
</ul>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul>
<li>基础部分:制作一个简易音乐盒，将BASYS2开发板外接蜂鸣器，可以通过蜂鸣器播放出音乐。</li>
<li>拓展部分：在实现音乐播放的基础上，增加音乐暂停功能和切歌功能。</li>
</ul>
<h2 id="实验原理与设计"><a href="#实验原理与设计" class="headerlink" title="实验原理与设计"></a>实验原理与设计</h2><h3 id="音乐播放原理"><a href="#音乐播放原理" class="headerlink" title="音乐播放原理"></a>音乐播放原理</h3><ul>
<li>音乐由音调和音长组成，其中。频率的高低决定了音调的高低，音符的持续时间和数目决定了音长。所以，只要将音调和音长控制好就能演奏出动听的乐曲。音乐播放的原理图如图所示。</li>
</ul>
<p><img src="/2018/07/03/基于BASYS2的音乐盒的制作/basys2_beep.png" alt="image"></p>
<h3 id="音调控制"><a href="#音调控制" class="headerlink" title="音调控制"></a>音调控制</h3><ul>
<li>限于BASYS2开发板中只提供50Hz的时钟信号，所有不同频率的信号都是从只能从基准频率分频得来。因此需要选择合适的基准频率以及每个音符对应的分频比。由于分频比只能是整数，若基准频率过低，则分频比太小，四舍五入取整后的误差较大。若基准频率过高，虽然误差变小，但分频数将变大。实际的设计应综合考虑两方面的因素，在尽量减小频率误差的前提下选取合适的基准频率与每个音符的分频比。</li>
<li>通过查阅资料，发现基准频率一般选取6MHz。对应每个音符的频率和相应的分频比如下表所示。分频比是从6MHz基准频率通过二分频得到的3MHz基础上计算得到的。对于乐曲中的休止符，分频系数为0。</li>
</ul>
<table>
<thead>
<tr>
<th>音调</th>
<th>低音</th>
<th>分频比</th>
<th>中音</th>
<th>分频比</th>
<th>高音</th>
<th>分频比</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>262</td>
<td>11450</td>
<td>523</td>
<td>5736</td>
<td>1046</td>
<td>2868</td>
</tr>
<tr>
<td>2</td>
<td>294</td>
<td>10204</td>
<td>587</td>
<td>5110</td>
<td>1175</td>
<td>2553</td>
</tr>
<tr>
<td>3</td>
<td>330</td>
<td>9090</td>
<td>659</td>
<td>4552</td>
<td>1318</td>
<td>2276</td>
</tr>
<tr>
<td>4</td>
<td>349</td>
<td>8595</td>
<td>698</td>
<td>4297</td>
<td>1397</td>
<td>2174</td>
</tr>
<tr>
<td>5</td>
<td>392</td>
<td>7653</td>
<td>784</td>
<td>3826</td>
<td>1568</td>
<td>1913</td>
</tr>
<tr>
<td>6</td>
<td>440</td>
<td>6818</td>
<td>880</td>
<td>3409</td>
<td>1760</td>
<td>1704</td>
</tr>
<tr>
<td>7</td>
<td>494</td>
<td>6072</td>
<td>988</td>
<td>3036</td>
<td>1967</td>
<td>1525</td>
</tr>
</tbody>
</table>
<h3 id="音长的控制"><a href="#音长的控制" class="headerlink" title="音长的控制"></a>音长的控制</h3><ul>
<li>由于每首歌的曲速和节拍的时间有一定的差异，所以每个音符的持续时间会有差异。假定节奏较慢的音乐最短的音符为四分音符，全音符的持续时间为1s，则需要提供一个4Hz的时钟信号。若最短的音符为8分音符，则同理需要提供一个8Hz的时钟信号。当然，如果曲速不同导致全音符的时间不是1s时，需要调整相应的参数使的音乐不会有较大的失真。由于本实验中不要求对音乐的精准控制，所以该参数根据实际的播放效果调节即可。</li>
</ul>
<h3 id="音乐暂停键的实现"><a href="#音乐暂停键的实现" class="headerlink" title="音乐暂停键的实现"></a>音乐暂停键的实现</h3><ul>
<li>音乐暂停键的实现较为简单，可以由一个条件语句实现。将输出端与指定的暂停键关联，当暂停键为真时，将输出端从音乐时钟信号脱离，反之则将音乐时钟信号输出。该功能实现代码可以由问号-冒号运算符简单实现</li>
</ul>
<h3 id="音乐切换的实现"><a href="#音乐切换的实现" class="headerlink" title="音乐切换的实现"></a>音乐切换的实现</h3><ul>
<li>本实验中内置了两首曲目，并且是两首曲速不同的曲目。其中一首最短的音符为四分音符，另一首的最短的音符为八分音符。鉴于两手歌的曲速有较大的差异，因此需要两个乐谱时钟频率。可以通过程序定义乐谱时钟频率的选择与开发板上的一个button对应。当button被按下时，会产生一个时钟上升沿，检测到该上升沿后接通不同的时钟频率，并且更改播放曲目的编号，由此便实现了音乐切换的功能。</li>
</ul>
<h2 id="调试问题分析与解决"><a href="#调试问题分析与解决" class="headerlink" title="调试问题分析与解决"></a>调试问题分析与解决</h2><h3 id="曲速控制"><a href="#曲速控制" class="headerlink" title="曲速控制"></a>曲速控制</h3><ul>
<li>曲速控制是一个比较麻烦的事情，需要不断调整分频比使的音乐基本不失真，并且，由于开发板上提供的时钟频率并不是严格的50MHz，所以对乐谱时钟频率的分频只能通过不断地尝试和3烧录后的结果来逐渐调整。尤其是两首歌的曲速不同需要不同的乐谱时钟频率，在确定该分频比的尝试中花费了不少时间。</li>
<li>当然，乐谱时钟频率也可以只使用一个，但是这样会导致曲速慢的曲目的音符大量重复，造成大量的冗余代码，所以两相权衡之下，还是选择了不同的乐谱时钟频率.</li>
</ul>
<h3 id="曲目切换"><a href="#曲目切换" class="headerlink" title="曲目切换"></a>曲目切换</h3><ul>
<li>按照实际的应用场景来看，曲目切换通常会提供两个button，分别对应上一首和下一首，由于本实验中只提供了两首内置歌曲，所以只提供了一个切换键。</li>
<li>当然，在实现本功能的过程中，也遇到了一个问题。即开始的时候通过检测button的状态为0或是为1来判定是否切换歌曲。但是后来发现每次button按下的时候，有时候歌曲切换但有时候又不切换，经过一定的debug之后，猛然反应过来每次button被按下时，在button状态为1时，可能里面有很多个时钟，所以切歌状态瞬间发生了很多次，最终导致歌曲切换发生问题。</li>
<li>解决办法也比较简单，即不检测button的0/1状态，而是检测button的上升沿，这样便解决了该问题。</li>
</ul>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><ul>
<li>通过本次实验，自己对verilog语言的特点和编程逻辑有了更深刻的认识。对BASYS2开发板的使用愈加娴熟。并且通过自行设计、调试并制作一个简易音乐盒，进一步巩固了自己所学的知识，掌握稍复杂电路的设计方法和制作流程，提高自身提出问题、分析问题和解决问题的能力。</li>
</ul>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>基于LSTM的2048游戏AI</title>
    <url>/2019/01/30/%E5%9F%BA%E4%BA%8ELSTM%E7%9A%842048%E6%B8%B8%E6%88%8FAI/</url>
    <content><![CDATA[<p>基于LSTM的2048游戏AI。</p>
<a id="more"></a>
<p>本项目在<a href="https://github.com/duducheng/2048-api" target="_blank" rel="noopener">duducheng</a>的基础上，通过循环卷积神经网络（RNN）的变体——训练了一个模型，实现了一个2048游戏AI。实测该模型平均可以达到1300分以上。</p>
<p>点击链接查看<a href="https://github.com/KayChou/2048-api" target="_blank" rel="noopener">项目源码</a></p>
<p>本文主要从以下几个方面说明该项目的方法和原理：</p>
<blockquote>
<ol>
<li>运行环境</li>
<li>数据集获取及定义</li>
<li>网络模型搭建</li>
<li>模型训练</li>
<li>结果测试</li>
</ol>
</blockquote>
<h3 id="运行环境说明"><a href="#运行环境说明" class="headerlink" title="运行环境说明"></a>运行环境说明</h3><p>本项目运行环境为python3 + torch。此外，数据集处理及存储需要使用pandas库。</p>
<h3 id="数据集获取及定义"><a href="#数据集获取及定义" class="headerlink" title="数据集获取及定义"></a>数据集获取及定义</h3><p>数据集主要从duducheng实现的基于决策实现的算法获取。这里我们称之其为“强Agent”。调用强Agent运行2048游戏，将当前棋盘的状态当做数据，强Agent的预测结果作为label。并且对棋盘数据进行取对数的预处理。存储格式如下图所示。其中每一行有17个数.前16个代表当前棋盘，最后一个为当前棋盘的预测结果。</p>
<p><img src="/2019/01/30/基于LSTM的2048游戏AI/2048_dataset.png" alt="image"></p>
<p>数据集定义方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span><span class="params">(torch.utils.data.Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root, transform=None, target_transform=None)</span>:</span></span><br><span class="line">        dataframe = pd.read_csv(root)</span><br><span class="line">        data_array = dataframe.values</span><br><span class="line"></span><br><span class="line">        self.data = data_array[:, <span class="number">0</span>:<span class="number">16</span>]</span><br><span class="line">        self.label = data_array[:, <span class="number">16</span>]</span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.target_transform = target_transform</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        board = self.data[index].reshape((<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">        board = board[:, :, np.newaxis]</span><br><span class="line">        board = board/<span class="number">11.0</span></span><br><span class="line">        <span class="comment"># board = torch.from_numpy(board)</span></span><br><span class="line"></span><br><span class="line">        label = self.label[index]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            board = self.transform(board)</span><br><span class="line">        <span class="keyword">return</span> board, label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.label)</span><br></pre></td></tr></table></figure>
<p>导入数据集方式如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">	train_data = MyDataset(</span><br><span class="line">		root = <span class="string">'./Datasets/Train.csv'</span>,</span><br><span class="line">		transform=transforms.Compose(</span><br><span class="line">			[transforms.ToTensor()]))</span><br><span class="line">    train = torch.utils.data.DataLoader(</span><br><span class="line">        train_data,</span><br><span class="line">        batch_size=batch_size,</span><br><span class="line">        shuffle=<span class="literal">True</span>,</span><br><span class="line">        num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    test_data = MyDataset(</span><br><span class="line">        root = <span class="string">'./Datasets/Test.csv'</span>,</span><br><span class="line">        transform=transforms.Compose(</span><br><span class="line">            [transforms.ToTensor()]))</span><br><span class="line"></span><br><span class="line">    test = torch.utils.data.DataLoader(</span><br><span class="line">        test_data,</span><br><span class="line">        batch_size=batch_size,</span><br><span class="line">        shuffle=<span class="literal">True</span>,</span><br><span class="line">        num_workers=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> train, test</span><br></pre></td></tr></table></figure>
<h3 id="网络模型搭建"><a href="#网络模型搭建" class="headerlink" title="网络模型搭建"></a>网络模型搭建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		super(Net, self).__init__()</span><br><span class="line">    self.RNN = nn.LSTM(</span><br><span class="line">		input_size = <span class="number">4</span>,</span><br><span class="line">		hidden_size = <span class="number">300</span>,</span><br><span class="line">		num_layers = <span class="number">4</span>,</span><br><span class="line">		batch_first=<span class="literal">True</span>)</span><br><span class="line">	self.fc1 = nn.Linear(<span class="number">300</span>, <span class="number">64</span>)</span><br><span class="line">	self.fc2 = nn.Linear(<span class="number">64</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">	x, (h_n, h_c) = self.RNN(x, <span class="literal">None</span>)</span><br><span class="line">	x = x[:, <span class="number">-1</span> ,:]</span><br><span class="line">	x = self.fc1(x)</span><br><span class="line">	x = self.fc2(x)</span><br><span class="line">	<span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Train the net</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(model, epoch, train_loader, optimizer)</span>:</span></span><br><span class="line">	model.train()</span><br><span class="line">    <span class="keyword">for</span> idx, (data, target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line"></span><br><span class="line">        data = data.type(torch.float)</span><br><span class="line">        data = Variable(data.view(<span class="number">-1</span>,<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">            data = Variable(data).cuda()</span><br><span class="line">            target = Variable(target).cuda()</span><br><span class="line">            model.cuda()</span><br><span class="line"></span><br><span class="line">        output = model(data)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># target = target.repeat(12)</span></span><br><span class="line">        loss = F.nll_loss(output, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idx % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            predict = output.data.max(<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">            num = predict.eq(target.data).sum()</span><br><span class="line">            correct = <span class="number">100.0</span>*num/batch_size</span><br><span class="line">            t = time.time()-start_time</span><br><span class="line">            print(<span class="string">'Train epoch: %d   Loss: %.3f    '</span> % (epoch+<span class="number">1</span>, loss), \</span><br><span class="line">				<span class="string">'Accuracy: %0.2f'</span> % correct, <span class="string">'%'</span>, <span class="string">'\tTotal Time: %0.2f'</span> % t)</span><br></pre></td></tr></table></figure>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="/2019/01/30/基于LSTM的2048游戏AI/2048.gif" alt="image"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Pytorch</tag>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法及其实践</title>
    <url>/2022/04/30/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>十种排序算法总结：算法描述 + 动图展示 + 代码实现</p>
<a id="more"></a>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_81618d545abaaed106904f33d1d8670e.png" alt></p>
<h2 id="算法描述与动图描述"><a href="#算法描述与动图描述" class="headerlink" title="算法描述与动图描述"></a>算法描述与动图描述</h2><table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:left">算法描述</th>
<th style="text-align:center">动图描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>冒泡排序</strong></td>
<td style="text-align:left">1. 比较相邻的元素，若前者大于后者，则交换位置。每次将未排序部分的最大值放在最后一个<br>2. 两层循环，第一层是排序数组个数，第二层逐次递减</td>
<td style="text-align:center"><img src="https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>选择排序</strong></td>
<td style="text-align:left">1. 在未排列的数组中找到最小的元素，然后放在开始的位置<br>2. 两层循环，第一层是当前的位置，第二层是在后面找到最小值</td>
<td style="text-align:center"><img src="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>插入排序</strong></td>
<td style="text-align:left">1. 初始时将第一个元素放在第一位<br>2. 对于后续的每个元素，依次与前面比较，放在合适的位置</td>
<td style="text-align:center"><img src="https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>堆排序</strong></td>
<td style="text-align:left">构建大顶堆，将堆顶元素取出，然后将剩余元素调整为大顶堆，然后重复，直到取出所有元素</td>
<td style="text-align:center"><img src="https://pic3.zhimg.com/v2-c66a7e83189427b6a5a5c378f73c17ca_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>归并排序</strong></td>
<td style="text-align:left">1. 将序列划分为两个子序列，对每个子序列进行归并排序，两个排序后的子序列存放在 temp 数组中<br>2. 将两个排序后的子序列合并到原数组</td>
<td style="text-align:center"><img src="https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>快速排序</strong></td>
<td style="text-align:left">1. 选择一个数作为基准（pivot），所有小于基准的放在前面，所有大于基准的放在后面<br>2. 递归的进行分区处理</td>
<td style="text-align:center"><img src="https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>希尔排序</strong></td>
<td style="text-align:left">1. 以一定的步长进行插入排序<br>2. 最后一个步长一定为1</td>
<td style="text-align:center"><img src="https://pic3.zhimg.com/v2-f14e4169ff39bad42c3dd6c385ad9c72_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>计数排序</strong></td>
<td style="text-align:left">1. 找到数组中的最大值和最小值<br>2. 统计数组中每个元素出现的次数，存储在一个计数数组中（或者存储在 map 中）</td>
<td style="text-align:center"><img src="https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>桶排序</strong></td>
<td style="text-align:left">将数组分到有限数量的桶中，然后对每个桶再分别排序。计数排序可以看做是桶数量为 1 的桶排序</td>
<td style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-465190477b7fb90d17aef27c2a213368_720w.jpg" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>基数排序</strong></td>
<td style="text-align:left">将整数按位数切割成不同的数字，然后按每个位数分别比较</td>
<td style="text-align:center"><img src="https://pic3.zhimg.com/v2-3a6f1e5059386523ed941f0d6c3a136e_b.webp" alt></td>
</tr>
</tbody>
</table>
<h2 id="源代码实现"><a href="#源代码实现" class="headerlink" title="源代码实现"></a>源代码实现</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">choose_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_idx = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[min_idx]) &#123;</span><br><span class="line">                min_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(min_idx != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[min_idx];</span><br><span class="line">            nums[min_idx] = nums[i];</span><br><span class="line">            nums[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">insert_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = i;</span><br><span class="line">        <span class="keyword">int</span> curr_num = nums[i];</span><br><span class="line">        <span class="keyword">while</span>(pos &gt; <span class="number">0</span> &amp;&amp; curr_num &lt; nums[pos - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[pos] = nums[pos - <span class="number">1</span>];</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[pos] = curr_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 简历父节点指针和子节点指针</span></span><br><span class="line">    <span class="keyword">int</span> dad = start;</span><br><span class="line">    <span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= <span class="built_in">end</span>) &#123; <span class="comment">// 若子节点指针在范围内才做比较</span></span><br><span class="line">        <span class="comment">// 先比较两个子节点大小，选择最大的</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= <span class="built_in">end</span> &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>])</span><br><span class="line">            son++;</span><br><span class="line">        <span class="comment">// 如果父节点大于子节点代表调整完成，跳出</span></span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">// 父亲节点大于子节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否则交换父子内容，然后继续子节点和孙节点比较</span></span><br><span class="line">            swap(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化，i 从最后一个父节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        max_heapify(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先将第一个元素和已经排好的元素前一位交换</span></span><br><span class="line">    <span class="comment">// 再重新调整（刚调整的元素之前的元素），直到排序完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    internel_merge_sort(nums, temp, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">internel_merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        internel_merge_sort(nums, temp, left, middle);</span><br><span class="line">        internel_merge_sort(nums, temp, middle + <span class="number">1</span>, right);</span><br><span class="line">        merge_sorted_array(nums, temp, left, middle, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sorted_array</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp, <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left;      </span><br><span class="line">    <span class="keyword">int</span> j = middle + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        temp[k++] = (nums[i] &lt;= nums[j]) ? nums[i++] : nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle)&#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( j&lt;= right)&#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把数据复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        nums[left + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    qsort(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middle = partition(nums, left, right);</span><br><span class="line">    qsort(nums, left, middle - <span class="number">1</span>);</span><br><span class="line">    qsort(nums, middle + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= pivot) right--;</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= pivot) left++;</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">step</span> &lt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) &#123;<span class="comment">//generate delta</span></span><br><span class="line">        <span class="built_in">step</span> = <span class="built_in">step</span> * <span class="number">3</span> + <span class="number">1</span>;    <span class="comment">// &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">step</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">step</span>; i &lt; nums.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">position</span> = i;</span><br><span class="line">            <span class="keyword">int</span> curr_num = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">position</span> &gt; <span class="number">0</span> &amp;&amp; nums[<span class="built_in">position</span> - <span class="built_in">step</span>] &gt; curr_num) &#123;</span><br><span class="line">                nums[<span class="built_in">position</span>] = nums[<span class="built_in">position</span> - <span class="built_in">step</span>];</span><br><span class="line">                <span class="built_in">position</span> -= <span class="built_in">step</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[<span class="built_in">position</span>] = curr_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">step</span> /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
