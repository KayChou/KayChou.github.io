<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>H.265/HEVC学习笔记</title>
    <url>/2019/10/15/H-265-HEVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>《新一代高效视频编码H.265HEVC》学习笔记</p>
<a id="more"></a>
<h3 id="1-视频编码标准"><a href="#1-视频编码标准" class="headerlink" title="1.视频编码标准"></a>1.视频编码标准</h3><h4 id="1-1-制定视频编码标准的两大组织："><a href="#1-1-制定视频编码标准的两大组织：" class="headerlink" title="1.1 制定视频编码标准的两大组织："></a>1.1 制定视频编码标准的两大组织：</h4><p>  ITU-T：（International Telecommunication Union-Telecommunication Standardization Sector）国际电信联盟电信标准化部门</p>
<p>  ISO/IEC：（International Organization for Standardization）国际标准化组织与（International Electrotechnical Commission）国际电工委员会</p>
<h4 id="1-2-H-26X系列标准"><a href="#1-2-H-26X系列标准" class="headerlink" title="1.2 H.26X系列标准"></a>1.2 H.26X系列标准</h4><h5 id="1-2-1-H-261标准："><a href="#1-2-1-H-261标准：" class="headerlink" title="1.2.1 H.261标准："></a>1.2.1 H.261标准：</h5><p>  于1990年由ITU-T制定，设计目的是为了在带宽为64kbits/s的倍数的综合业务数字网（Integrated Services Digital Network，ISDN）上传输质量可接受的视频信号，所以被称为p×64 bits/s编码器。<br>  采用的编码方法包括基于运动补偿的帧间预测，DCT，量化，zig-zag扫描和熵编码等。</p>
<h5 id="1-2-2-H-263标准"><a href="#1-2-2-H-263标准" class="headerlink" title="1.2.2 H.263标准"></a>1.2.2 H.263标准</h5><p>  由ITU-T制定，仍以混合编码框架为核心，原始组织和码流组织与H.261十分相似。同时，H.263也吸收了一些MPEG等一些其他国际标准的技术，如半像素精度的运动估计，PB帧预测，无限制运动矢量和8×8的帧间预测。</p>
<p>  H.263后来发展出两个增强版本：H.263+和H.263++。</p>
<h5 id="1-2-3-H-264标准"><a href="#1-2-3-H-264标准" class="headerlink" title="1.2.3 H.264标准"></a>1.2.3 H.264标准</h5><p> 由ITU-T的VCEG和ISO/IEC的MPEG组成的联合视频组（JVT）共同开发。也称H.264/AVC。</p>
<p> H.264/AVC仍然沿用了混合编码的概念，在此基础上支持了许多先进编码的技术，并获得了远超以往标准的编码性能。在相同重建质量的条件下，H.264/AVC比H.263+减少了50%的码率。</p>
<h4 id="1-3-MPEG系列标准"><a href="#1-3-MPEG系列标准" class="headerlink" title="1.3 MPEG系列标准"></a>1.3 MPEG系列标准</h4><h5 id="1-3-1-MPEG-1标准"><a href="#1-3-1-MPEG-1标准" class="headerlink" title="1.3.1 MPEG-1标准"></a>1.3.1 MPEG-1标准</h5><p>是由MPEG指定的第一个视频和音频有损压缩的标准，原本主要目标是针对数字存储媒体（CD光盘），后来成为VCD的核心技术。</p>
<h5 id="1-3-2-MPEG-2标准"><a href="#1-3-2-MPEG-2标准" class="headerlink" title="1.3.2 MPEG-2标准"></a>1.3.2 MPEG-2标准</h5><p>于1994年面世，应用范围包括卫星电视，有线电视等，经过少量修改后成为DVD的主要技术。MPEG-2视频编码标准由MPEG与ITU-T联合制定，与H.262完全相同。</p>
<h5 id="1-3-3-MPEG-4标准"><a href="#1-3-3-MPEG-4标准" class="headerlink" title="1.3.3 MPEG-4标准"></a>1.3.3 MPEG-4标准</h5><p>于1998年被ISO/IEC批准，相比于MPEG-1和MPEG-2，MPEG-4涵盖的内容非常丰富。包括多达31个部分。MPEG-4分别定义了系统，音视频编码，多媒体传输集成框架等，其中第10部分就是H.264/AVC。</p>
<h4 id="1-4-H-265-HEVC简介"><a href="#1-4-H-265-HEVC简介" class="headerlink" title="1.4 H.265/HEVC简介"></a>1.4 H.265/HEVC简介</h4><p>2010年4月VCEG和MPEG再次组建视频编码联合组（JCT-VC），联手制定H.265/HEVC（High Efficiency Video Coding）。<br>从根本上说，H.265/HEVC视频编码标准的编码框架并没有革命性的改变，仍采用混合编码框架，包括变换，量化，熵编码，帧内预测，帧间预测以及环路滤波等模块，但在几乎每个模块都引入了新的编码技术。<br>（1）帧内预测：去除空间冗余。<br>（2） 帧间预测：去除时间冗余。<br>（3）变换量化：通过对残差数据进行变换量化以去除频域相关性，对数据进行有损压缩。将图形变换至频域，将能量集中在低频区域。<br>（4）去方块滤波：基于块的视频编码形成的重构图像会出现方块效应，采用方块滤波可以削弱甚至消除方块效应。<br>（5）样点自适应补偿：解析去方块滤波后的像素的统计特性，为像素添加相应的偏移值，在一定程度上削弱振铃效应。<br>（6）熵编码：将编码控制数据，量化变化系数，帧内预测数据以及运动数据编码为二进制流进行存储或传输。熵编码模块的输出即为原始视频压缩后的码流。<br>相对于以往的视频编码标准，H.264/HEVC的编码性能有了很大的提升，这源于新编码工具的使用和自身独居特色的核心技术。例如基于四叉树的灵活块分割结构，不同角度的帧内预测模式，自适应的运动矢量预测，合并技术Merge，可变尺寸的DCT，模式依赖的DST和性能更好的CABAC，以及新的样点自适应补偿滤波器等。<br>（7）编码单元：H.264/AVC标准中的核心编码单元是宏块，包含一个16×16的亮度块采样，对于一般的视频信源，会伴随两个8×8的色度块采样。而H.265/HEVC采用了编码树单元和编码树块，大小可以由编码器设定，并且可以超越16×16。<br>（8）改进的帧内预测技术：H.264/AVC对4×4的编码块采用9种预测模式，对16×16的编码块采用4种预测模式。H.265/HEVC提供了35种帧内预测模式。<br>（9）先进的帧间预测技术：H.265/HEVC中引入了新的帧间预测技术，包括运动信息融合技术，先进的运动矢量预测技术以及基于Merge的Skip模式。<br>（10）RQT（Residual Quad-tree Transform）技术是基于四叉树结构的自适应变换技术。<br>（11）ACS（Adaptive Cofficient Scanning）技术包括三类：对角扫描，水平扫描和垂直扫描。<br>（12）SAO像素自适应补偿技术。位于去块效率滤波器之后，用于补偿重构像素值，达到减少振铃效应失真的目的。<br>（13） IBDI（Internal Bit Depth Increase）技术，在编码器的输入端将未压缩图像的像素深度由P比特增加到Q比特，在解码器输出端再恢复到P比特。</p>
<h3 id="2-颜色空间"><a href="#2-颜色空间" class="headerlink" title="2 颜色空间"></a>2 颜色空间</h3><h4 id="2-1-RGB"><a href="#2-1-RGB" class="headerlink" title="2.1 RGB"></a>2.1 RGB</h4><h4 id="2-2-YUV"><a href="#2-2-YUV" class="headerlink" title="2.2 YUV"></a>2.2 YUV</h4><p>主要用于优化彩色视频信号的传输，并使其向后兼容老式黑白电视。其中Y表示明亮度，U和V表示色度。色度U反映的是RGB信号蓝色部分与亮度值之间的差异，V反映的是RGB信号红色部分与信号亮度值之间的差异。</p>
<h4 id="2-3-YCbCr：与YUV类似，Y表示明亮度。"><a href="#2-3-YCbCr：与YUV类似，Y表示明亮度。" class="headerlink" title="2.3 YCbCr：与YUV类似，Y表示明亮度。"></a>2.3 YCbCr：与YUV类似，Y表示明亮度。</h4><p>（1）4:4:4：每4个亮度样本都对应4个Cb和4个Cr色度样本。<br>（2） 4:2:2：每2个亮度样本都对应1个Cb和1个Cr色度样本。<br>（3） 4:1:1：水平方向上每4个亮度样本都对应1个Cb和1个Cr色度样本。垂直方向分辨率相同。<br>（4）4:2:0：水平和垂直方向上每4个亮度样本都对应1个Cb和1个Cr色度样本。</p>
<h3 id="3-H-265-HEVC编码视频格式"><a href="#3-H-265-HEVC编码视频格式" class="headerlink" title="3 H.265/HEVC编码视频格式"></a>3 H.265/HEVC编码视频格式</h3><p>不同格式的源视频通过前处理模块转换成统一的数据格式，经过编解码器后再转换成源视频格式。</p>
<h4 id="3-1-编码图像格式"><a href="#3-1-编码图像格式" class="headerlink" title="3.1 编码图像格式"></a>3.1 编码图像格式</h4><p>主要包括矩阵数量及空间关系，图像空间分辨率，像素两化深度等。承载编码图像格式的语法元素属于SPS（序列参数集），SPS表征一组图像CVS（编码视频序列）的共有参数。</p>
<h4 id="3-2-解码图像格式"><a href="#3-2-解码图像格式" class="headerlink" title="3.2 解码图像格式"></a>3.2 解码图像格式</h4><p>除包含图像携带的格式信息，还包括扫描类型、图像类型、色彩空间等信息。</p>
<h3 id="4-编码结构"><a href="#4-编码结构" class="headerlink" title="4 编码结构"></a>4 编码结构</h3><p>视频序列由若干时间连续的图像构成，在压缩之前，先将视频序列分割为若干个小的图像组（GOP）。GOP又分为封闭式GOP和开放式GOP。封闭式GOP以IDR（Instantaneous Decoding Refresh）图像开始，各个GOP之间独立编解码。开放式GOP，第一个GOP中的第一个帧内编码图像为IDR图像，后面GOP中的帧内编码图像可以越过non-IDR图像使用前一个GOP的已编码图像做参考图像。<br>每个GOP又分为很多片（slice），片与片之间进行独立编解码，每个片由一个或多个片段（Slice Segment，SS）组成。此外，H.265/HEVC又引入了树形结构单元（CTU）。每个CTU包括一个亮度树形编码块（CTB）和两个色差树形编码块。<br>一个SS在编码时，先被分割成大小相同的CTU，每一个CTU按照四叉树分割方式被划分为不同类型的编码单元（Coding Unit，CU）。<br>在码流结构方面，H.265/HEVC将属于GOP，Slice层中共用的大部分语法元素游离出来，组成序列参数集（SPS）和图像参数集（PPS）。SPS大致包括解码相关信息，如档次级别，分辨率，时域可分级信息等。PPS包含了一幅图像所用的公共参数，即一幅图像中的所有SS引用同一个PPS。大致内容包括初始图像控制信息，如初始量化参数（QP）、分块信息等。此外，为了兼容标准在其他应用上的拓展，H.265/HEVC的语法架构增加了视频参数集（VPS）。其内容大致包括多个子层共享的语法元素。<br>对于一个SS，通过引用它的PPS，该PPS又引用其对应的SPS，该SPS再引用它所对应的VPS，最终得到SS的公用信息。</p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/1.png" alt="image"></p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/2.png" alt="image"></p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/3.png" alt="image"></p>
<h4 id="4-1-视频参数集（VPS）"><a href="#4-1-视频参数集（VPS）" class="headerlink" title="4.1 视频参数集（VPS）"></a>4.1 视频参数集（VPS）</h4><p>主要用于传输视频分级信息，一个给定的视频序列，无论其每一层的SPS是否相同，都参考相同的VPS。VPS包含的信息主要有：多个子层和操作点共享的语法元素；会话所需要的有关操作点的关键信息，如档次、级别；其他不属于SPS的操作点特性信息。</p>
<h4 id="4-2-序列参数集（SPS）"><a href="#4-2-序列参数集（SPS）" class="headerlink" title="4.2 序列参数集（SPS）"></a>4.2 序列参数集（SPS）</h4><p>对于一段视频码流，其可能包含一个或者多个编码视频序列CVS。SPS的作用就是包含一个CVS中所有编码图像的共享编码参数，SPS通过被PPS引用而作用于编码图像。一个CVS中所有使用的PPS都引用同一个SPS。内容主要包括：1）图像格式信息，如采样格式，图像分辨率，量化深度，裁剪参数等；2）编码参数信息，包括编码块、变换块的最大最小尺寸等；3）与参考图像相关的信息，包括短期参考图像的设置，长期参考图像的使用和数目；4）档次，层和级相关参数；5）时域分集信息，包括时域子层的最大数目，控制传输POC仅为参数；6）可视化可用信息；7）其他信息如当前SPS引用的VPS编好，SPS标识号和SPS扩展信息。</p>
<h4 id="4-3-图像参数集（PPS）"><a href="#4-3-图像参数集（PPS）" class="headerlink" title="4.3 图像参数集（PPS）"></a>4.3 图像参数集（PPS）</h4><p>在编码视频流中，一个CVS包含多幅图像，每幅图像可能包括一个或多个SS，每个SS提供了其所引用的PPS标识号，依次得到相应PPS中的共用信息。对于同一幅图像，其内所有SS都用一个PPS。PPS的主要内容有：1）编码工具的可用性标志，编码工具主要包括符号位隐藏，帧内预测受限，去方块滤波等；2）量化过程相关句法元素；3）Tile相关句法元素；4）去方块滤波相关句法元素；5）片头控制信息；6）其他编码一幅图像可以共用的信息。</p>
<h4 id="4-4-片段层（SS）"><a href="#4-4-片段层（SS）" class="headerlink" title="4.4 片段层（SS）"></a>4.4 片段层（SS）</h4><p>一幅图像可以被分割为一个或多个片（Slice），每个片的压缩数据都是独立的。Slice不能跨过边界来进行帧内或帧间预测，但允许环路滤波器跨过边界进行滤波。使用Slice的目的是为了当数据丢失后能在此保证解码同步。根据编码类型不同，Slice可以分为：<br>（1）I Slice：该Slice的所有CU的编码过程都使用帧内预测。<br>（2）P Slice：P帧中的CU可以使用帧间预测，每个预测块（PB）使用至多一个运动补偿预测信息。<br>（3）B Slice：B帧的CU也可以使用帧间预测，但是每个PB可以使用至多两个运动补偿预测信息。<br>一个独立的Slice可以进一步划分为若干SS，包括一个独立SS和若干个依赖SS，并且以独立SS作为该Slice的开始。独立SS是指它所涉及的句法元素可以由自身确定，依赖SS是指它所涉及的某些句法元素由已解码的独立SS推导得到。一个SS包含整数个CTU，并且这些CTU分布在同一个NAL单元中。<br>H.265/HEVC编码的最高层为SS层，SS层所需要的图像层信息可以通过引用相应的PPS来获得。SS头包含其引用的PPS标识号，同一幅图像中的所有SS引用同一个PPS。</p>
<h4 id="4-5-Tile单元"><a href="#4-5-Tile单元" class="headerlink" title="4.5 Tile单元"></a>4.5 Tile单元</h4><p>H.265/HEVC相对于H.264/AVC的改进之处还在于Tile的提出。一幅图像不仅可以划分为若干个Slice，也可以划分为若干个Tile。即从水平和数值方向将一幅图像分割为若干个矩形区域，每个矩形区域都是一个Tile。每个Tile包含整数个CTU，可以独立解码。Tile提供比CTB更大程度上的并行。<br>通常情况下，每个Tile中包含的CTU的数据是近似相等的。在一幅图像中，可以同时存在某些Slice包含多个Tile和某些Tile中包含多个Slice的情况。</p>
<h4 id="4-6-Slice与Tile"><a href="#4-6-Slice与Tile" class="headerlink" title="4.6 Slice与Tile"></a>4.6 Slice与Tile</h4><p>Slice与Tile划分的目的都是为了进行独立解码，但二者划分方式有所不同。Tile形状基本上为矩形，Slice则为条带状。Slice由一系列的SS组成，一个SS由一系列的CTU组成。Tile则直接由一系列的CTU组成。每个Slice/SS和Tile至少要满足一下两个条件之一：1）一个Slice/SS中的所有CTU属于同一个Tile；2）一个Tile中的所有CTU属于同一个Slice/SS。</p>
<h4 id="4-7-树形编码块（CTU）"><a href="#4-7-树形编码块（CTU）" class="headerlink" title="4.7 树形编码块（CTU）"></a>4.7 树形编码块（CTU）</h4><p>传统的视频编码都是基于宏块实现的。H.265/HEVC标准中引入了树形编码单元CTU，其尺寸由编码器指定，可以大于宏块尺寸。为了灵活高效地表示视频场景中的不同纹理细节、运动变化的视频内容或者视频对象，H.265/HEVC为图像划分定义了一套全新的语法单元，包括编码单元（CU）、预测单元（PU）和变换单元（TU）。</p>
<h5 id="编码单元CU"><a href="#编码单元CU" class="headerlink" title="编码单元CU"></a>编码单元CU</h5><p>在H.264/AVC中，编码块CB的大小是固定的，而在H.265/HEVC中，一个CTB可以直接作为一个CB，也可以进一步以四叉树的形式划分为多个小的CB。亮度CB最大为64×64，最小为8×8。一个亮度CB和相应的色度CB及它们相关的句法元素共同组成一个编码单元CU。</p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/4.png" alt="image"></p>
<h5 id="预测单元PU"><a href="#预测单元PU" class="headerlink" title="预测单元PU"></a>预测单元PU</h5><p>一切与预测有关的信息都定义在预测单元部分，比如帧内预测的方向、帧间预测的分割方式、运动矢量预测以及帧间预测参考图像索引号等都属于PU的范畴。对于一个2N×2N的CU模式，帧内预测单元PU的可选模式有两种，帧间预测单元PU的可选模式有8种：4种对称模式和4种非对称模式。如下图所示。此外还有skip模式，skip模式是帧间预测的一种，当需要编码的运动信息只有运动参数集索引，编码残差信息不需要编码时，为2N×2N skip模式。</p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/5.png" alt="image"></p>
<h5 id="变换单元TU"><a href="#变换单元TU" class="headerlink" title="变换单元TU"></a>变换单元TU</h5><p>是独立完成变换和量化的基本单元。H.265/HEVC突破了原有的变换尺寸限制，可支持大小为4×4~32×32的编码变换。TU的大小依赖于CU，在一个CU内，以四叉树的形式递归划分TU。</p>
<h4 id="4-8-档次、层和级别"><a href="#4-8-档次、层和级别" class="headerlink" title="4.8 档次、层和级别"></a>4.8 档次、层和级别</h4><p>H.264中已经有对档次（profile）和级别（level）的划分，而H.265/HEVC在此基础上又定义了新的概念：层（Tier）。档次主要规定编码器可以采用哪些编码工具或算法，级别则根据解码器负载和存储空间情况对关键参数加以限制。考虑到应用可以根据最大码率和CPB（解码缓冲区）大小来区分，因此有些Level定义了两个Tier：主层（Main Tier）和高层（High Tier）。主层用于大多数应用，高层用于最苛刻的应用。<br>档次：H.265/HEVC中提出了三种档次：Main, Main 10和Main Still Picture。限制条件如下：1）只支持4:2:0色度采样信号；2）使用了Tiles便不能使用WPP，每一个Tile的亮度分辨率至少要256×64；3）Main和Main Still Picture档次支持8位像素深度，Main 10档次则支持10位像素深度，Main Still Picture档次不支持帧间预测。<br>层和级别：H.265/HEVC定义了两个层和13个级，两个层分别为Main Tier和High Tier。4和4以上的8个Level支持High Tier。</p>
<h3 id="5预测编码"><a href="#5预测编码" class="headerlink" title="5预测编码"></a>5预测编码</h3><p>对于视频信号来说，一幅图像的邻近像素之间有着较强的空间相关性，相邻图像之间有很强的时间相关性。采用帧内预测和帧间预测的方式，有效去除视频空域和时域的相关性，编码器对预测后的残差而不是原始像素值进行变换、量化、熵编码由此大幅提高编码效率。</p>
<h4 id="5-1-预测编码原理"><a href="#5-1-预测编码原理" class="headerlink" title="5.1 预测编码原理"></a>5.1 预测编码原理</h4><p>预测编码是指利用已编码的一个或几个样本值，根据某种模型或方法，对当前的样本值进行预测，并对样本真实值和预测值之间的差值进行编码。联合编码和条件编码时两种有记忆信源的有效编码方式。联合编码通常将图像分割成固定的块，将每一个块作为一个信源符号来考察，对每一个块内的像素进行联合编码。联合编码充分利用一个块内像素间的相关性，但未能利用相邻块之间的相关性。条件编码中当前像素的编码依赖于邻近已邻近编码像素，各像素将以滑动窗口的形式进行条件编码，这种方式改善了联合编码的缺陷，图像内邻近像素之间的相关性得到了充分利用。<br>预测编码技术通过预测模型消除橡塑件的相关性，得到的差值信号可以认为没有相关性或相关性很小，因此可以作为无记忆信源进行编码。预测编码的基本过程如下图所示。</p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/6.png" alt="image"></p>
<p>视频预测编码技术主要分为两大类：帧内预测和帧间预测。</p>
<h5 id="5-1-1-帧内预测编码"><a href="#5-1-1-帧内预测编码" class="headerlink" title="5.1.1 帧内预测编码"></a>5.1.1 帧内预测编码</h5><p>Harrison首先在图像编码中研究了帧内预测方法，方法师用先前已编码的像素进行加权平均作为当前像素的预测值。这一基本思想最终被应用于JPEG-LS标准的LOCO-I算法中。后来随着DCT在图像、视频编码中的广泛应用，帧内预测转为在频域进行，如JPEG，H.261，MPEG-I，MPEG-2和H.263等。<br>H.264/AVC标准规定了若干种预测模式，每一种模式都对应一种纹理方向，当前块预测像素由其预测方向上相邻块的边界重建像素生成。为了选择最合适的帧内预测模式，H.264/AVC使用拉格朗日率失真优化（RDO）进行模式选择。H.264/AVC标准以及后来的FRExt扩展层一共规定了3种大小的亮度帧内预测模块：4×4、8×8和16×16。其中4×4、8×8块包含9种预测模式，16×16块包含4种预测模式。色度分量的帧内帧内预测都是基于8×8大小的块进行的，也有4种预测模式。<br>（1）亮度分量的帧内16×16模式<br>帧内16×16模式包含4种预测模式：垂直模式、水平模式、DC模式和Plane模式，如下图所示。垂直模式：当前块预测像素由上方相邻块重建像素产生；水平模式：当前块预测像素由左侧相邻块重建像素产生；DC模式：当前块预测像素都为其所有参考像素的平均值；Plane模式。</p>
<p><img src="/2019/10/15/H-265-HEVC学习笔记/7.png" alt="image"></p>
<p>（2）亮度分量帧内4×4模式<br>帧内4×4和8×8块都包含9种预测模式，且两者方法类似。以帧内4×4的9种预测模式为例，包含了8种不同的预测方向以及DC模式：1）垂直模式；2）水平模式；3）DC模式；4）左下对角线模式；5）右下对角线模式；6）垂直向右模式；7）水平向下模式；8）垂直向左模式；9）水平向上模式。<br>（3）8×8色度帧内预测模式<br>色度帧内预测包含4中模式：DC模式、水平模式、垂直模式和Plane模式。<br>最新的H.265/HEVC标准对其进行了进一步发展。一方面，H.265/HEVC使用了更多大小的预测块，以适应高清视频的内容特征；另一方面，H.265/HEVC规定了更多种预测模式，对应于更多种不同的预测方向，以适应更加丰富的纹理。</p>
<h5 id="5-1-2-帧间预测编码"><a href="#5-1-2-帧间预测编码" class="headerlink" title="5.1.2 帧间预测编码"></a>5.1.2 帧间预测编码</h5><p>由于视频序列通常包括较强的时域相关性，因此预测残差通常是“平坦的”，即很多残差值接近于0。将残差信号作为后续模块的输入进行变换、量化、扫描及熵编码，可实现对视频信号的高效压缩。<br>目前主要的视频编码标准帧间预测都采用了基于块的运动补偿技术。主要原理是为当前图像的每个像素块在之前已编码图像中寻找一个最佳匹配块，该过程称为运动估计。其中用于预测的图像称为参考图像，参考块到当前像素块的唯一称为运动向量，当前像素块与参考快的差值称为预测残差。<br>早期的H.261定义了两种类型的图像——I图像和P图像。其中I只能使用帧内编码，而P则可以利用帧间预测编码。此外，为了去除相邻块运动向量之间的相关性，H.261对MV进行了差分编码。在H.261中，P图像的预测方式必须是由前一幅图像预测当前图像，这称为“前向预测”，但实际场景旺旺会产生不可不预测的运动和遮挡，因此当前图像的某些像素块可能无法从之前的图像中找到匹配块。为此，MPEG-1标准中定义了第三类图像——B图像，并规定B可以使用三种预测方式：前向预测、后向预测以及双向预测。这样，B中的一个宏块可以对应两个MV：一个由前向预测得来，另一个由后向预测得来。此外，MPEG-1首次使用了半像素精度的运动估计，其半像素位置的参考像素值可由双线性差值方法产生。<br>面向数字广播电视的标准MPEG-2首次支持了隔行扫描视频，一帧图像包含两个场——顶场和底场。为了适应这种情况，每个帧图像的宏块需要被拆分为两个16×8的块分别进行预测。<br>H.263标准沿用了MPEG-1的双向预测与半像素精度运动估计，并进一步发展了MPEG-2中将一个宏块分成更小的块进行预测的思想。此外，H.263改进了MV的预测机制——用当前块左方、上方及右上方的3个MV的中值来预测当前块的MV。<br>H.264/AVC标准在集成以往标准帧间预测成熟技术和框架的同时，对其进行了进一步细化和改善。为了提高运动补偿的精度，H.264/AVC规定了7种大小的运动补偿块，并且一个宏块内部允许存在不同大小块的组合。编码器可以根据视频内容自适应的选择块大小。此外还使用了1/4像素精度运动估计（色度为1/8像素精度）、多参考图像预测、加权预测以及空域/时域MV预测等。</p>
<h5 id="5-1-3-帧间预测编码关键技术"><a href="#5-1-3-帧间预测编码关键技术" class="headerlink" title="5.1.3 帧间预测编码关键技术"></a>5.1.3 帧间预测编码关键技术</h5><p>（1） 运动估计<br>运动估计准则：1）最小均方误差MSE准则；2）绝对误差和SAD准则；3）最大匹配像素数MPC准则。<br>搜索算法：常用的搜索算法有：全搜索算法，二维对数走索，三步搜索算法等。<br>亚像素精度估计：亚像素精度运动估计意味着需要对参考图像进行插值，好的插值方法能够大幅改善运动补偿的性能。<br>（2） MV预测<br>在大多数图像和视频中，一个运动物体可能会覆盖多个运动补偿块，因此空间域相邻块的运动向量具有较强的相关性。若使用相邻已编码块对当前块MV进行预测，将二者差值进行进行编码，则会大幅节省编码MV所需的比特数。H.264/AVC使用了空域和时域两种MV的预测模式。<br>（3） 多参考图像加权预测<br>对于某些场景，如物理周期性变化，多参考图像可以大幅提高预测精度。早起视频编码标准只支持单个参考图像，H.263+开始支持多参考图像预测技术，而H.264/AVC标准最多支持15个参考图像。为了权衡编码效率与编码时间，一般情况下都采用4~6个参考图像。<br>此外，H.264/AVC还使用了加权预测技术，加权预测表示预测像素可以用一个或两个参考图像中的像素与加权系数相乘得出。</p>
<h4 id="5-2-H-265-HEVC帧内预测"><a href="#5-2-H-265-HEVC帧内预测" class="headerlink" title="5.2 H.265/HEVC帧内预测"></a>5.2 H.265/HEVC帧内预测</h4><h5 id="5-2-1-亮度帧内预测模式"><a href="#5-2-1-亮度帧内预测模式" class="headerlink" title="5.2.1 亮度帧内预测模式"></a>5.2.1 亮度帧内预测模式</h5><p>H.265/HEVC亮度分量帧内预测支持5中大小的PU：4×4，8×8，16×16，32×32和64×64，其中每一种大小的PU都对应35种预测模式，包括Planar模式，DC模式以及33种角度模式。所有的预测模式都是用相同的模板。</p>
<p>（1）Planar模式：由H.264/AVC中的Plane模式发展而来，它适用于像素值缓慢变化的区域，Planar模式使用水平和垂直方向的两个线性滤波器，并将二者的平均值作为当前块像素的预测值。<br>（2）DC模式：适用于大面积平坦区域，其做法与H.264/AVC基本相同。当前块预测值可由其左侧和上方参考像素的平均值得到。</p>
<p>（3）角度模式：相比于H.264/AVC使用了8种不同的预测方向想，H.265/HEVC则进一步细化了这些预测方向，规定了33中角度预测模式。上图给出了这33种预测角度模式。</p>
<h5 id="5-2-2-亮度模式编码"><a href="#5-2-2-亮度模式编码" class="headerlink" title="5.2.2 亮度模式编码"></a>5.2.2 亮度模式编码</h5><p>H.265/HEVC建立了一个帧内预测模式候选列表candModeList，表中有三个候选预测模式，用于存储相邻PU的预测模式。</p>
<h5 id="5-2-3-色度模式编码"><a href="#5-2-3-色度模式编码" class="headerlink" title="5.2.3 色度模式编码"></a>5.2.3 色度模式编码</h5><p>H.265/HEVC色度分量帧内预测一共有5种模式：Planar模式，垂直模式，水平模式，DC模式以及对应亮度分量的预测模式。</p>
<h5 id="5-2-4-帧内预测过程"><a href="#5-2-4-帧内预测过程" class="headerlink" title="5.2.4 帧内预测过程"></a>5.2.4 帧内预测过程</h5><p>在H.265/HEVC中，35种预测模式是在PU的基础上定义的，而具体帧内预测过程的实现则是以TU为单位的。标准规定PU可以以四叉树的形式划分TU，且一个PU内的所有TU共享同一种预测模式。H.265/HEVC帧内预测可以分为3个步骤：1）判断当前TU相邻参考像素是否可用并做相应处理；2）对参考像素进行滤波；3）根据滤波后的参考像素计算当前TU的预测像素值。<br>（1）相邻参考像素的获取<br>对于一个N×N的TU，参考像素区域可分为5个部分：左下，左侧，左上，上方和右上，一共4N+1个像素点。若该TU位于图像边界，或Slice、Tile的边界（H.265/HEVC规定帧内编码中相邻Slice和Tile不能相互参考），则相邻参考像素可能不存在或不可用。另外在某些情况下左下和右上区域尚未编码时，这些参考像素也是不可用的。<br>当参考像素不存在或者不可用时，H.265/HEVC标准会使用最相邻的像素进行填充。若所有区域参考像素都不可用，则参考像素都用固定值填充。<br>（2）参考像素的滤波<br>H.264/AVC在帧内预测时对某些模式下的参考像素进行了滤波，以更好地利用临近像素之间的相关性，提高预测精度。H.265/HEVC沿用了这一做法。<br>一方面，H.265/HEVC针对大小不同的TU选择了不同数量的模式进行滤波。DC模式以及4×4大小的TU都不需要进行参考像素滤波，32×32的TU除水平模式，垂直模式之外的所有角度模式以及Planar模式，其他都需要参考像素滤波，16×16TU进一步除去最接近水平和垂直方向的四个模式。8×8TU仅对3个45°倾斜方向的模式以及Planar模式进行参考像素滤波。<br>另一方面，H.265/HEVC增加使用了一种强滤波方法。<br>（3）预测像素的计算</p>
<h4 id="5-3-H-265-HEVC帧间预测"><a href="#5-3-H-265-HEVC帧间预测" class="headerlink" title="5.3 H.265/HEVC帧间预测"></a>5.3 H.265/HEVC帧间预测</h4><h5 id="5-3-1-运动估计"><a href="#5-3-1-运动估计" class="headerlink" title="5.3.1 运动估计"></a>5.3.1 运动估计</h5><p>在基于块运动补偿的视频编码框架中，运动搜索是最为重要的环节之一，同时也是编码端最耗时的模块。H.265/HEVC官方测试编码器HM10.0给出了两种搜索算法：全搜索和TZSearch算法。TZSearch是H.265/HEVC新出现的技术，步骤为：1）确定其实搜索点：H.265/HEVC采用AMVP，AMVP给出若干个候选测试MV，编码器从中选择率失真代价最小的的作为预测MV。将其指向的位置作为起始搜索点。2）以步长1开始，按照菱形模板或正方形模板在搜索范围内进行搜索，其中步长以2的幂次递增，选出率失真代价最小的点作为该步骤的搜索结果。3）若上一步得到的最优点步长为1，则需要在该店周围做两点搜索，主要目的是补充搜索最优点周围尚未搜索的点。4）若最优点步长大于一定的阈值，则以该最优点为中心，在一定范围内做全搜索。5）以最优点为新的启示搜索点，重复2~4，细化搜索。TZSearch与全搜索算法相比性能上略有降低，但搜索时间仅为全搜索的一半。<br>在实际场景中，由于物体运动距离不一定是像素的整数倍，因此需要将运动估计的精度提升到亚像素级别。H.265/HEVC沿用了上一代标准H.264/AVC所使用的1/4像素精度运动估计，并进一步发展了其亚像素差值算法，如亮度分量差值算法，色度分量插值算法等。</p>
<h5 id="5-3-2-MV预测技术"><a href="#5-3-2-MV预测技术" class="headerlink" title="5.3.2 MV预测技术"></a>5.3.2 MV预测技术</h5><p>空域上相邻块的MV具有较强的相关性，同时MV在时域上也有一定的相关性。若利用空域或时域上相邻块的MV对当前MV进行预测，仅对残差进行编码，则能够大幅节省MV的编码比特数。H.265/HEVC在MV的预测方面提出了两种技术——Merge技术和AMVP技术。<br>（1）Merge技术：Merge模式会为当前PU建立一个MV候选列表，列表中存在5个候选MV，通过遍历这5个候选MV，并进行率失真代价的计算，最终选取率失真代价最小的一个作为该Merge模式的最优MV。Merge模式建立的MV候选列表中包含了空域和时域两种情形。<br>（2）AMVP技术：高级运动向量预测利用空域时域上运动向量的相关性为当前PU建立了候选MV列表，编码器从中选出最优的预测MV，并对MV进行差分编码，解码器通过建立相同的列表，仅需要运动向量残差（MVD）与预测MV在该列表中的序号即可计算当前PU的MV。</p>
<h5 id="5-3-3-加权预测"><a href="#5-3-3-加权预测" class="headerlink" title="5.3.3 加权预测"></a>5.3.3 加权预测</h5><p>加权预测可以 用于修正P帧或B帧中的运动补偿预测像素，H.265/HEVC标准规定了两种加权预测方法——默认加权预测以及Explicit加权预测。</p>
<h4 id="5-4-PCM模式"><a href="#5-4-PCM模式" class="headerlink" title="5.4 PCM模式"></a>5.4 PCM模式</h4><p>H.265/HEVC中有一种特殊的编码模式——PCM模式。在该模式下，编码器直接传输一个CU的像素值，而不经过预测、变换等其他操作。对一些特殊的情况，如图像内容极不规则或量化参数QP非常小时，该模式与传统的“帧内—变换—量化—熵编码”相比编码效率可能更高，此外，PCM模式还适用于无损编码情形。</p>
<h3 id="6-变换编码"><a href="#6-变换编码" class="headerlink" title="6 变换编码"></a>6 变换编码</h3><h4 id="6-1-离散余弦变换"><a href="#6-1-离散余弦变换" class="headerlink" title="6.1 离散余弦变换"></a>6.1 离散余弦变换</h4><p>傅里叶变换表明，任何信号都能表示为多个不同振幅和频率的正弦波或余弦波信号的叠加。对二维DCT基图像来说，其中左上角小图像表示水平和垂直空间频率均为零时的基图像，其余分别对应于不同水平和垂直空间频率的基图像。对于灰度值变化缓慢的像素块来说，经过DCT后绝大部分能量都集中在在左上角的低频系数中。实际上，大多数图像包含更多的低频分量，并且可以利用人眼对图像高频细节相对不敏感的特性，对高能量的低频系数进行较为精细的量化和处理，而对低能量的高频系数进行粗略的量化或掩盖，这样可以较好地压缩图像而不会造成明显的主观质量下降。<br>随着变换尺寸的增大，DCT去相关性能越来越好，但提升幅度逐渐变缓。考虑到DCT的计算复杂度会随着变换尺寸的增大而大幅提高，因此许多较早的图像与食品编码标准都采用8×8 DCT作为其变换编码方案。</p>
<h5 id="6-1-1-整数DCT"><a href="#6-1-1-整数DCT" class="headerlink" title="6.1.1 整数DCT"></a>6.1.1 整数DCT</h5><p>DCT中余弦函数的存在使得DCT过程必须使用浮点数，这样不可避免地会带来舍入误差以及编解码正反变换失配的问题。针对该问题，从H.264/AVC开始采用整数DCT。<br>H.265/HEVC沿用了H.264/AVC所采用的的整数DCT技术，但其变换矩阵与H.264/AVC相比有所不同。H.265/HEVC使用了4种不同尺寸的整数DCT。</p>
]]></content>
      <categories>
        <category>视频编码</category>
      </categories>
      <tags>
        <tag>H.265/HEVC</tag>
        <tag>视频编码</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode专题--字符串</title>
    <url>/2022/05/02/Leetcode%E4%B8%93%E9%A2%98--%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>Leetcode 专题训练：<strong>字符串</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#30">30</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">串联所有单词的子串</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#32">32</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/longest-valid-parentheses/" target="_blank" rel="noopener">最长有效括号</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#65">65</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/valid-number/" target="_blank" rel="noopener">有效数字</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#76">76</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#115">115</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/distinct-subsequences/" target="_blank" rel="noopener">不同的子序列</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#126">126</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/word-ladder-ii/" target="_blank" rel="noopener">单词接龙 II</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#127">127</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/word-ladder/" target="_blank" rel="noopener">单词接龙</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#212">212</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/word-search-ii/" target="_blank" rel="noopener">单词搜索 II</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#224">224</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/basic-calculator/" target="_blank" rel="noopener">基本计算器</a></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a>串联所有单词的子串<span id="30"></span></h2><p>给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。</p>
<p><strong>解法一：暴力解法</strong></p>
<ul>
<li>遍历字符串 s 的每一个位置，对于每一个可能的起始位置，取长度为 words 所有单词构成的总长度的子串</li>
<li>判断子串是否由 words 中的子串串联而成</li>
</ul>
<p><strong>解法二：滑动窗口</strong></p>
<ul>
<li>建立 word 到 int 的映射 unordered_map：map_word，记录 words 中的所有单词以及次数</li>
<li>使用 matched_num 记录已经匹配的单词个数</li>
<li>记一个单词的长度为 word_len，从 0 - word_len - 1 的起始位置 i 遍历<ul>
<li>初始化窗口左右边界均为 i </li>
<li>在 i 右边截取一个单词的长度，判断单词是否出现在 map_word 中，若没有出现，则重新设定滑动窗口到当前位置</li>
<li>若出现在 word 中，则 right 向右移动一个单词</li>
<li>若出现的次数大于 map_word 的次数，则左边界向右移动</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span> || words.size() == <span class="number">0</span>) <span class="keyword">return</span> result; <span class="comment">// 处理特殊情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> one_word = words[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; map_word;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word : words) map_word[word]++; <span class="comment">// 建立 word 的映射</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; one_word; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i, right = i; <span class="comment">// 滑动窗口左右边界</span></span><br><span class="line">            <span class="keyword">int</span> matched_num = <span class="number">0</span>; <span class="comment">// 记录匹配的单词个数</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">// 滑动窗口内的单词统计</span></span><br><span class="line">            <span class="keyword">while</span>(right + one_word &lt;= s.size()) &#123;</span><br><span class="line">                <span class="built_in">string</span> next = s.substr(right, one_word);</span><br><span class="line">                right += one_word; <span class="comment">// 更新右边界</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(map_word.find(next) == map_word.end()) &#123; <span class="comment">// 没有找到匹配的单词</span></span><br><span class="line">                    left = right;</span><br><span class="line">                    matched_num = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">map</span>.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 找到了匹配的单词</span></span><br><span class="line">                    <span class="built_in">map</span>[next]++;</span><br><span class="line">                    matched_num++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="built_in">map</span>[next] &gt; map_word[next]) &#123; <span class="comment">// 更新左边界</span></span><br><span class="line">                        <span class="built_in">string</span> str = s.substr(left, one_word);</span><br><span class="line">                        <span class="built_in">map</span>[str]--;</span><br><span class="line">                        left += one_word;</span><br><span class="line">                        matched_num--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(matched_num == words.size()) result.push_back(left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号<span id="32"></span></h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p><strong>解法一：栈</strong></p>
<ul>
<li><p>使用一个栈存储最后一个没有匹配的右括号 ‘)’ 出现的位置</p>
</li>
<li><p>遇到左括号 ‘(‘ 将当前索引入栈</p>
</li>
<li>遇到右括号 ‘’)” ，将栈顶元素出栈，表示当前右括号已经被匹配<ul>
<li>栈为空，则将当前元素入栈，表示当前元素是后面未匹配的右括号</li>
<li>栈不为空，则更新最大长度</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk; <span class="comment">// stk 表示没有被匹配的 '(' 的下标</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        stk.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) stk.push(i); <span class="comment">// 左括号入栈</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(stk.empty()) stk.push(i);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = max(result, i - stk.top());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：动态规划</strong></p>
<ul>
<li>用 dp[i] 表示以 i 结尾的最长有效括号的长度</li>
<li>遍历 i，若 s[i] == ‘)’ 则 更新 dp[i]<ul>
<li>若 s[i - 1] == ‘(‘ ，即前一个是左括号，则 dp[i] 等于 dp[i - 2] + 2</li>
<li>若 s[i - 1] == ‘)’ 即前一个是右括号，则前一个可能是左括号的位置是在 (i - 1) - dp[i - 1]<ul>
<li>若是左括号，则 dp[i] 等于 dp[i - 1] + dp[i - 1 - dp[i - 1] - 1] + 2</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span>] == <span class="string">'('</span>) dp[i] = ((i &gt;= <span class="number">2</span>) ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i - dp[i - <span class="number">1</span>]&gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = max(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="有效数字"><a href="#有效数字" class="headerlink" title="有效数字"></a>有效数字<span id="65"></span></h2><p>有效数字（按顺序）可以分成以下几个部分：</p>
<ul>
<li>一个 小数 或者 整数</li>
<li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</li>
</ul>
<p>小数（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>下述格式之一：<ul>
<li>至少一位数字，后面跟着一个点 ‘.’</li>
<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>
<li>一个点 ‘.’ ，后面跟着至少一位数字</li>
</ul>
</li>
</ul>
<p>整数（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>至少一位数字</li>
</ul>
<p>部分有效数字列举如下：[“2”, “0089”, “-0.1”, “+3.14”, “4.”, “-.9”, “2e10”, “-90E3”, “3e+7”, “+6e-1”, “53.5e93”, “-123.456e789”]</p>
<p>部分无效数字列举如下：[“abc”, “1a”, “1e”, “e3”, “99e2.5”, “–6”, “-+3”, “95a54e53”]</p>
<p>给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。</p>
<p><strong>解法：条件判断</strong></p>
<ul>
<li>首先将字符串划分为若干部分：小数，整数，e/E<ul>
<li>首先判断是否有 e/E，若有，则划分为两部分，然后判断两部分是否符合要求</li>
<li>若没有 e/E 直接判断整个字符串即可</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找 e/E 在的位置，判断 e 的位置，若有两个 E，则 reurn false</span></span><br><span class="line">        <span class="keyword">int</span> idx_e = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'E'</span> || s[i] == <span class="string">'e'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(idx_e == <span class="number">-1</span>) idx_e = i;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx_e == <span class="number">-1</span>) &#123; <span class="comment">// 没有出现 e/E，则只需要判断是否是小数，或者是整数</span></span><br><span class="line">            <span class="keyword">return</span> (is_float(s) || is_integrater(s));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> left = s.substr(<span class="number">0</span>, idx_e);</span><br><span class="line">        <span class="built_in">string</span> right = s.substr(idx_e + <span class="number">1</span>, s.size() - idx_e - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> left_valid = (is_integrater(left) || is_float(left)); <span class="comment">// e/E 左边是一个整数或者一个小数</span></span><br><span class="line">        <span class="keyword">bool</span> right_valid = is_integrater(right); <span class="comment">// e/E 右边是一个整数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left_valid &amp;&amp; right_valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_integrater</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> has_sign = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> has_int = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) has_sign = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) has_int = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> has_int;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_float</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> has_sign = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> has_int = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> has_dot = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) has_sign = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 出现两个符号, false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(has_dot == <span class="literal">false</span>) has_dot = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 出现两个'.', false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) has_int = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (has_dot &amp;&amp; has_int);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串<span id="65"></span></h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p>即在 s 中找到一个子字符串，使得子字符串中包括了 t 中的所有字符。</p>
<p><strong>解法：滑动窗口</strong></p>
<ul>
<li>首先使用 unordered_map 记录 t 中的所有字符及数量</li>
<li>初始化窗口 left = right = 0，初始化窗口内的字符的 unordered_map&lt;char, int&gt; map，以及已经匹配的字符数量 matched_num = 0 </li>
<li>从左到右遍历 s，对于当前字符，将其添加到 map 中，窗口右移</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">need</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : t) &#123;</span><br><span class="line">            need[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        count = t.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, start = <span class="number">0</span>, size = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[right];</span><br><span class="line">            <span class="keyword">if</span>(need[c] &gt; <span class="number">0</span>)</span><br><span class="line">                count--;</span><br><span class="line">            need[c]--;  <span class="comment">// 先把右边的字符加入窗口</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) &#123; <span class="comment">// 窗口中已经包含所需的全部字符</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; need[s[left]] &lt; <span class="number">0</span>) &#123; <span class="comment">// 缩减窗口</span></span><br><span class="line">                    need[s[left++]]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt; size) &#123; <span class="comment">// 更新答案</span></span><br><span class="line">                    size = right - left + <span class="number">1</span>;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                need[s[left]]++;   <span class="comment">//左边界右移之前需要释放need[s[l]]</span></span><br><span class="line">                left++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size == INT_MAX ? <span class="string">""</span> : s.substr(start, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列<span id="115"></span></h2><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p><strong>解法一：动态规划</strong></p>
<ul>
<li>定义 dp[ i ][ j ] 为 s 的 0 - i 字符 和 T 的前 0 - j 字符组成的最多个数</li>
<li>动态转移方程：<ul>
<li>若遍历到 i, j 时有 s[i] == t[j]，即最后一个字符相同，则有两种情况：<ul>
<li>t 的最后一个字符匹配 s 的最后一个字符，这种情况下是 dp[i-1][j-1] 种</li>
<li>t 的最后一个字符不一定匹配 s 的最后一个字符，这种情况下，s 删除最后一个字符，然后再与 t 进行匹配，有 dp[i - 1][j] 种</li>
<li>转移方程为 dp[i][j] = dp[i-1][j-1] + dp[i - 1][j] </li>
</ul>
</li>
<li>s[i] != t[j] 时，意味着当前两个位置最后一个字符不匹配, 则只能用 s 的前一个字符去匹配 t 的最后一个字符，则 dp[i][j] = dp[i-1][j] </li>
</ul>
</li>
<li>这种方法会超出 int 的范围，题解说了限制，但是中间数据会有超出 int 的范围，因此需要对中间过程 mod INT_MAX</li>
</ul>
<p>一个示例的动态方程为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">tgt \ src</th>
<th style="text-align:center">r</th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">b</th>
<th style="text-align:center">b</th>
<th style="text-align:center">i</th>
<th style="text-align:center">t</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>r</strong></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>a</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>b</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center"><strong>b</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center"><strong>i</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center"><strong>t</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(t.size() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.size(); i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// t 为空，都有一种方法对应</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++) &#123; <span class="comment">// 遍历 s 的每一个位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.size(); j++) &#123; <span class="comment">// 遍历 t 的每一个位置</span></span><br><span class="line">                <span class="keyword">if</span>(s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]) % INT_MAX;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()][t.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="单词接龙-II"><a href="#单词接龙-II" class="headerlink" title="单词接龙 II"></a>单词接龙 II<span id="126"></span></h2><p>按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk 这样的单词序列，并满足：</p>
<p>每对相邻的单词之间仅有单个字母不同。<br>转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。<br>sk == endWord<br>给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, …, sk] 的形式返回。</p>
<p><strong>解法一：递归 + 回溯</strong></p>
<ul>
<li><p>遍历 wordList ，若 endWord 不存在于 wordList，返回空</p>
</li>
<li><p>从当前单词开始，遍历 wordList 的所有单词，若单词距离与当前单词距离为 1， 则进一步递归</p>
</li>
<li>终止条件：当前单词等于 endWord</li>
<li>不出意外地超时了。。。。。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; seen;</span><br><span class="line">    <span class="keyword">int</span> min_len = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">findLadders</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况，endWord 不在 wordList 中</span></span><br><span class="line">        <span class="keyword">bool</span> in_list = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(wordList[i] == endWord) in_list = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(in_list == <span class="literal">false</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        path.push_back(beginWord);</span><br><span class="line">        traverse(beginWord, endWord, wordList);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="built_in">string</span> &amp;curr_word, <span class="built_in">string</span> &amp;end_word, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(curr_word == end_word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path.size() &lt; min_len) &#123; <span class="comment">// 出现更短的路径时，清空之前路径</span></span><br><span class="line">                result.clear();</span><br><span class="line">                min_len = path.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(path.size() == min_len) result.push_back(path); <span class="comment">// 只记录最短路径</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 横向遍历所有 wordList 的单词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist(curr_word, wordList[i]) == <span class="number">1</span> &amp;&amp; seen.find(wordList[i]) == seen.end()) &#123;</span><br><span class="line">                path.push_back(wordList[i]);</span><br><span class="line">                seen.insert(wordList[i]);</span><br><span class="line"></span><br><span class="line">                traverse(wordList[i], end_word, wordList);</span><br><span class="line"></span><br><span class="line">                path.pop_back();</span><br><span class="line">                seen.erase(wordList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s2[i]) dist++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：广度优先搜索 + DFS</strong></p>
<ul>
<li>把每个单词抽象成一个节点，距离为 1 的两个单词之间有边相连，这样可以得到一个图</li>
<li>从一个单词出发，修改每一位字符，替换为 a - z 的所有字母，判断修改后是否在 wordList 中</li>
<li>若 next 在 wordList 中，则将 next 压入队列中，并且记录 next 来自于 curr，记录在 from 中</li>
<li>从终点出发，深度优先遍历 往回找 from，也就是每个词的母节点，直到 from 为空结束</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">findLadders</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_set = &#123;wordList.begin(), wordList.end()&#125;;</span><br><span class="line">        <span class="keyword">if</span>(word_set.find(endWord) == word_set.end()) <span class="keyword">return</span> result; <span class="comment">// 若 endWord 没有出现，false</span></span><br><span class="line"></span><br><span class="line">        word_set.erase(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; steps = &#123;&#123;beginWord, <span class="number">0</span>&#125;&#125;; <span class="comment">// key: 单词 value: 在广度优先遍历的第几层</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; from = &#123;&#123;beginWord, &#123;&#125;&#125;&#125;; <span class="comment">// 记录一个单词可以从哪些单词扩展而来</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; que = <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;&#123;&#123;beginWord&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> word_len = beginWord.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">int</span> size = que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="built_in">string</span> curr = que.front();</span><br><span class="line">                <span class="built_in">string</span> next = curr;</span><br><span class="line">                que.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word_len; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                        next[j] = c; <span class="comment">// 下一个更改后的单词</span></span><br><span class="line">                        <span class="keyword">if</span> (steps[next] == step) &#123;</span><br><span class="line">                            from[next].insert(curr);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(word_set.find(next) == word_set.end()) <span class="keyword">continue</span>; <span class="comment">// 若不在 word_set 中，continue</span></span><br><span class="line">                        word_set.erase(next);</span><br><span class="line">                        que.push(next);</span><br><span class="line"></span><br><span class="line">                        from[next].insert(curr); <span class="comment">// 记录 next 从 curr 变化而来</span></span><br><span class="line">                        steps[next] = step;</span><br><span class="line">                        <span class="keyword">if</span>(next == endWord) found = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next = curr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(found) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 2 步：深度优先遍历找到所有解，从 endWord 恢复到 beginWord ，所以每次尝试操作 path 列表的头部</span></span><br><span class="line">        <span class="keyword">if</span>(found) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = &#123;endWord&#125;;</span><br><span class="line">            dfs(result, endWord, from, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;result, <span class="keyword">const</span> <span class="built_in">string</span> &amp;node, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;from, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(from[node].empty()) &#123;</span><br><span class="line">            result.push_back(&#123;path.rbegin(), path.rend()&#125;); <span class="comment">// 反转 path</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="built_in">string</span> &amp;parent : from[node]) &#123;</span><br><span class="line">            path.push_back(parent);</span><br><span class="line">            dfs(result, parent, from, path);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙<span id="127"></span></h2><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk：</p>
<p>每一对相邻的单词只差一个字母。<br> 对于 1 &lt;= i &lt;= k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。<br>sk == endWord<br>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 。</p>
<p><strong>思路</strong>：本题和 <a href="https://leetcode.cn/problems/word-ladder-ii/" target="_blank" rel="noopener">单词接龙 II</a> 唯一不同的地方在于本题只需要返回最短长度，而不是所有的转换方式。</p>
<p><strong>解法一：BFS + DFS</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_set;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造 word_set 存储所有的单词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str : wordList) word_set.insert(str);</span><br><span class="line">        <span class="comment">// 若 end 不在 word_set 中，return 0</span></span><br><span class="line">        <span class="keyword">if</span>(word_set.find(endWord) == word_set.end()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        word_set.erase(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; from; <span class="comment">// key: 当前节点，value：当前节点的所有父节点 </span></span><br><span class="line">        <span class="comment">// BFS, 从起点开始，找到所有通往终点的路径，存在 from 中</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; que;</span><br><span class="line">        que.push(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="built_in">string</span> curr = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">string</span> next = curr;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; beginWord.size(); j++) &#123; <span class="comment">// 尝试将每个位置替换为 a - z，找到下一个节点 </span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                        next[j] = c; <span class="comment">// 下一个字符</span></span><br><span class="line">                        <span class="keyword">if</span>(word_set.find(next) == word_set.end()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                        word_set.erase(next);</span><br><span class="line">                        que.push(next);</span><br><span class="line">                        from[next].insert(curr);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(next == endWord) found = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next = curr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(found) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        dfs(beginWord, endWord, from, length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp;beginWord, <span class="built_in">string</span> curr_word, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;from, <span class="keyword">int</span> &amp;length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(from[curr_word].empty() &amp;&amp; curr_word == beginWord) &#123;</span><br><span class="line">            result = length;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str : from[curr_word]) &#123; <span class="comment">// 遍历当前节点的所有父节点</span></span><br><span class="line">            length++;</span><br><span class="line">            dfs(beginWord, str, from, length);</span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="单词搜索-II"><a href="#单词搜索-II" class="headerlink" title="单词搜索 II"></a>单词搜索 II<span id="212"></span></h2><p>给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words， 返回所有二维网格上的单词 。</p>
<p>单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<p><strong>解法：DFS</strong></p>
<ul>
<li>对每一个开始的位置，往四个方向进行 DFS，判断每个字符串是否出现在 word 中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> path;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; result_set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; word_set;</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        rows = board.size();</span><br><span class="line">        cols = board[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str : words) word_set.insert(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="comment">// 对每一个位置进行遍历</span></span><br><span class="line">                path.clear();</span><br><span class="line">                path.push_back(board[i][j]);</span><br><span class="line">                <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">seen</span><span class="params">(rows, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(cols, <span class="literal">false</span>))</span></span>;</span><br><span class="line">                seen[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                dfs(board, i, j, seen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str : result_set) result.push_back(str);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;seen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt; <span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(word_set.find(path) != word_set.end()) &#123;</span><br><span class="line">            result_set.insert(path); <span class="comment">// 使用 set 对结果进行去重</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">4</span>; m++) &#123; <span class="comment">// 往四个方向进行查找</span></span><br><span class="line">            <span class="keyword">int</span> x = i + direction[m][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = j + direction[m][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &lt; cols &amp;&amp; seen[x][y] == <span class="literal">false</span>) &#123;</span><br><span class="line">                path.push_back(board[x][y]);</span><br><span class="line">                seen[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                dfs(board, x, y, seen);</span><br><span class="line"></span><br><span class="line">                path.pop_back();</span><br><span class="line">                seen[x][y] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="基本计算器"><a href="#基本计算器" class="headerlink" title="基本计算器"></a>基本计算器<span id="224"></span></h2><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>
<p><strong>解法：栈</strong></p>
<ul>
<li>只有加减法时，括号的作用只会在减号后面存在括号时有所区别</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ops;</span><br><span class="line">        ops.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) &#123; <span class="comment">// 遇到加号时，更新 sign</span></span><br><span class="line">                sign = ops.top();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>) &#123; <span class="comment">// 遇到减号时，反转 sign</span></span><br><span class="line">                sign = -ops.top();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123; <span class="comment">// 遇到左括号时，将 sign 入栈</span></span><br><span class="line">                ops.push(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123; <span class="comment">// 遇到右括号时，将 sign 出栈</span></span><br><span class="line">                ops.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode专题--动态规划</title>
    <url>/2022/06/01/Leetcode%E4%B8%93%E9%A2%98--%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>Leetcode 专题训练：<strong>动态规划</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#115">115</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/distinct-subsequences/" target="_blank" rel="noopener">不同的子序列</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#329">329</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">矩阵中的最长递增路径</a></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列<span id="115"></span></h2><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p><strong>解法：动态规划</strong></p>
<p>已经在 <a href="https://zhoukay.top/2022/05/02/Leetcode%E4%B8%93%E9%A2%98--%E5%AD%97%E7%AC%A6%E4%B8%B2/#115" target="_blank" rel="noopener">Leetcode专题–字符串</a> 中进行了解答。</p>
<h2 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a>地下城游戏<span id="174"></span></h2><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p><strong>解法：动态规划</strong></p>
<ul>
<li>定义 dp[i][j] 为骑士到达格子 (i, j) 需要具备最小的点数，这个点数可以保证骑士安全通过当前格子并且到达终点</li>
<li>为了保证骑士能安全到达终点，所以我们从最后一个格子往前倒推<ul>
<li>当 dp[i][j] 只由一个格子得到时，即 dp[i][j] 在格子边缘，则 dp[i][j] = dp[i - 1][j] (或 dp[i ][j - 1] ) - dungeon[i][j]，且 dp[i][j] 最小为 1（否则死亡）</li>
<li>当 dp[i][j] 由两个格子得到时，dp[i][j] = max(1, min(dp[i - 1][j], dp[i][j - 1]) - dungeon[i][j])</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = dungeon.size();</span><br><span class="line">        <span class="keyword">int</span> cols = dungeon[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 初始化最后一个格子</span></span><br><span class="line">        dp[rows - <span class="number">1</span>][cols - <span class="number">1</span>] = max(<span class="number">1</span>, <span class="number">1</span> - dungeon[rows - <span class="number">1</span>][cols - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = cols - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == rows - <span class="number">1</span> &amp;&amp; j == cols - <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 最后一个格子跳过</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == rows - <span class="number">1</span>) &#123; <span class="comment">// 特殊情况1，最底下一行</span></span><br><span class="line">                    dp[i][j] = max(<span class="number">1</span>, dp[i][j + <span class="number">1</span>] - dungeon[i][j]);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == cols - <span class="number">1</span>) &#123; <span class="comment">// 特殊情况2，最右边一列</span></span><br><span class="line">                    dp[i][j] = max(<span class="number">1</span>, dp[i + <span class="number">1</span>][j] - dungeon[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(<span class="number">1</span>, min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a>矩阵中的最长递增路径<span id="329"></span></h2><p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p>
<p><strong>解法一：DFS 记忆化搜索</strong></p>
<p>在 <a href="https://zhoukay.top/2022/05/02/Leetcode%E4%B8%93%E9%A2%98--DFS/#329" target="_blank" rel="noopener">Leetcode专题–DFS</a> 中有这一题的 DFS 解答。</p>
<p><strong>解法二：动态规划</strong></p>
<ul>
<li>状态定义：dp[i][j] 表示从 (i, j) 出发的最长路径</li>
<li>状态转移，当周围的数大于当前值时，当前最长路径等于周围最大的 + 1</li>
<li>状态转移过程中，必须保证首先计算出来的是数字较大的数，因此需要先对矩阵中的所有元素进行排序，然后再从大到小进行转移</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get&lt;<span class="number">0</span>&gt;(a) &gt; get&lt;<span class="number">0</span>&gt;(b);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; nums; <span class="comment">// val, x, y 三元组集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                nums.push_back(&#123;matrix[i][j], i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(nums.begin(), nums.end(), cmp); <span class="comment">// 对三元组按照 val 从大到小进行排序</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123; <span class="comment">// 遍历所有的位置</span></span><br><span class="line">            <span class="keyword">int</span> x = get&lt;<span class="number">1</span>&gt;(num);</span><br><span class="line">            <span class="keyword">int</span> y = get&lt;<span class="number">2</span>&gt;(num);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;  <span class="comment">// 遍历四个方向</span></span><br><span class="line">                <span class="keyword">int</span> new_x = x + direction[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y = y + direction[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(new_x &gt;= <span class="number">0</span> &amp;&amp; new_x &lt; rows &amp;&amp; new_y &gt;= <span class="number">0</span> &amp;&amp; new_y &lt; cols) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(matrix[new_x][new_y] &gt; matrix[x][y]) &#123;</span><br><span class="line">                        dp[x][y] = max(dp[x][y], dp[new_x][new_y] + <span class="number">1</span>);</span><br><span class="line">                        result = max(result, dp[x][y]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode专题--数组</title>
    <url>/2022/05/02/Leetcode%E4%B8%93%E9%A2%98--%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>Leetcode 专题训练：<strong>数组</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#1">1</a></td>
<td style="text-align:center"><font color="green">简单</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#15">15</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#16">16</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">最接近的三数之和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#18">18</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/4sum" target="_blank" rel="noopener">四数之和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#31">31</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#33">33</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#34">34</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#36">36</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">有效的数独</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#37">37</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">解数独</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#41">41</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#42">42</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#51">51</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/n-queens/" target="_blank" rel="noopener">N 皇后</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#84">84</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和<span id="1"></span></h2><p><strong>题目</strong>：</p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p><strong>解法：</strong></p>
<ul>
<li>使用一个 map 记录遍历过的数组，第一个整数为 （ target - 当前值），第二个整数为 index</li>
<li>遍历数组，对每个 nums[i] 查找 map 中是否存在 ( target - nums[i] )，若存在，则添加到结果中。</li>
<li>复杂度 O(N)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">// int: nums[i], int: index</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(target - nums[i]) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                result.push_back(<span class="built_in">map</span>[target - nums[i]]);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和<span id="15"></span></h2><p><strong>题目</strong>：</p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>解法：排序 + 双指针</strong></p>
<ul>
<li>先对数组进行从小到大排序</li>
<li>第一层循环遍历第一个数：first，并在当前循环进行去重，即当前值 == 前一个值时，需要跳过</li>
<li>第二层循环使用双指针，second 指向 first + 1， third 指向数组末尾，并判断三个数之和，有三种情况：<ul>
<li>sum &gt; 0 ：三个数之和大于 0，需要将右边界左移，使得总和减小，即 third–;</li>
<li>sum &lt; 0：三个数之和小于 0，需要将左边界右移，即 second++</li>
<li>sum == 0：三个数之和等于 0，将当前结果记录到 result，并同时移动左右边界，并且在移动的时候进行去重</li>
</ul>
</li>
<li>复杂度 O(N^2^)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; nums.size() - <span class="number">2</span>; first++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> second = first + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> third = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = - nums[first];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(second &lt; third) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[second] + nums[third];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target) &#123; <span class="comment">// 三数之和大于 0 ，右边界左移</span></span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123; <span class="comment">// 三数之和小于 0 ，左边界右移</span></span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 三数之和等于 0 ，同时移动左右边界</span></span><br><span class="line">                    result.push_back(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">                    second++;</span><br><span class="line">                    third--;</span><br><span class="line">                    </span><br><span class="line">					<span class="comment">// 对 second 进行去重</span></span><br><span class="line">                    <span class="keyword">while</span>(second &lt; nums.size() - <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) second++; </span><br><span class="line">                    <span class="comment">// 对 third 进行去重</span></span><br><span class="line">                    <span class="keyword">while</span>(third &gt; first &amp;&amp; nums[third] == nums[third + <span class="number">1</span>]) third--; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和<span id="16"></span></h2><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p>
<p>返回这三个数的和。</p>
<p><strong>解法：排序 + 双指针</strong>（与三数之和类似）</p>
<ul>
<li>在遍历过程中使用 min_diff 记录与目标值的最小差距，并且当发现有更小的 min_diff 时，更新 result</li>
<li>复杂度 O(N^2^)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end()); <span class="comment">// 从大到小排序</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_diff = INT_MAX; <span class="comment">// 记录 (sum - target) 的最小值</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; nums.size(); first++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> second = first + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> third = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(second &lt; third) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[first] + nums[second] + nums[third];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(sum - target) &lt; min_diff) &#123;</span><br><span class="line">                    min_diff = <span class="built_in">abs</span>(sum - target);</span><br><span class="line">                    result = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target) third--;</span><br><span class="line">                <span class="keyword">else</span> second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和<span id="18"></span></h2><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ol>
<li>0 &lt;= a, b, c, d &lt; n</li>
<li>a、b、c 和 d 互不相同</li>
<li>nums[a] + nums[b] + nums[c] + nums[d] == target</li>
</ol>
<p><strong>解法：排序 + 双指针</strong>（与三数之和类似）</p>
<ul>
<li>先对数组进行从小到大排序</li>
<li>第一层循环遍历第一个数：first，并在当前循环进行去重，即当前值 == 前一个值时，需要跳过</li>
<li>第二层遍历第二个数：second，并在当前层进行去重</li>
<li>第二层循环使用双指针，third 指向 first + 1， fourth 指向数组末尾，并判断四个数之和，有三种情况：<ul>
<li>sum &gt; 0 ：四个数之和大于 0，需要将右边界左移，使得总和减小，即 fourth–;</li>
<li>sum &lt; 0：四个数之和小于 0，需要将左边界右移，即 third++</li>
<li>sum == 0：四个数之和等于 0，将当前结果记录到 result，并同时移动左右边界，并且在移动的时候进行去重</li>
</ul>
</li>
<li>复杂度 O(N^3^)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">4</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; nums.size() - <span class="number">3</span>; first++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 对 a 去重</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; nums.size() - <span class="number">2</span>; second++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 对 b 去重</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> third = second + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> fourth = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> sum_ab = nums[first] + nums[second];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(third &lt; fourth) &#123;</span><br><span class="line">                    <span class="keyword">long</span> sum_cd = nums[third] + nums[fourth];</span><br><span class="line">                    <span class="keyword">if</span>(sum_ab + sum_cd &gt; target) &#123;</span><br><span class="line">                        fourth--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum_ab + sum_cd &lt; target) &#123;</span><br><span class="line">                        third++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.push_back(&#123;nums[first], nums[second], nums[third], nums[fourth]&#125;);</span><br><span class="line">                        third++;</span><br><span class="line">                        fourth--;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(third &lt; nums.size() &amp;&amp; nums[third] == nums[third - <span class="number">1</span>]) third++; <span class="comment">// 对 c 去重</span></span><br><span class="line">                        <span class="keyword">while</span>(fourth &gt; second &amp;&amp; nums[fourth] == nums[fourth + <span class="number">1</span>]) fourth--; <span class="comment">// 对 d 去重</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列<span id="31"></span></h2><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 <code>下一个排列</code> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 <code>原地</code> 修改，只允许使用额外常数空间。</p>
<p><strong>解法</strong></p>
<ul>
<li>先从后向前遍历数组，找到第一组顺序的数字，位置记为 idx 和 idx + 1 <ul>
<li>若未能找到一组顺序，则说明整个数组是逆序的，则将数组从小到大排序后进行返回</li>
</ul>
</li>
<li>在 idx 右边找到第一个大于 nums[idx] 的值，与 nums[idx] 交换位置</li>
<li>将 idx 后的元素按照从小到大进行排列</li>
<li>复杂度 O(N)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.size() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin() + i + <span class="number">1</span>, nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组<span id="33"></span></h2><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。你可以设计一个时间复杂度为 <code>O(log n)</code> 的解决方案吗？</p>
<p><strong>解法：二分查找</strong></p>
<ul>
<li>分析：数组排列方式为：左半部分若干个数升序排列，右半部分也是升序排列，且左半部分所有数均大于右半部分的值</li>
<li>初始化 left 和 right，分别指向数组起点与终点</li>
<li>查找当前 mid 对应的值<ul>
<li>若 nums[mid] == target，return mid</li>
<li>若 [nums[left], nums[mid]]  是有序数组<ul>
<li>若 target 在区间 [nums[mid], nums[right]] 之间，则在 [left, mid - 1] 中进行查找</li>
<li>否则在 [mid + 1, right] 中查找</li>
</ul>
</li>
<li>若 [nums[mid], nums[right]]  是有序数组<ul>
<li>若 target 在区间 [nums[mid + 1], nums[right]] 之间，则在 [mid +1, right] 中进行查找</li>
<li>否则在 [left, mid - 1] 中查找</li>
</ul>
</li>
</ul>
</li>
<li>复杂度：O( logN )</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[left]) &#123;<span class="comment">// mid 在左边升序区间中</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt;= nums[right]) &#123; <span class="comment">// mid 在右边升序区间中</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置<span id="34"></span></h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p>
<p><strong>解法：二分查找</strong></p>
<ul>
<li>两次二分，一次查找左边，一次查找右边;</li>
<li>不同之处在于：在查找过程中比较 nums[left] 和 nums[right] 是否和 target 相等，而不是 nums[mid]</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = binary_search_left(nums, target);</span><br><span class="line">        <span class="keyword">int</span> right = binary_search_right(nums, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;left, right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary_search_left</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] == target) &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[right] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binary_search_right</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[middle] == target) &#123;</span><br><span class="line">                left = middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独<span id="36"></span></h2><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<p><strong>解法：遍历 + 哈希表</strong></p>
<ul>
<li>使用三个哈希表<ul>
<li>rows[9][9]：第一维表示 第 i 行，第二维表示数字 j ，对应的值表示出现的次数</li>
<li>cols[9][9]：与 rows 同理</li>
<li>sub_box[3][3][9]：第 i 行 第 j 列的小方格中数组 k 出现的次数</li>
</ul>
</li>
<li>复杂度： O(N)，只对整个数组遍历一遍</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> cols[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> sub_box[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> str = board[i][j];</span><br><span class="line">                <span class="keyword">if</span>(str != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = str - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    rows[i][idx]++;</span><br><span class="line">                    cols[j][idx]++;</span><br><span class="line">                    sub_box[i / <span class="number">3</span>][j / <span class="number">3</span>][idx]++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(rows[i][idx] &gt; <span class="number">1</span> || cols[j][idx] &gt; <span class="number">1</span> || sub_box[i / <span class="number">3</span>][j / <span class="number">3</span>][idx] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独<span id="37"></span></h2><p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p><strong>解法：回溯</strong></p>
<ul>
<li>对每一个需要填充的位置<ul>
<li>遍历1 - 9 进行填充，填入某个值 i ，检查当前填充值是否有效<ul>
<li>若有效，则进行递归，填充下一个位置</li>
<li>否则回溯一步，将当前填充位置置空</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;        <span class="comment">// 遍历行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++) &#123; <span class="comment">// 遍历列</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">'1'</span>; k &lt;= <span class="string">'9'</span>; k++) &#123;     <span class="comment">// (i, j) 这个位置放k是否合适</span></span><br><span class="line">                    <span class="keyword">if</span> (isValid(i, j, k, board)) &#123;</span><br><span class="line">                        board[i][j] = k;                <span class="comment">// 放置k</span></span><br><span class="line">                        <span class="keyword">if</span> (backtracking(board)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果找到合适一组立刻返回</span></span><br><span class="line">                        board[i][j] = <span class="string">'.'</span>;              <span class="comment">// 回溯，撤销k</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">// 9个数都试完了，都不行，那么就返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> val, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123; <span class="comment">// 判断行里是否重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[row][i] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123; <span class="comment">// 判断列里是否重复</span></span><br><span class="line">            <span class="keyword">if</span> (board[j][col] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> startRow = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> startCol = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startRow; i &lt; startRow + <span class="number">3</span>; i++) &#123; <span class="comment">// 判断9方格里是否重复</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = startCol; j &lt; startCol + <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == val ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数<span id="41"></span></h2><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<p><strong>解法：原地哈希</strong></p>
<ul>
<li>将数组看作为一个哈希表，尝试将每个数 nums[i] 放置在 idx 为 nums[i] - 1 的位置</li>
<li>即数组应该类似于 [1, 2, 3, …] 的形式</li>
<li>从开始遍历，遇到第一个 nums[i] != i + 1 的位置，即返回</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123; <span class="comment">// 遍历数组的每个位置</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= <span class="number">0</span> || nums[i] &gt; nums.size() || nums[i] == nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// // 满足在指定范围内、并且没有放在正确的位置上，才交换</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> idx = nums[i] - <span class="number">1</span>;</span><br><span class="line">                swap(nums[i], nums[idx]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水<span id="42"></span></h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>解法一：动态规划</strong></p>
<p>纵向计算每根柱子的水量</p>
<ul>
<li>对于下标为 i 的柱子，能接的雨水为 min(左边最大柱子， 右边最大柱子) - 当前柱子高度 height[i]</li>
<li>定义两个数组：leftMax, rightMax</li>
<li>从左向右遍历，记录左边的最高柱子为 leftMax[i] = max(leftMax[i - 1], height[i])</li>
<li>从右向左遍历，右边柱子最高 rightMax[i] = max(rightMax[i + 1], height[i])</li>
<li>遍历柱子 i ,对于每个柱子，存储的水量根据第一条进行计算</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = height.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">leftMax</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightMax</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        rightMax[size - <span class="number">1</span>] = height[size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) leftMax[i] = max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) rightMax[i] = max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">            result += curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：单调栈</strong></p>
<p>横向看待每个水平槽的水量</p>
<ul>
<li>维护一个单调栈，存储是下标，并且保证从栈底到栈顶是递减的（其实就是存储一个潜在的水槽的左半边）</li>
<li>遍历到一根水柱，若 stack 中有两个以上的元素，且当前 柱子高度高于 stack.top() ， 则形成一个水槽<ul>
<li>计算水的容量，并将 top 出栈</li>
</ul>
</li>
<li>若 stack 中只有一个元素，则若当前高度小于前一个，入栈</li>
<li>若 stack 为空，直接入栈</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk; <span class="comment">// 单调栈，存储下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++) &#123; <span class="comment">// 遍历每一根柱子</span></span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(stk.empty()) &#123; <span class="comment">// 栈为空，没有left, 退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = stk.top();</span><br><span class="line">                result += (min(height[i], height[left]) - height[top]) * (i - left - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法三：双指针</strong></p>
<ul>
<li>使用两个变量 leftMax 和 rightMax 来代替动态规划中的两个数组</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            leftMax = max(leftMax, height[left]);</span><br><span class="line">            rightMax = max(rightMax, height[right]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right]) &#123;</span><br><span class="line">                result += leftMax - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result += rightMax - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="N-皇后"><a href="#N-皇后" class="headerlink" title="N 皇后"></a>N 皇后<span id="51"></span></h2><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>不能相互攻击需要满足的条件是：</p>
<ul>
<li>不在同一行</li>
<li>不在同一列</li>
<li>不在同一个对角线</li>
</ul>
<p><strong>解法：递归 + 回溯</strong></p>
<ul>
<li>用 vector\&lt;string> 表示当前棋盘状态，vector&lt;vector\&lt;string>&gt; 表示最终的返回结果</li>
<li>遍历每一行，对于每一行的 n 个位置，尝试放置一个皇后，然后判断是否符合不能相互攻击的条件<ul>
<li>判断能否相互攻击，在这种写法下，每一行只有一个皇后，因此不需判断行</li>
<li>判断列，遍历四列，判断每一列皇后是否为1</li>
</ul>
</li>
<li>若符合，则递归遍历下一行，若不符合，将当前位置清空，遍历当前行的下一个位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 初始化 path</span></span><br><span class="line">            path.push_back(<span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row)</span> </span>&#123; <span class="comment">// size 为 n，当前在填充第 row 行</span></span><br><span class="line">        <span class="keyword">if</span>(row == n) &#123;</span><br><span class="line">            result.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123; <span class="comment">// 遍历当前行每一个位置</span></span><br><span class="line">            path[row][col] = <span class="string">'Q'</span>; <span class="comment">// 尝试将当前行填入 ‘Q’</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(is_valid_board(path)) &#123; <span class="comment">// 若满足要求，则继续填充下一行</span></span><br><span class="line">                traverse(n, row + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path[row][col] = <span class="string">'.'</span>; <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_valid_board</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查每一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i][j] == <span class="string">'Q'</span>) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查对角线</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map_main; <span class="comment">// 主对角线，key = i - j</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map_vice; <span class="comment">// 副对角线，key = i + j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i][j] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">                    map_main[i - j]++;</span><br><span class="line">                    map_vice[i + j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = map_main.begin(); it != map_main.end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = map_vice.begin(); it != map_vice.end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="柱状图中的最大矩形"><a href="#柱状图中的最大矩形" class="headerlink" title="柱状图中的最大矩形"></a>柱状图中的最大矩形<span id="84"></span></h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>解法：单调栈</strong></p>
<ul>
<li>对于每一根柱子，其构成的最大矩形方式是，向两边扩展，直到遇到高度小于当前柱子，然后结束（这种方式其实不一定是最大的，比如相邻的柱子 5, 6，对 6 进行扩展，只会选择当前柱子，但这不要紧，因为会在以 5 向两边扩展的时候找到最大的柱子）</li>
<li>因此对于本题，首要是要找到每一根柱子，左右两边第一根小于当前柱子的位置</li>
<li>使用两个数组，分别记录当前柱子左边第一个小于当前高度的位置，和右边第一个小于当前高度的位置。</li>
<li>这可以使用单调栈进行完成，单调栈中保存数组的下标，并且保证从栈底到栈顶是单调递增的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left_idx</span><span class="params">(heights.size(), <span class="number">0</span>)</span></span>; <span class="comment">// 左边第一个小于当前高度的位置</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_idx</span><span class="params">(heights.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="comment">// 第一遍从左向右遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; heights[i] &lt;= heights[stk.top()]) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stk.empty()) left_idx[i] = stk.top();</span><br><span class="line">            <span class="keyword">else</span> left_idx[i] = <span class="number">-1</span>;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二遍从右向左遍历</span></span><br><span class="line">        <span class="keyword">while</span>(!stk.empty()) stk.pop(); <span class="comment">// 清空队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = heights.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; heights[i] &lt;= heights[stk.top()]) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stk.empty()) right_idx[i] = stk.top();</span><br><span class="line">            <span class="keyword">else</span> right_idx[i] = heights.size();</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++) &#123;</span><br><span class="line">            result = max(result, heights[i] * (right_idx[i] - left_idx[i] - <span class="number">1</span>)); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加评论系统Valine</title>
    <url>/2018/08/11/Hexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9FValine/</url>
    <content><![CDATA[<p>一款简洁，方便，好用的评论系统。</p>
<a id="more"></a>
<h2 id="Step1：注册Leancloud"><a href="#Step1：注册Leancloud" class="headerlink" title="Step1：注册Leancloud"></a>Step1：注册Leancloud</h2><hr>
<p>我们的评论系统是放在Leancloud上的,所以首先需要注册一个Leancloud账号。</p>
<p>点击进入<a href="https://leancloud.cn/" target="_blank" rel="noopener">Leancloud官网</a>。</p>
<p>注册完成后需要先创建应用。点击创建应用，弹出如下界面：</p>
<p><img src="/2018/08/11/Hexo添加评论系统Valine/create.JPG" alt="image"></p>
<p>应用名称可以随意取，笔者此处取名为Blog_comment，创建完成后单击进入应用。进入<font color="#0099ff" size="3" face="黑体">设置—应用Key </font>，可以看到APP ID 与 APP Key。</p>
<p><img src="/2018/08/11/Hexo添加评论系统Valine/set.JPG" alt="image"></p>
<h2 id="Step2：修改主题配置文件"><a href="#Step2：修改主题配置文件" class="headerlink" title="Step2：修改主题配置文件"></a>Step2：修改主题配置文件</h2><hr>
<p>打开主题配置文件 搜索 valine，填入appid 和 appkey。在对应位置填上步骤一中的APP ID 与 APP Key。  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">your</span> <span class="string">appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">your</span> <span class="string">appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure>
<p>保存后退出。在git bash 中执行:<br>    <code>hexo server -p 2333</code><br>在浏览器中输入 <a href="http://localhost:2333" target="_blank" rel="noopener">http://localhost:2333</a> ，可以看到添加评论系统后的博客。</p>
]]></content>
      <categories>
        <category>Hexo配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>评论</tag>
        <tag>Leancloud</tag>
      </tags>
  </entry>
  <entry>
    <title>InfluxDB+Grafana可视化</title>
    <url>/2021/05/02/InfluxDB-Grafana%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>InfluxDB是一个用于存储和分析时间序列数据的开源数据库，Grafana是一款采用 go 语言编写的开源应用，主要用于大规模指标数据的可视化展现。两者结合可以方便的进行系统资源监控。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>使用docker分别安装influxDB与grafana</p>
<ul>
<li><p>docker pull influxdb</p>
</li>
<li><p>docker pull grafana/grafana</p>
</li>
</ul>
</li>
</ul>
<h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><ul>
<li><p>docker run -d -p 8083:8083 -p 8086:8086 –name influxdb influxdb</p>
</li>
<li><p>docker run -d -p 3000:3000 –name grafana grafana/grafana:latest</p>
</li>
</ul>
<h2 id="配置InfluxDB"><a href="#配置InfluxDB" class="headerlink" title="配置InfluxDB"></a>配置InfluxDB</h2><ul>
<li><p>使用浏览器打开<a href="http://localhost:8086/" target="_blank" rel="noopener">http://localhost:8086</a>，看到以下界面即安装成功</p>
<p><img src="https://api2.mubu.com/v3/document_image/73cfcef2-7ddf-4550-b5ee-d108b9e71ebf-5720288.jpg" alt="img"></p>
</li>
<li><p>点击开始，输入Username，password，Org，Bucket名称等信息</p>
<ul>
<li>假设用户名和密码为medialab，Org为SJTU，Bucket为demo</li>
</ul>
</li>
<li><p>点击Quick Start，进入主界面</p>
<p><img src="https://api2.mubu.com/v3/document_image/52f1cc41-c92f-4b39-b0bb-fb290962a780-5720288.jpg" alt="img"></p>
</li>
<li><p>点击左侧边栏Data选项，其中Buckets中可以看到创建的demo，也可以另外新建/删除，Tokens中可以复制到访问所需的token</p>
</li>
<li><p>python脚本写入数据示例</p>
<p><img src="https://api2.mubu.com/v3/document_image/4584b374-14fe-46c5-961b-3d8aac96efd7-5720288.jpg" alt></p>
<ul>
<li><p>此即向数据库中写入一条数据，写入后能在浏览器中查询到该数据</p>
<p><img src="https://api2.mubu.com/v3/document_image/c7a1b249-beea-47ac-a36b-2fd908d53b24-5720288.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h2 id="配置Grafana"><a href="#配置Grafana" class="headerlink" title="配置Grafana"></a>配置Grafana</h2><ul>
<li><p>在浏览器中输入<a href="http://localhost:3000/，看到以下界面即为安装成功" target="_blank" rel="noopener">http://localhost:3000/，看到以下界面即为安装成功</a></p>
<p><img src="https://api2.mubu.com/v3/document_image/f7ef9cbf-2314-47b6-aa7c-e023d94302aa-5720288.jpg" alt="img"></p>
</li>
<li><p>输入用户名和密码，初始均为admin，登录后会要求立即修改密码</p>
</li>
<li><p><strong>添加数据源，与InfluxDB联通</strong></p>
<ul>
<li><p>进入Settings-Data Source，点击Add Data Source，选择InfluxDB，配置页面参考下图：</p>
<p><img src="https://api2.mubu.com/v3/document_image/0f065361-5b4c-4994-9193-d0f0db5e2f21-5720288.jpg" alt></p>
<ul>
<li>其中172.16.7.131是宿主机IP地址</li>
</ul>
</li>
<li><p><strong>新建Dashboard</strong></p>
<ul>
<li><p>依次选择Create-New dashboard-Add an empty panel</p>
</li>
<li><p>配置界面格式，添加筛选条件，参考</p>
<ul>
<li><p>from(bucket: “demo”)</p>
</li>
<li><p>|&gt; range(start: v.timeRangeStart, stop: v.timeRangeStop)</p>
</li>
<li><p>|&gt; filter(fn: (r) =&gt; r[“_measurement”] == “mem”)</p>
</li>
<li><p>|&gt; filter(fn: (r) =&gt; r[“_field”] == “encoder”)</p>
</li>
<li><p>|&gt; aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)</p>
</li>
<li><p>|&gt; yield(name: “mean”)</p>
</li>
</ul>
</li>
<li><p>例如添加两个Dashboard，得到的最终效果如图所示<img src="https://api2.mubu.com/v3/document_image/cc885f4c-20f6-4d75-bd46-cc200a789edf-5720288.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode专题--栈</title>
    <url>/2022/05/29/Leetcode%E4%B8%93%E9%A2%98--%E6%A0%88/</url>
    <content><![CDATA[<p>Leetcode 专题训练：<strong>栈</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#726">726</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/number-of-atoms/" target="_blank" rel="noopener">原子的数量</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#895">895</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/maximum-frequency-stack/" target="_blank" rel="noopener">最大频率栈</a></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="原子的数量"><a href="#原子的数量" class="headerlink" title="原子的数量"></a>原子的数量<span id="726"></span></h2><p>给你一个字符串化学式 formula ，返回 每种原子的数量 。</p>
<p>原子总是以一个大写字母开始，接着跟随 0 个或任意个小写字母，表示原子的名字。</p>
<p>如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。</p>
<p>例如，”H2O” 和 “H2O2” 是可行的，但 “H1O2” 这个表达是不可行的。<br>两个化学式连在一起可以构成新的化学式。</p>
<p>例如 “H2O2He3Mg4” 也是化学式。<br>由括号括起的化学式并佐以数字（可选择性添加）也是化学式。</p>
<p>例如 “(H2O2)” 和 “(H2O2)3” 是化学式。<br>返回所有原子的数量，格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。</p>
<p><strong>解法：栈</strong></p>
<ul>
<li>使用一个栈描述括号带来的倍数问题</li>
<li>从后向前遍历，遇到右括号，将当前倍数入栈，遇到左括号，出栈</li>
<li>使用 unordered_map 存储每个原子的名称和大小，最后排序后进行输出</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countOfAtoms</span><span class="params">(<span class="built_in">string</span> formula)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line">        <span class="comment">// 首先将化学式分割成有规律的写法，没有数字的补 1</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; formula.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(formula[i] == <span class="string">'('</span> || formula[i] == <span class="string">')'</span>) &#123; <span class="comment">// 遇到括号</span></span><br><span class="line">                <span class="built_in">string</span> tmp = formula[i] == <span class="string">'('</span> ? <span class="string">"("</span> : <span class="string">")"</span>;</span><br><span class="line">                stk.push(tmp);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(formula[i] &gt;= <span class="string">'A'</span> &amp;&amp; formula[i] &lt;= <span class="string">'Z'</span>) &#123; <span class="comment">// 遇到原子</span></span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; formula.size() &amp;&amp; formula[j] &gt;= <span class="string">'a'</span> &amp;&amp; formula[j] &lt;= <span class="string">'z'</span>) j++;</span><br><span class="line">                stk.push(formula.substr(i, j - i));</span><br><span class="line">                i = j;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; formula.size() &amp;&amp; (formula[i] &lt; <span class="string">'0'</span> || formula[i] &gt; <span class="string">'9'</span>)) &#123;</span><br><span class="line">                    stk.push(<span class="built_in">string</span>(<span class="string">"1"</span>)); <span class="comment">// 在单原子后面补 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(formula[i] &gt;= <span class="string">'0'</span> &amp;&amp; formula[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                 <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; formula.size() &amp;&amp; formula[j] &gt;= <span class="string">'0'</span> &amp;&amp; formula[j] &lt;= <span class="string">'9'</span>) j++;</span><br><span class="line">                stk.push(formula.substr(i, j - i));</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; times;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">// 统计每个原子的数量 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">1</span>; <span class="comment">// 记录前一个下标数字</span></span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">1</span>; <span class="comment">// 记录当前括号的倍数</span></span><br><span class="line">        <span class="keyword">while</span>(!stk.empty()) &#123; <span class="comment">// 从后向前遍历表达式</span></span><br><span class="line">            <span class="built_in">string</span> str = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str == <span class="string">")"</span>) &#123; <span class="comment">// 右括号，</span></span><br><span class="line">                times.push(prev);</span><br><span class="line">                curr *= prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">"("</span>) &#123;</span><br><span class="line">                curr /= times.top();</span><br><span class="line">                times.pop();</span><br><span class="line">                prev = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str &gt;= <span class="string">"0"</span> &amp;&amp; str &lt;= <span class="string">"9"</span>) &#123;</span><br><span class="line">                prev = stoi(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">map</span>[str] += prev * curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出，按照 key 值排序</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; pairs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = <span class="built_in">map</span>.begin(); it != <span class="built_in">map</span>.end(); it++) &#123;</span><br><span class="line">            pairs.push_back(&#123;it-&gt;first, it-&gt;second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(pairs.begin(), pairs.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); i++) &#123;</span><br><span class="line">            result += pairs[i].first;</span><br><span class="line">            <span class="keyword">if</span>(pairs[i].second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                result += to_string(pairs[i].second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode专题--树</title>
    <url>/2022/05/30/Leetcode%E4%B8%93%E9%A2%98--%E6%A0%91/</url>
    <content><![CDATA[<p>Leetcode 专题训练：<strong>树</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#124">124</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">二叉树中的最大路径和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#834">834</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/sum-of-distances-in-tree/" target="_blank" rel="noopener">树中距离之和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#968">968</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-cameras/" target="_blank" rel="noopener">监控二叉树</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#987">987</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的垂序遍历</a></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和<span id="124"></span></h2><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><strong>解法：递归</strong></p>
<ul>
<li>递归遍历每一个节点，对于每个节点<ul>
<li>遍历左子树，找以左子树为起始节点的最大路径长 left</li>
<li>遍历右子树，找以右子树为起始节点的最大路径长 right</li>
<li>返回以当前节点为起始节点的最大长度 max(val, max(val + left), max(val + right))</li>
</ul>
</li>
<li>在每一步遍历的时候记录最长路径</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> result = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        longest_path(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longest_path</span><span class="params">(TreeNode* node)</span> </span>&#123; <span class="comment">// 以 node 为节点的最长路径</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 叶子节点返回当前 val</span></span><br><span class="line">            result = max(node-&gt;val, result);</span><br><span class="line">            <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) left = longest_path(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) right = longest_path(node-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = max(node-&gt;val, max(node-&gt;val + left, max(node-&gt;val + right, node-&gt;val + left + right)));</span><br><span class="line">        result = max(length, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(node-&gt;val, max(node-&gt;val + left, node-&gt;val + right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="树中距离之和"><a href="#树中距离之和" class="headerlink" title="树中距离之和]"></a>树中距离之和]<span id="834"></span></h2><p>给定一个无向、连通的树。树中有 n 个标记为 0…n-1 的节点以及 n-1 条边 。</p>
<p>给定整数 n 和数组 edges ， edges[i] = [ai, bi]表示树中的节点 ai 和 bi 之间有一条边。</p>
<p>返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和。</p>
<p><strong>解法一：树形动态规划</strong></p>
<ul>
<li>定义<ul>
<li>dp[i] 是以 i 为根节点的子树，其所有子节点到 i 的距离之和</li>
<li>sz[i] 表示以 i 为根节点的子树的节点数量</li>
</ul>
</li>
<li>转移方程：dp[u] = sigma(dp[v] + sz[v])，其中 v 是 u 的所有儿子节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans, sz, dp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        sz[u] = <span class="number">1</span>;</span><br><span class="line">        dp[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v: graph[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == f) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(v, u);</span><br><span class="line">            dp[u] += dp[v] + sz[v];</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        ans[u] = dp[u];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v: graph[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == f) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pu = dp[u], pv = dp[v];</span><br><span class="line">            <span class="keyword">int</span> su = sz[u], sv = sz[v];</span><br><span class="line"></span><br><span class="line">            dp[u] -= dp[v] + sz[v];</span><br><span class="line">            sz[u] -= sz[v];</span><br><span class="line">            dp[v] += dp[u] + sz[u];</span><br><span class="line">            sz[v] += sz[u];</span><br><span class="line"></span><br><span class="line">            dfs2(v, u);</span><br><span class="line"></span><br><span class="line">            dp[u] = pu, dp[v] = pv;</span><br><span class="line">            sz[u] = su, sz[v] = sv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sumOfDistancesInTree</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        ans.resize(n, <span class="number">0</span>);</span><br><span class="line">        sz.resize(n, <span class="number">0</span>);</span><br><span class="line">        dp.resize(n, <span class="number">0</span>);</span><br><span class="line">        graph.resize(n, &#123;&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge: edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">            graph[u].emplace_back(v);</span><br><span class="line">            graph[v].emplace_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        dfs2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树<span id="968"></span></h2><p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
<p><strong>解法：递归 + 树形动态规划</strong></p>
<ul>
<li>用三个数字表征当前的节点状态<ul>
<li>0：当前节点无覆盖</li>
<li>1：当前节点有摄像头</li>
<li>2：当前节点被覆盖</li>
</ul>
</li>
<li>对于每一个节点<ul>
<li>若当前节点为 NULL，返回2</li>
<li>递归遍历访问左子树和右子树，记为 left 和 right</li>
<li>若 left 和 right 至少有一个为 0 ，新增一个摄像头，返回1</li>
<li>若 left 和 right 都是1，则返回 0</li>
<li>否则，返回2 </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(traverse(root) == <span class="number">0</span>) &#123; <span class="comment">// 若当前节点没有覆盖</span></span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0-无覆盖, 1-有摄像头, 2-有覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">traverse</span><span class="params">(TreeNode* node)</span> </span>&#123; <span class="comment">// 返回当前节点的状态</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left = traverse(node-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = traverse(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>) &#123; <span class="comment">// 左右节点至少有一个没有被覆盖时，新增一个摄像头</span></span><br><span class="line">            result++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的垂序遍历"><a href="#二叉树的垂序遍历" class="headerlink" title="二叉树的垂序遍历"></a>二叉树的垂序遍历<span id="987"></span></h2><p>给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。</p>
<p>对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。</p>
<p>二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p>
<p>返回二叉树的 垂序遍历 序列。</p>
<p><strong>解法：遍历 + 自定义排序</strong></p>
<ul>
<li>从根节点开始，对整棵树进行一次遍历，在遍历的过程中记录下每个节点的行号、列号及值。</li>
<li>在遍历完成后，我们按照 col 为第一关键字升序，row 为第二关键字升序，value 为第三关键字升序，对所有的节点进行排序即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; nodes;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">verticalTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        sort(nodes.begin(), nodes.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> lastcol = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [col, row, value]: nodes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col != lastcol) &#123;</span><br><span class="line">                lastcol = col;</span><br><span class="line">                ans.emplace_back();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.back().push_back(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        nodes.emplace_back(col, row, node-&gt;val);</span><br><span class="line">        dfs(node-&gt;left, row + <span class="number">1</span>, col - <span class="number">1</span>);</span><br><span class="line">        dfs(node-&gt;right, row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode专题--DFS</title>
    <url>/2022/05/02/Leetcode%E4%B8%93%E9%A2%98--DFS/</url>
    <content><![CDATA[<p>Leetcode 专题训练：<strong>数组深度优先搜索（DFS）</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#94">94</a></td>
<td style="text-align:center"><font color="green">简单</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#98">98</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#99">99</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">恢复二叉搜索树</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#113">113</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">路径总和 II</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#114">114</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#116">116</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">填充每个节点的下一个右侧节点指针</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#124">124</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">二叉树中的最大路径和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#297">297</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化与反序列化</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#329">329</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener"> 矩阵中的最长递增路径</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#332">332</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/reconstruct-itinerary/" target="_blank" rel="noopener">重新安排行程</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#685">685</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/redundant-connection-ii/" target="_blank" rel="noopener">冗余连接 II</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#753">753</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/cracking-the-safe/" target="_blank" rel="noopener">破解保险箱</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#765">765</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/couples-holding-hands/" target="_blank" rel="noopener">情侣牵手</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#675">675</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/cut-off-trees-for-golf-event/" target="_blank" rel="noopener">为高尔夫比赛砍树</a></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历<span id="94"></span></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<p>解法：<strong>递归（DFS）</strong></p>
<ul>
<li>先递归遍历左子树，将当前节点加入 vector，然后递归遍历右子树</li>
<li>终止条件：当前节点为 NULL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        traverse(node-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        result.push_back(node-&gt;val); <span class="comment">// 将当前值加入到 vector</span></span><br><span class="line">        traverse(node-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树<span id="98"></span></h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 小于 当前节点的数。</li>
<li>节点的右子树只包含 大于 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>解法：<strong>中序遍历</strong></p>
<ul>
<li>注意到二叉搜索树 BST 的中序遍历序列是升序的</li>
<li>不需要记录整个遍历序列，只需要依次比较当前值与前一个值即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre_val = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> left = check(node-&gt;left); <span class="comment">// 检查左子树是不是 BST</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &gt; pre_val) &#123; <span class="comment">// 若中序遍历序列不是升序，则 false</span></span><br><span class="line">            pre_val = node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> right = check(node-&gt;right); <span class="comment">// 检查右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树<span id="99"></span></h2><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。</p>
<p><strong>解法：中序遍历</strong></p>
<ul>
<li>中序遍历 BST，得到的数组原本应该是有序的，由于交换了两个位置：<ul>
<li>交换位置相邻：则有一个逆序对</li>
<li>交换位置不相邻：则有两个逆序对</li>
</ul>
</li>
<li>使用 pair&lt; TreeNode*, TreeNode*&gt; rev_pair 来记录逆序对<ul>
<li>若有一对，则交换两个 node 的值</li>
<li>若有两对，则交换第一对的第一个，和第二对的第二个节点值 </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre_node = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; rev_pair; <span class="comment">// 存储逆序的节点对</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        traverse_inorder(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rev_pair.size() == <span class="number">1</span>) &#123; <span class="comment">// 相邻的位置被交换，只有一对逆序对</span></span><br><span class="line">            TreeNode* node1 = rev_pair[<span class="number">0</span>].first;</span><br><span class="line">            TreeNode* node2 = rev_pair[<span class="number">0</span>].second;</span><br><span class="line">            swap(node1-&gt;val, node2-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rev_pair.size() == <span class="number">2</span>) &#123; <span class="comment">// 不相邻的位置被交换，有两个逆序对</span></span><br><span class="line">            TreeNode* node1 = rev_pair[<span class="number">0</span>].first;</span><br><span class="line">            TreeNode* node2 = rev_pair[<span class="number">1</span>].second;</span><br><span class="line">            swap(node1-&gt;val, node2-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse_inorder</span><span class="params">(TreeNode* node)</span> </span>&#123; <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        traverse_inorder(node-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre_node &amp;&amp; node-&gt;val &lt; pre_node-&gt;val) &#123;</span><br><span class="line">            rev_pair.push_back(&#123;pre_node, node&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        pre_node = node;</span><br><span class="line"></span><br><span class="line">        traverse_inorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a>路径总和 II<span id="113"></span></h2><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p><strong>解法：DFS + 递归</strong></p>
<ul>
<li>定义路径 path 和 当前路径总和 sum，以及 返回值 result</li>
<li>若 当前节点为 NULL，return，若当前为叶子节点，特殊处理</li>
<li>否则，遍历左节点，回溯一次</li>
<li>遍历右节点，回溯</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 记录遍历的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        traverse(root, <span class="number">0</span>, targetSum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="keyword">int</span> sum, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 叶子节点，终止迭代</span></span><br><span class="line">            sum += node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(sum == targetSum) &#123;</span><br><span class="line">                path.emplace_back(node-&gt;val);</span><br><span class="line">                result.emplace_back(path);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) traverse(node-&gt;left, sum + node-&gt;val, targetSum);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) traverse(node-&gt;right, sum + node-&gt;val, targetSum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表<span id="114"></span></h2><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>
<p><strong>解法一：前序遍历</strong></p>
<ul>
<li>使用前序遍历，将遍历的数组保存下来</li>
<li>将遍历的数组重建成单链表</li>
<li>空间复杂度 O(N)，与 O(1) 要求不符</li>
</ul>
<p><strong>解法二：前序遍历 + 同步展开</strong></p>
<ul>
<li>前序遍历使用 stack 进行辅助，每次从栈中 pop 出一个节点，如果当前节点不为空，则<ul>
<li>将右节点 push 到栈中</li>
<li>将左节点 push 到栈中</li>
</ul>
</li>
<li>同步展开，维护上一个访问的节点 prev，每次访问一个节点 curr<ul>
<li>prev 左节点设置为 NULL，右节点指向 curr</li>
<li>更新 prev</li>
</ul>
</li>
<li>时间复杂度 O(N)，空间复杂度 O(n)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line"></span><br><span class="line">        TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty()) &#123;</span><br><span class="line">            TreeNode* curr = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right) stk.push(curr-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left) stk.push(curr-&gt;left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                prev-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                prev-&gt;right = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法三：寻找前驱结点</strong></p>
<p>前序遍历都需要存储节点，因此不满足空间复杂度 O(1) 的要求。</p>
<ul>
<li>对于当前节点，如果其左子树不为空，则在其左子树中找到最右边的节点，作为<strong><em>前驱结点</em></strong></li>
<li>将当前节点 curr 的右指针指向前驱结点的右子节点</li>
<li>然后将 curr 的左节点 变成 右节点，并将左节点置空</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                TreeNode* pre_node = curr-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(pre_node-&gt;right != <span class="literal">NULL</span>) &#123; <span class="comment">// 找到左子树的最右节点（前驱结点）</span></span><br><span class="line">                    pre_node = pre_node-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pre_node-&gt;right = curr-&gt;right; <span class="comment">// 将右子树接到前驱结点</span></span><br><span class="line">                curr-&gt;right = curr-&gt;left; <span class="comment">// 左子树换到右边</span></span><br><span class="line">                curr-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针<span id="116"></span></h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<p><strong>解法一：层序遍历</strong></p>
<ul>
<li>借助队列，进行层序遍历</li>
<li>时间复杂度 O(N)，空间复杂度 O(1)</li>
</ul>
<p><strong>解法二：借助 next 指针</strong></p>
<ul>
<li>对于当前节点<ul>
<li>有两个子节点的情况，将下一层的左节点指向右节点</li>
<li>当前 next 不为 NULL 的情况，将 curr 右节点 指向 curr-&gt;next 的左节点</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        Node* left_first = root; <span class="comment">// 每一层最左边的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left_first-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node* head = left_first;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                head-&gt;left-&gt;next = head-&gt;right; <span class="comment">// 同一个父节点的两个节点</span></span><br><span class="line">                <span class="keyword">if</span>(head-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 不同父节点的两个相邻节点</span></span><br><span class="line">                    head-&gt;right-&gt;next = head-&gt;next-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            left_first = left_first-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和<span id="124"></span></h2><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><strong>解法：递归</strong></p>
<ul>
<li>递推关系式：当前节点的路径最长 = max( 当前 val, 左节点最长 + val，val + 右节点最长，左节点最长 + val + 右节点最长)</li>
<li>对于当前节点，如果是叶子节点，则返回当前 val</li>
<li>计算左子树最长路径 left 和右子树最长路径 right</li>
<li>结果取 max(result, val, val + left, val + right, val + left + right) 的最大值</li>
<li>返回值取 max(val, val + left, val + right) 的最大值，这是因为一旦返回，意味着当前不能左右子树都访问而只能选择一路</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> result = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        longest_path(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longest_path</span><span class="params">(TreeNode* node)</span> </span>&#123; <span class="comment">// 以 node 为中间节点的最长路径</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 叶子节点返回当前 val</span></span><br><span class="line">            result = max(node-&gt;val, result);</span><br><span class="line">            <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) left = longest_path(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) right = longest_path(node-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = max(node-&gt;val, max(node-&gt;val + left, max(node-&gt;val + right, node-&gt;val + left + right)));</span><br><span class="line">        result = max(length, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(node-&gt;val, max(node-&gt;val + left, node-&gt;val + right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化<span id="297"></span></h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>解法：层次遍历</strong></p>
<ul>
<li>使用队列辅助进行层次遍历，不同元素用 “,” 分隔，空节点用 # 标识</li>
<li>序列化<ul>
<li>前序遍历整个树，先存当前节点，再存左节点，然后是右节点</li>
</ul>
</li>
<li>反序列化<ul>
<li>根据 “,” 分割当前 string，以 list 存储</li>
<li>以 list 第一个元素为当前节点，新建一个节点</li>
<li>去除首个元素后，递归建立左子树和右子树</li>
<li>遇到 “#” 后返回 NULL</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str + <span class="string">","</span> + serialize(root-&gt;left) + <span class="string">","</span> + serialize(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123; <span class="comment">// 将序列化字符串转成字符串数组</span></span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; nums; </span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] == <span class="string">','</span>) &#123;</span><br><span class="line">                nums.push_back(str);</span><br><span class="line">                str.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> str += data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!str.empty()) &#123; <span class="comment">// 将最后一个元素放入数组</span></span><br><span class="line">            nums.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; &amp;data)</span> </span>&#123; <span class="comment">// 对字符串数组反序列化</span></span><br><span class="line">        <span class="keyword">if</span>(data.front() == <span class="string">"#"</span>) &#123;</span><br><span class="line">            data.erase(data.begin());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* curr = <span class="keyword">new</span> TreeNode(stoi(data.front()));</span><br><span class="line">        data.erase(data.begin());</span><br><span class="line">        curr-&gt;left = deserialize(data);</span><br><span class="line">        curr-&gt;right = deserialize(data);</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a>矩阵中的最长递增路径<span id="329"></span></h2><p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p>
<p><strong>解法：记忆化 DFS</strong></p>
<ul>
<li>从矩阵中每一个单元格进行 DFS，即找到从当前单元格开始的最长递增路径</li>
<li>对于当前单元格，尝试遍历四个方向，在每一个合理的方向上：<ul>
<li>若移动后的值 大于 当前值，则返回 移动后的最大路径 + 1</li>
<li>在遍历时，使用 length 矩阵进行记忆，若当前单元格已经遍历过，直接返回当前单元格的最长路径</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">length</span><span class="params">(matrix.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                result = max(result, dfs(matrix, i, j, length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回以单元格 (row, col) 为起点的最长递增路径</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length[row][col] &gt; <span class="number">0</span>) <span class="keyword">return</span> length[row][col]; <span class="comment">// 若当前已经遍历过，则直接返回</span></span><br><span class="line">        length[row][col]++; <span class="comment">// 长度至少为 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next_row = row + direction[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> next_col = col + direction[i][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(next_row &gt;= <span class="number">0</span> &amp;&amp; next_row &lt; matrix.size() &amp;&amp; next_col &gt;= <span class="number">0</span> &amp;&amp; next_col &lt; matrix[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[next_row][next_col] &gt; matrix[row][col]) &#123;</span><br><span class="line">                    length[row][col] = max(length[row][col], <span class="number">1</span> + dfs(matrix, next_row, next_col, length));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程<span id="332"></span></h2><p>给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<p>例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前。<br>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>
<p><strong>解法：求解欧拉回路 + DFS</strong></p>
<ul>
<li>Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：<ul>
<li>从起点出发，进行深度优先搜索。</li>
<li>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</li>
<li>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</li>
</ul>
</li>
<li>首先构建 <code>unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, std::greater&lt;string&gt;&gt;</code> ，key 值表示出发机场，val 是一个优先级队列，其中按照字典序从小到大记录了目的地的航班，这样每次从优先级队列中取出一个目的地，都能保证是字典序最小的</li>
<li>从起始点开始 <strong>DFS</strong><ul>
<li>对于当前节点，从它的每一个非死胡同（出度与入度差1）分支出发进行 DFS</li>
<li>遍历与当前节点相连的所有节点后，再将当前节点入栈，这能保证死胡同节点是第一个入栈的</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stk; <span class="comment">// 存储遍历的各个顶点（机场）</span></span><br><span class="line">    <span class="comment">// key 表示起点，val 表示终点列表</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, priority_queue&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt;&gt;&gt; <span class="built_in">map</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findItinerary</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tickets) &#123;</span><br><span class="line">            <span class="built_in">map</span>[it[<span class="number">0</span>]].push(it[<span class="number">1</span>]); <span class="comment">// 构建 map</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="string">"JFK"</span>);</span><br><span class="line"></span><br><span class="line">        reverse(stk.begin(), stk.end());</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">map</span>.find(curr) != <span class="built_in">map</span>.end() &amp;&amp; <span class="built_in">map</span>[curr].size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="built_in">map</span>[curr].top(); <span class="comment">//</span></span><br><span class="line">            <span class="built_in">map</span>[curr].pop();</span><br><span class="line">            dfs(str);</span><br><span class="line">        &#125; <span class="comment">// 遍历所有节点后再入栈，可以保证死胡同节点是第一个入栈的</span></span><br><span class="line">        stk.push_back(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="冗余连接-II"><a href="#冗余连接-II" class="headerlink" title="冗余连接 II"></a>冗余连接 II<span id="685"></span></h2><p>在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
<p><strong>解法：并查集</strong></p>
<ul>
<li>分析题目：本质上是一颗有方向的树，添加了一条多余的边，添加的边可能有两种情况：<ul>
<li>指向 root 节点：这会导致一条环路出现</li>
<li>不指向 root 节点：这会导致有一个节点有两个父节点，可能有环，也可能没有环</li>
</ul>
</li>
<li>使用<strong>并查集</strong>来判断是否存在环路以及父节点<ul>
<li>每个节点 i 初始化父亲节点 parent[i] = i</li>
<li>每添加一条边 [u, v]，若 v 节点父亲节点不是 v(说明已经有别的父节点)，则将当前边记为冲突的边</li>
<li>若 u 的父节点和 v 的父节点相同，则说明存在环路</li>
</ul>
</li>
<li>判断该删除哪条边<ul>
<li>若没有冲突的边（两个父节点），则直接删除环路中的最后一条边即可</li>
<li>若存在冲突的边 [u, v]：<ul>
<li>若有环，则不可能是 [u, v]，因为一条边不可能同时是冲突边和环路出现的边，这时候直接删除另一条指向 v 的边即可，所以附加的边是 [parent[v], v]</li>
<li>若没有环，则直接删除冲突的边 [u, v]</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span> <span class="comment">// 并查集实现</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line">        UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">            parent.resize(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) parent[i] = i; <span class="comment">// 初始化，每个人的父节点都是自己</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查找 x 节点的最终父节点，也即其所在的集合</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == parent[x]) <span class="keyword">return</span> x; <span class="comment">// 若该节点的最终父节点是自己，返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> find(parent[x]); <span class="comment">// 否则不断去查找父节点的最终父节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            parent[find(u)] = find(v); <span class="comment">// 认新的父节点，即让 u 的最终父节点认 v 的最终父节点当父亲</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(edges.size() + <span class="number">1</span>)</span></span>; <span class="comment">// 实例化并查集合</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">parent</span><span class="params">(edges.size() +<span class="number">1</span>)</span></span>; <span class="comment">// 记录每条边的父节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= edges.size(); i++) parent[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> conflict = <span class="number">-1</span>, cycle = <span class="number">-1</span>; <span class="comment">// 记录冲突的边和环形边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(parent[v] != v) &#123; <span class="comment">// 节点 v 已经有了父节点，当前为冲突边</span></span><br><span class="line">                conflict = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                <span class="keyword">if</span>(uf.find(u) == uf.find(v)) &#123; <span class="comment">// 存在环形边</span></span><br><span class="line">                    cycle = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    uf.merge(u, v); <span class="comment">// 没有环形边，将 u, v归为一类</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断该删除哪条边</span></span><br><span class="line">        <span class="keyword">if</span>(conflict == <span class="number">-1</span>) &#123; <span class="comment">// 没有冲突边，直接删除最后一个环形边</span></span><br><span class="line">            <span class="keyword">return</span> edges[cycle];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(cycle != <span class="number">-1</span>) &#123; <span class="comment">// 存在环形边</span></span><br><span class="line">                <span class="keyword">int</span> v = edges[conflict][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> &#123;parent[v], v&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> edges[conflict];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="破解保险箱"><a href="#破解保险箱" class="headerlink" title="破解保险箱"></a>破解保险箱<span id="753"></span></h2><p>有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, …, k-1 中的一个 。</p>
<p>你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。</p>
<p>举个例子，假设密码是 “345”，你可以输入 “012345” 来打开它，只是你输入了 6 个字符.</p>
<p>请返回一个能打开保险箱的最短字符串。</p>
<p><strong>题意分析：</strong></p>
<ul>
<li><code>n=1, k=2</code>的时候，就是说密码是1位，可能是0，也可能是1，那么这个答案就应该包含0，也包含1，顺序不重要，<strong>只要按照这答案输入，遇到对的情况自然会打开。</strong></li>
<li><code>n=2, k=2</code>，那么密码就可能是01、10、00、11，密码就应该包含这四种情况，看一下答案，”00110” , “01100”, “10011”, “11001”，是不是这四种答案每个里边都包含这个子串？</li>
<li><code>n=3, k=2</code>，那么密码就应该包含000、001、010、011…还有几个我就不写了，可以看一下答案，答案肯定是包含这几个串的：0011101000</li>
</ul>
<p><strong>解法：求解欧拉回路 + DFS</strong></p>
<p>建模：</p>
<ul>
<li>将 n - 1 位数看作节点，每一位可以填充 0 - (k - 1)，所以共有 K^(n - 1) 个节点</li>
<li>从每个节点出发，有 k 个出边，编号 0 - (k - 1)，编号对应第 n 位的数字。如果当前节点对应的点数为 a1a2…a(n - 1)，则第 x 条出边 对应的节点为 a2a3…a(n-1)x 节点。这样每个节点也有 k 个入边</li>
</ul>
<p><code>例如 k=4k=4，n=3n=3 时，节点分别为 00, 01, 02,..., 32, 3300,01,02,⋯,32,33，每个节点的出边的编号分别为 0, 1, 2, 30,1,2,3，那么 0000 和它的出边形成了 000, 001, 002, 003000,001,002,003 这 44 个 33 位数，3232 和它的出边形成了 320, 321, 322, 323320,321,322,323 这 44 个 33 位数。</code></p>
<p><strong>Hierholzer 算法：</strong></p>
<ul>
<li>从 000 节点 node（n - 1 个 0）出发，沿着 x : 0, 1, 2 ,… k - 1 移动到下一个节点（表示为 10 * node + x）% （10 ^ (n - 1)）</li>
<li>使用 set 记录经过的值，只有在 set 中没有这个值的时候，才进行下一轮迭代</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="built_in">string</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123; <span class="comment">// 沿着 i 向下一个节点移动</span></span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">10</span> * node + i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.find(val) == <span class="built_in">set</span>.end()) &#123;</span><br><span class="line">                <span class="built_in">set</span>.insert(val);</span><br><span class="line">                dfs(val % mod); <span class="comment">// 递归下一个节点</span></span><br><span class="line">                result += (i + <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">crackSafe</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mod = <span class="built_in">pow</span>(<span class="number">10</span>, n - <span class="number">1</span>); <span class="comment">// 模 mod 用来得到 (n-1) 位数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        result += <span class="built_in">string</span>(n - <span class="number">1</span>, <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="情侣牵手"><a href="#情侣牵手" class="headerlink" title="情侣牵手"></a>情侣牵手<span id="765"></span></h2><p>n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。</p>
<p>人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。</p>
<p>返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次交换可选择任意两人，让他们站起来交换座位。</p>
<p><strong>解法一：并查集</strong></p>
<ul>
<li>对于坐在相邻位置上的两个人，构成一个连通分量</li>
<li>并查集初始化时有 N 对情侣（即 N 个联通分量），然后将两两相邻的两个人并在一起，联通分量数减一</li>
<li>最终最小的交换次数是 N - （联通分量数）</li>
</ul>
<h2 id="为高尔夫比赛砍树"><a href="#为高尔夫比赛砍树" class="headerlink" title="为高尔夫比赛砍树"></a>为高尔夫比赛砍树<span id="675"></span></h2><p>你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 m x n 的矩阵表示， 在这个矩阵中：</p>
<p>0 表示障碍，无法触碰<br>1 表示地面，可以行走<br>比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度<br>每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。</p>
<p>你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 1（即变为地面）。</p>
<p>你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。</p>
<p>可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。</p>
<p><strong>解法：记忆化 DFS</strong></p>
<p>这题和 <a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener"> 329. 矩阵中的最长递增路径</a> 相似，从 (0, 0) 位置出发，找到一个最长递增路径。但是由于此题可能会舍近求远，即会先去砍一个更远地方的树，再回头砍近处的树。所以需要先将树节点排序，再对排序后的树两两之间去查找路径。</p>
<ul>
<li>遍历整个矩阵，记录每棵树的坐标，记录为 vector&lt;pair&lt;int, int&gt;&gt; 格式</li>
<li>对 trees 按照高度进行排序</li>
<li>对两两节点直接做路径查找</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; forest, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        m = forest.size();</span><br><span class="line">        n = forest[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; myQue;</span><br><span class="line">        <span class="keyword">int</span> directions[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>; </span><br><span class="line"></span><br><span class="line">        tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; root&#123;<span class="number">0</span>, x1, y1&#125;;</span><br><span class="line">        myQue.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!myQue.empty())&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myQue.size(); ++i)&#123;</span><br><span class="line">                tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; node = myQue.front();</span><br><span class="line">                myQue.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> d = get&lt;<span class="number">0</span>&gt;(node), x = get&lt;<span class="number">1</span>&gt;(node), y = get&lt;<span class="number">2</span>&gt;(node); </span><br><span class="line">                <span class="keyword">if</span> ((x == x2) <span class="keyword">and</span> (y == y2))&#123;</span><br><span class="line">                    <span class="keyword">return</span> d;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">int</span> n_x = x + directions[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> n_y = y + directions[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> ((n_x &gt;= <span class="number">0</span> &amp;&amp; n_x &lt; m) &amp;&amp; (n_y &gt;= <span class="number">0</span> &amp;&amp; n_y &lt; n) &amp;&amp; (forest[n_x][n_y] != <span class="number">0</span> &amp;&amp; (!visited[n_x][n_y])))&#123;</span><br><span class="line">                        visited[n_x][n_y] = <span class="literal">true</span>;</span><br><span class="line">                        myQue.emplace(tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&#123;d + <span class="number">1</span>, n_x, n_y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; forest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; trees;</span><br><span class="line"></span><br><span class="line">        m = forest.size();</span><br><span class="line">        n = forest[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (forest[i][j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_tree&#123;forest[i][j], i, j&#125;;</span><br><span class="line">                    trees.push_back(tmp_tree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(trees.begin(), trees.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start_x = <span class="number">0</span>, start_y = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trees.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> dist = bfs(forest, start_x, start_y, trees[i][<span class="number">1</span>], trees[i][<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (dist &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            start_x = trees[i][<span class="number">1</span>];</span><br><span class="line">            start_y = trees[i][<span class="number">2</span>];</span><br><span class="line">            res += dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/07/02/My%20First%20Blog/</url>
    <content><![CDATA[<p>Hello，这是我的第一篇博客。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>爱狗</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode经典算法</title>
    <url>/2022/04/30/Leetcode%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Leetcode中常用算法：KMP算法 + 树状数组 + 并查集</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">例题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#1">KMP算法</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><a href="#2">树状数组</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><a href="#3">并查集</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/redundant-connection-ii/" target="_blank" rel="noopener">685. 冗余连接 II</a></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组<span id="2"></span></h2><p><strong>树状数组</strong>是一种可以动态维护序列前缀和的数据结构，主要功能有：</p>
<ul>
<li>单点更新：update(i, val)：把序列 i 位置的数字加上一个值 val。</li>
<li>区间查询：prefixSum(i)：查询 [1, i] 区间的区间和，即 i 的位置的前缀和。</li>
<li>区间求和：sumRange(int i, int j)：求原数组闭区间 [i, j] 的和</li>
</ul>
<p>本质上并不是一棵树，而是根据数字的二进制表示来对数组中的元素进行逻辑上的分层存储。</p>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_b76dd0db487add64877ef27de65496a4.png" alt="image-20200927095842317" style="zoom:60%;"></p>
<p>从图中可以看出，每一层的末尾 0 的个数是相同的，且 0 的个数与前置 1 代表了覆盖的长度。如第一层只有 0 个0，代表覆盖长度为 1，第二层末尾都是1 个 0，覆盖长度均为 2。归纳发现</p>
<ul>
<li>t[x] 节点的覆盖长度等于 lowbit(x)</li>
<li>t[x] 父亲节点为 t[x + lowbit(x)]  // 用于更新一个值</li>
<li>t[x] 左侧上一级节点为 t[x - lowbit(x)] //用于计算前缀和</li>
<li>整棵树的深度为 logn + 1</li>
</ul>
<p>修改和查询的时间复杂度都是 O(log n )，其中 n 是需要维护的前缀和的序列的长度。</p>
<p>解析链接：<a href="https://www.cnblogs.com/xenny/p/9739600.html" target="_blank" rel="noopener">https://www.cnblogs.com/xenny/p/9739600.html</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// """树状数组的模板"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit_tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; origin;  <span class="comment">// 记录原始数组，从而能够在update的时候计算出位置i处的值的变化量</span></span><br><span class="line">                         <span class="comment">// bit_tree是该数组的反应</span></span><br><span class="line">    <span class="comment">// C[i] = A[i - 2^k+1] + A[i - 2^k+2] + ... + A[i];   //k为i的二进制中从最低位到高位连续零的长度</span></span><br><span class="line">    <span class="comment">// 其中 C 为 bit_tree 的数值，A 为 origin 的数值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">low_bit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 二进制表达式中最低位的 1 所代表的值，比如 6 = 0110, 则lowbit(6) = 0010 = 2</span></span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定原数据有边界下标值，求其前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">prefixSum</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        index += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result += <span class="keyword">this</span>-&gt;bit_tree[index];</span><br><span class="line">            index -= low_bit(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BIT(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;origin.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;origin.insert(<span class="keyword">this</span>-&gt;origin.end(), nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;bit_tree.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;bit_tree.insert(<span class="keyword">this</span>-&gt;bit_tree.end(), nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化bit_tree</span></span><br><span class="line">        <span class="comment">// 即根据给定i，更新所有能管到i的右边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bit_tree.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + low_bit(i);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; bit_tree.size()) bit_tree[j] += bit_tree[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意此处是将i下标的值更新为val，而不是在原基础上增加val</span></span><br><span class="line">    <span class="comment">// 但是原理还是一样的，先求出其变化值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dec = val - <span class="keyword">this</span>-&gt;origin[i];  <span class="comment">// 注意bit_tree中记录的是区间和，origin记录的才是bit_tree对应的原始数组</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;origin[i] = val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="keyword">this</span>-&gt;bit_tree.size())&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;bit_tree[i] += dec;</span><br><span class="line">            i += low_bit(i); <span class="comment">// 找到当前节点 i 的父亲节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求原数组闭区间[i,j]的和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefixSum(j) - prefixSum(i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集<span id="3"></span></h2><p>并查集是一种树形的数据结构，用于处理一些不相交的集合的合并和查询问题。</p>
<p><a href="https://blog.csdn.net/weixin_44176696/article/details/106434770" target="_blank" rel="noopener">CSDN 教程</a></p>
<p><strong>思想</strong>：用一个数组表示整片森林，树的根节点标识了一个集合，只需要找到某个元素的树根，就能确定其在哪个集合里。</p>
<p><strong>并查集的功能</strong>：</p>
<ul>
<li>合并两个集合</li>
<li>将一个元素并入某一个集合</li>
<li>判断两个元素是否属于同一个集合</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line">    UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        parent.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; </span><br><span class="line">            parent[i] = i; <span class="comment">// 初始化，每个人的最终父节点都是自己</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 查找 index 节点的最终父节点，也即其所在的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == parent[idx]) <span class="keyword">return</span> idx; <span class="comment">// 若该节点的最终父节点是自己，返回</span></span><br><span class="line">        <span class="keyword">return</span> find(parent[idx]); <span class="comment">// 否则不断去查找父节点的最终父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        parent[find(u)] = find(v); <span class="comment">// 认新的父节点，即让 u 的最终父节点认 v 的最终父节点当父亲</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉回路——Hierholzer算法"><a href="#欧拉回路——Hierholzer算法" class="headerlink" title="欧拉回路——Hierholzer算法"></a>欧拉回路——Hierholzer算法</h2><p><strong>欧拉回路：</strong></p>
<p>通过图中所有边恰好一次且行遍所有顶点的回路称为<strong>欧拉回路</strong>。具有欧拉回路的无向图称为<strong>欧拉图</strong>。</p>
<p>为<strong>欧拉回路</strong>。</p>
<p><strong>Hierholzer算法</strong>可以在一个欧拉图中找出欧拉回路。</p>
<ul>
<li>从一个可能的起点出发，进行 DFS，但是每次沿着辅助边从某个顶点转移到另一个顶点时，都需要删除这个辅助边</li>
<li>如果没有可移动的路径，将节点加入到栈中，并返回</li>
<li>最终得到的栈中保存的就是欧拉回路中的顶点。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node, Deque trace)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!node.edges.isEmpty()) &#123;</span><br><span class="line">		Node next = node.edges.removeLast();</span><br><span class="line">		dfs(next, trace);</span><br><span class="line">	&#125;</span><br><span class="line">	trace.addLast(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>单调栈本质上是栈，只是限制要比普通的栈更严格而已了。要求是每次入栈的元素必须要有序（如果新元素入栈不符合要求，则将之前的元素出栈，直到符合要求再入栈），使之形成单调递增/单调递减的一个栈。</p>
<ul>
<li><strong>单调递增栈</strong>：只有比栈顶小的才能入栈，否则就把栈顶出栈后，再入栈。出栈时可能会有一些计算。适用于求解第一个大于该位置元素的数。</li>
<li><strong>单调递减栈</strong>：与单调递增栈相反。适用于求解第一个小于该位置元素的数。</li>
</ul>
<p>单调递增/递减栈是根据出栈后的顺序来决定的。例如，栈内顺序[1, 2, 6]，出栈后顺序[6, 2, 1]，这就是单调递减栈。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">42</td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></td>
</tr>
<tr>
<td style="text-align:center">84</td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></td>
</tr>
<tr>
<td style="text-align:center">739</td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a></td>
</tr>
<tr>
<td style="text-align:center">496</td>
<td style="text-align:center"><font color="green">简单</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/next-greater-element-i/" target="_blank" rel="noopener">下一个更大元素 I</a></td>
</tr>
<tr>
<td style="text-align:center">316</td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/remove-duplicate-letters/" target="_blank" rel="noopener">去除重复字母</a></td>
</tr>
<tr>
<td style="text-align:center">901</td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/online-stock-span/" target="_blank" rel="noopener">股票价格跨度</a></td>
</tr>
<tr>
<td style="text-align:center">402</td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/remove-k-digits/" target="_blank" rel="noopener">移掉 K 位数字</a></td>
</tr>
<tr>
<td style="text-align:center">581</td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">最短无序连续子数组</a></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch入门之MNIST分类实例</title>
    <url>/2018/09/03/Pytorch%E5%85%A5%E9%97%A8%E4%B9%8BMNIST%E5%88%86%E7%B1%BB%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>手写体数字识别，MNIST分类实例。<br><a id="more"></a></p>
<p>初学机器学习，尝试做了一个简单的手写数字识别。本实例选用的是MNIST数据集，基于卷积神经网络，通过两个卷积层，两个池化层和两个全连接层，实现了手写体数字识别。实际测试识别准确率达到98%。这里分享一下我的思路和代码，以期为其他初学者提供一点简单的思路。</p>
<p>点击查看<a href="https://github.com/KayChou/KayChou.github.io/blob/master/2018/09/03/Pytorch%E5%85%A5%E9%97%A8%E4%B9%8BMNIST%E5%88%86%E7%B1%BB%E5%AE%9E%E4%BE%8B/MNIST.py" target="_blank" rel="noopener"> Source Code</a></p>
<p>本实例主要有以下四个步骤：</p>
<blockquote>
<ul>
<li>导入MNIST数据集。</li>
<li>定义网络模型。</li>
<li>模型训练。</li>
<li>模型测试。</li>
</ul>
</blockquote>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>本实例运行环境为：python3 + torch。需要导入的库如下所示。在运行本实例前，请确保以下库均安装成功。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torchvision.datasets <span class="keyword">as</span> datasets</span><br><span class="line"><span class="keyword">import</span> torch.utils.data</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br></pre></td></tr></table></figure>
<h2 id="导入MNIST数据集"><a href="#导入MNIST数据集" class="headerlink" title="导入MNIST数据集"></a>导入MNIST数据集</h2><p>MNIST（Mixed National Institute of Standards and Technology database）是一个计算机视觉数据集，它包含70000张手写数字的灰度图片，其中每一张图片包含 28*28 个像素点（如下图所示）。每一张图片都有对应的标签，也就是图片对应的数字。</p>
<p><img src="/2018/09/03/Pytorch入门之MNIST分类实例/MNIST-Matrix.png" alt="image"></p>
<p>数据集被分成两部分：60000 行的训练数据集（mnist.train）和10000行的测试数（mnist.test）。<br>其中：60000 行的训练集分拆为 55000 行的训练集和 5000 行的验证集。</p>
<p><img src="/2018/09/03/Pytorch入门之MNIST分类实例/mnist-train-xs.png" alt="image"></p>
<p>导入MNIST数据集的函数定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load training and test data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(path)</span>:</span></span><br><span class="line">​    train_data = datasets.MNIST(root=path,</span><br><span class="line">​                                train=<span class="literal">True</span>,</span><br><span class="line">​                                transform=transforms.Compose(</span><br><span class="line">​                                    [transforms.ToTensor(),</span><br><span class="line">​                                     transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))]),</span><br><span class="line">​                                target_transform=<span class="literal">None</span>,</span><br><span class="line">​                                download=<span class="literal">True</span>)</span><br><span class="line">​    train = torch.utils.data.DataLoader(train_data,</span><br><span class="line">​                                        batch_size=<span class="number">64</span>,</span><br><span class="line">​                                        shuffle=<span class="literal">True</span>,</span><br><span class="line">​                                        num_workers=<span class="number">0</span>)</span><br><span class="line">​    test_data = datasets.MNIST(root=path,</span><br><span class="line">​                               train=<span class="literal">False</span>,</span><br><span class="line">​                               transform=transforms.Compose(</span><br><span class="line">​                                   [transforms.ToTensor(),</span><br><span class="line">​                                    transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))]),</span><br><span class="line">​                               target_transform=<span class="literal">None</span>,</span><br><span class="line">​                               download=<span class="literal">True</span>)</span><br><span class="line">​    test = torch.utils.data.DataLoader(test_data,</span><br><span class="line">​                                       batch_size=<span class="number">64</span>,</span><br><span class="line">​                                       shuffle=<span class="literal">True</span>,</span><br><span class="line">​                                       num_workers=<span class="number">0</span>)</span><br><span class="line">​    <span class="keyword">return</span> train, test</span><br></pre></td></tr></table></figure>
<p>该函数传入参数为MNIST数据集的存放路径，输出分别为训练数据集和测试数据集。这里每次训练的图片数量batch_size选为64.</p>
<h2 id="定义网络模型"><a href="#定义网络模型" class="headerlink" title="定义网络模型"></a>定义网络模型</h2><p>本实例中用到的网络模型由两个卷积层，两个池化层和两个全连接层组成。</p>
<p>第一层卷积层输入channel数为1，输出channel数选为10，卷积核大小为5*5。输入为64*1*28*28的张量，输出为64*10*24*24的张量。经过一个2*2的最大池化层，输出张量规模为64*10*12*12。</p>
<p>第二层卷积层输入channel数为10，输出channel数选为20，卷积核大小为5*5。输入为64*10*12*12的张量，输出为64*20*8*8的张量。经过一个2*2的最大池化层，输出张量规模为64*10*4*4。</p>
<p>经过两层卷积后，将所得张量经过两个全连接层，线性映射为1*10的张量，其中每个元素表示该张图片属于相应类别的概率。</p>
<p>网络模型的定义如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">​    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">​        super(Net, self).__init__()</span><br><span class="line">​        self.conv1 = nn.Conv2d(in_channels=<span class="number">1</span>,</span><br><span class="line">​                               out_channels=<span class="number">10</span>,</span><br><span class="line">​                               kernel_size=<span class="number">5</span>)</span><br><span class="line">​        self.conv2 = nn.Conv2d(in_channels=<span class="number">10</span>,</span><br><span class="line">​                               out_channels=<span class="number">20</span>,</span><br><span class="line">​                               kernel_size=<span class="number">5</span>)</span><br><span class="line">​        self.conv2_drop = nn.Dropout2d()</span><br><span class="line">​        self.fc1 = nn.Linear(<span class="number">320</span>, <span class="number">50</span>)</span><br><span class="line">​        self.fc2 = nn.Linear(<span class="number">50</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = F.max_pool2d(x, kernel_size=<span class="number">2</span>)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">    </span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.max_pool2d(x, kernel_size=<span class="number">2</span>)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">    </span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">320</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.dropout(x, training=self.training)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Train the net</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(model, epoch, train_loader, optimizer)</span>:</span></span><br><span class="line">​    model.train()</span><br><span class="line">​    <span class="keyword">for</span> idx, (data, target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">​        optimizer.zero_grad()</span><br><span class="line">​        output = model(data)</span><br><span class="line">​        loss = F.nll_loss(output, target)</span><br><span class="line">​        loss.backward()</span><br><span class="line">​        optimizer.step()</span><br><span class="line">​        <span class="keyword">if</span> idx % <span class="number">50</span> == <span class="number">49</span>:</span><br><span class="line">​            print(<span class="string">'Train epoch: %d   Loss: %.3f    '</span> % (epoch+<span class="number">1</span>, loss))</span><br></pre></td></tr></table></figure>
<p>该函数输入参数为网络模型model，训练轮次epoch，训练数据集train_loader和优化方式optimizer。<br>训练过程中损失函数使用负对数似然函数。</p>
<h2 id="模型测试"><a href="#模型测试" class="headerlink" title="模型测试"></a>模型测试</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Test the net</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(model, test_loader)</span>:</span></span><br><span class="line">​    model.eval()</span><br><span class="line">​    correct = <span class="number">0</span></span><br><span class="line">​    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">​        output = model(data)</span><br><span class="line">​        predict = output.data.max(<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">​        correct = correct + predict.eq(target.data).sum()</span><br><span class="line">​    print(<span class="string">'Accuracy: %2d'</span> % (<span class="number">100</span>*correct/<span class="number">10000</span>), <span class="string">'%'</span>)</span><br></pre></td></tr></table></figure>
<p>该函数传入参数为网络模型model，测试数据集test_loader，并将当前模型识别准确率打印在屏幕上。</p>
<p>到这里，整个实例已经全部定义完成，在主函数中依次调用相应的函数，即可实现手写体数字识别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">​    data_base = <span class="string">'./Datasets'</span></span><br><span class="line">​    mnist_path = os.path.join(data_base, <span class="string">'MNIST'</span>)</span><br><span class="line">​    train_loader, test_loader = load_data(mnist_path)</span><br><span class="line"></span><br><span class="line">    model = Net()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.5</span>)</span><br><span class="line">    epochs = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        train(model, epoch, train_loader, optimizer)</span><br><span class="line">        test(model, test_loader)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">​    main()</span><br></pre></td></tr></table></figure>
<p>运行实例，笔者的测试准确率可以达到98%。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>初学者刚接触机器学习，自身理解和认知有限，欢迎大家在评论区指正和评论。有任何问题也可以在评论区提出。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Pytorch</tag>
        <tag>MNIST</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode专题--链表</title>
    <url>/2022/05/29/Leetcode%E4%B8%93%E9%A2%98--%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>Leetcode 专题训练：<strong>链表</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#23">23</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个升序链表</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#25">25</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">K 个一组翻转链表</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#460">460</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/lfu-cache/" target="_blank" rel="noopener">LFU 缓存</a></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表<span id="23"></span></h2><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>解法一：合并 + 排序</strong></p>
<ul>
<li>依次遍历 K 个链表，合并到一个数组中</li>
<li>对数组排序</li>
<li>对排序后的数组重新构造一个新的链表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> K = lists.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123; <span class="comment">// 遍历每一个链表</span></span><br><span class="line">            ListNode* curr = lists[i];</span><br><span class="line">            <span class="keyword">while</span>(curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                nums.push_back(curr-&gt;val);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(nums.begin(), nums.end()); <span class="comment">// 对数组进行排序</span></span><br><span class="line"></span><br><span class="line">        ListNode* dummy_head = <span class="keyword">new</span> ListNode(); <span class="comment">// 虚拟头结点</span></span><br><span class="line">        ListNode* prev = dummy_head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> ListNode(nums[i]);</span><br><span class="line">            prev-&gt;next = node;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：多指针</strong></p>
<ul>
<li>由于每个链表都已经升序排列，所以对每一个链表使用一个指针指向开始位置</li>
<li>依次比较每个位置，取最小值，加入到虚拟链表中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 特殊情况处理</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; ptr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="built_in">list</span> : lists) ptr.push_back(<span class="built_in">list</span>); <span class="comment">// 初始化每个链表的指针指向起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> finished = <span class="literal">false</span>;</span><br><span class="line">        ListNode* dummy_head = <span class="keyword">new</span> ListNode(); <span class="comment">// 虚拟头结点</span></span><br><span class="line">        ListNode* prev = dummy_head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(finished == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历所有链表的指定节点</span></span><br><span class="line">            <span class="keyword">int</span> min_val = INT_MAX;</span><br><span class="line">            <span class="keyword">int</span> min_idx = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> empty_list_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ptr.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr[i] == <span class="literal">NULL</span>) &#123; <span class="comment">// 当前 ptr 为空</span></span><br><span class="line">                    empty_list_cnt++;</span><br><span class="line">                    <span class="keyword">if</span>(empty_list_cnt == ptr.size()) &#123; <span class="comment">// 所有链表均为空，退出</span></span><br><span class="line">                        finished = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(ptr[i]-&gt;val &lt; min_val) &#123; <span class="comment">// 找到所有位置的最小值，记录对应索引</span></span><br><span class="line">                    min_idx = i;</span><br><span class="line">                    min_val = ptr[i]-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(min_idx == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ListNode* curr = ptr[min_idx];</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> ListNode(curr-&gt;val);</span><br><span class="line">            prev-&gt;next = node;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            ptr[min_idx] = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy_head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法三：分治</strong></p>
<ul>
<li>每次合并两个队列，直到所有都合并</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b)) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = aPtr; aPtr = aPtr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = bPtr; bPtr = bPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt; &amp;lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表<span id="25"></span></h2><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p><strong>解法一：滑动窗口法</strong></p>
<ul>
<li>初始化 left 和 right ，保证 right = left + K - 1，left 初始化为左节点，next 为 right 的下一个节点      </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* left = head;</span><br><span class="line">        ListNode* right = left;</span><br><span class="line"></span><br><span class="line">        ListNode* result = head;</span><br><span class="line">        ListNode* prev = <span class="literal">NULL</span>; <span class="comment">// 前一组指向下一组的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right != <span class="literal">NULL</span> &amp;&amp; step &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">            step++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(step == k - <span class="number">1</span> &amp;&amp; right != <span class="literal">NULL</span>) &#123; <span class="comment">// 找到了一组，需要进行翻转</span></span><br><span class="line">                ListNode* next_group = right-&gt;next; <span class="comment">// 记录下一组的起点</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 翻转当前组的每个指针</span></span><br><span class="line">                ListNode* curr = left;</span><br><span class="line">                ListNode* next = curr-&gt;next;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123; <span class="comment">// 翻转组内部的指针</span></span><br><span class="line">                    ListNode* tmp = next-&gt;next;</span><br><span class="line">                    next-&gt;next = curr;</span><br><span class="line">                    curr = next;</span><br><span class="line">                    next = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理组与组之间的指针</span></span><br><span class="line">                <span class="keyword">if</span>(prev) prev-&gt;next = right;</span><br><span class="line">                left-&gt;next = next_group; <span class="comment">// 前一组指向下一组</span></span><br><span class="line">                prev = left;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(result == head) result = right; <span class="comment">// 新的头结点</span></span><br><span class="line">                <span class="comment">// 将 left 和 right 指向下一组</span></span><br><span class="line">                left = next_group;</span><br><span class="line">                right = next_group;</span><br><span class="line">                step = <span class="number">0</span>; <span class="comment">// step 置零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="LFU缓存"><a href="#LFU缓存" class="headerlink" title="LFU缓存"></a>LFU缓存<span id="460"></span></h2><p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p>
<p>实现 LFUCache 类：</p>
<ul>
<li>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象</li>
<li>int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。</li>
<li>void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。<br>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。</li>
</ul>
<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p>
<p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 3配置anaconda编译环境</title>
    <url>/2018/10/07/Sublime-Text-3%E9%85%8D%E7%BD%AEanaconda%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>Ubuntu16.04下配置Sublime Text 3的anaconda编译环境。</p>
<a id="more"></a>
<p>默认的Sublime Text 3 编译系统中只有python编译，没有anaconda编译，但是很多情况下，我们总是希望能在sublime text 下支持anaconda编译。在已经安装好anaconda的前提下，配置方式如下所述。</p>
<ol>
<li><p>打开sublime text 3,点击上部菜单栏Tools-&gt;Build System-&gt;new Build System,如下图所示。</p>
<p><img src="/2018/10/07/Sublime-Text-3配置anaconda编译环境/sublime.png" alt="image"></p>
</li>
<li><p>点击后，会打开一个新的配置文件，在空白配置文件中拷贝以下代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"cmd"</span>: [<span class="string">"/home/benjamin/anaconda3/bin/python"</span>, <span class="string">"-u"</span>, <span class="string">"$file"</span>],</span><br><span class="line">    <span class="string">"file_regex"</span>: <span class="string">"^[ ]*File \"(...*?)\", line ([0-9]*)"</span>,</span><br><span class="line">    <span class="string">"selector"</span>: <span class="string">"source.python"</span> </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中，”/home/benjamin/anaconda3/bin/python”为anaconda所在的环境路径，需要读者自己修改为自己电脑上的环境。</p>
<ol start="3">
<li>保存配置文件，命名为anaconda。</li>
<li>至此，在sublime text3下的anaconda编译环境就配好了，可以在Tools-&gt;build System中进行选择。</li>
</ol>
]]></content>
      <categories>
        <category>Ubuntu装机</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title>ipv6 服务器搭建 v2ray 方法</title>
    <url>/2022/05/05/ipv6%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAv2ray%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>基于 <a href="https://github.com/233boy/v2ray/tree/master" target="_blank" rel="noopener">233boy</a> 项目进行适当修改，在 ipv6 机器上进行部署。</p>
<a id="more"></a>
<h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p>纯 ipv6 机器不具有 NAT4 访问的能力，因此连基本的 github 都无法直接访问。此时可以通过 <strong>NAT64</strong> 进行转换，NAT64 是一种有状态的网络地址与协议转换技术，一般只支持通过 IPv6网络侧用户发起连接访问 IPv4侧网络资源。 </p>
<p>DNS64是与NAT64搭配使用的，原理很简单，修改你的DNS到DNS64提供者的DNS，当你发出向解析到IPv4的域名的请求后，DNS会将IPv4地址按照一定格式嵌入IPv6地址中；这个返回IPv6地址会指向NAT64的服务器，NAT64网关会按照它包含的信息获取IPv4的数据并转发给你，这样一来你就能够直接访问IPv4的网站了。</p>
<p>一键写入 DNS:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"nameserver 2001:67c:2b0::4\nnameserver 2001:67c:2b0::6"</span> &gt; /etc/resolv.conf</span><br></pre></td></tr></table></figure>
<p>然后下载代码，注意不要下载到 <code>/etc/v2ray/233boy/</code>下，因为后续会安装到这里</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/<span class="number">233</span>boy/v2ray -b <span class="keyword">master</span> <span class="title">v2ray</span> --<span class="attr">depth=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="修改-get-ip-以支持-ipv6"><a href="#修改-get-ip-以支持-ipv6" class="headerlink" title="修改 get_ip() 以支持 ipv6"></a>修改 get_ip() 以支持 ipv6</h2><p>进入下载路径 <code>v2ray</code>，需要修改两个文件：<code>install.sh</code> 和 <code>v2ray.sh</code>，找到 get_ip 函数，修改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">get_ip</span></span>() &#123;</span><br><span class="line">	ip=$(curl -s 6.ipw.cn)</span><br><span class="line">	<span class="comment"># ip=$(curl -s https://ipinfo.io/ip)</span></span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s https://api.ip.sb/ip)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s https://api.ipify.org)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s https://ip.seeip.org)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s https://ifconfig.co/ip)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s https://api.myip.com | grep -oE <span class="string">"([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;"</span>)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s icanhazip.com)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; ip=$(curl -s myip.ipip.net | grep -oE <span class="string">"([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;"</span>)</span><br><span class="line">	[[ -z <span class="variable">$ip</span> ]] &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"\n<span class="variable">$red</span> 这垃圾小鸡扔了吧！<span class="variable">$none</span>\n"</span> &amp;&amp; <span class="built_in">exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要改动内容为，将第一行注释，并添加一个能够返回 ipv6 地址的网址。</p>
<h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><p>使用本地安装模式进行安装：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bash </span><span class="keyword">install.sh </span>local</span><br></pre></td></tr></table></figure>
<p>根据提示进行配置即可。</p>
<h2 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙"></a>开启防火墙</h2><p>若是无法使用，说明端口可能被防火墙禁用，开启对应端口的防火墙即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo ufw status <span class="comment">// 查看防火墙状态</span></span><br><span class="line">sudo ufw allow <span class="number">2333</span> <span class="comment">// 允许 2333 端口通过</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下通过pip安装PyTorch导入报错</title>
    <url>/2018/09/07/Windows%E4%B8%8B%E9%80%9A%E8%BF%87pip%E5%AE%89%E8%A3%85PyTorch%E5%AF%BC%E5%85%A5%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h2 id="报错详情"><a href="#报错详情" class="headerlink" title="报错详情"></a>报错详情</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"C:\Users\username\Code\Python\Test\venv_pytorch\lib\site-packages\torch\__init__.py"</span>, line <span class="number">78</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">   <span class="keyword">from</span> torch._C <span class="keyword">import</span> *</span><br><span class="line">ImportError: DLL load failed: 找不到指定的模块</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>该问题是由于Numpy和当前python版本不兼容造成的。在安装pytorch时，执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install torchvision </span><br></pre></td></tr></table></figure>

该安装命令会自动安装依赖包numpy。主动卸载安装的numpy

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 uninstall numpy </span><br></pre></td></tr></table></figure>
<p>点击访问<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">非官方python拓展库</a>，下拉找到numpy:</p>
<p><img src="/2018/09/07/Windows下通过pip安装PyTorch导入报错/numpy_whl.PNG" alt="image"></p>
<p>选择与自己电脑python对应版本相同的numpy包，点击下载。以笔者的安装环境为例：python版本为64位python35，则选择下载 numpy‑1.15.1+mkl‑cp35‑cp35m‑win_amd64.whl 。</p>
<p>打开下载文件的存储路径，在当前路径下，通过命令行执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install numpy‑<span class="number">1.15</span><span class="number">.1</span>+mkl‑cp35‑cp35m‑win_amd64.whl </span><br></pre></td></tr></table></figure>
<p>等待安装完成，再次导入torch，成功导入！</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>欢迎大家在评论区指正和评论。有任何问题也可以在评论区提出。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16.04配置shadowsocks-qt5客户端</title>
    <url>/2018/09/16/Ubuntu16-04%E9%85%8D%E7%BD%AEshadowsocks-qt5%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<p>Ubuntu16.04下配置shadowsocks客户端实现浏览器翻墙。</p>
<a id="more"></a>
<h3 id="安装shadowsocks-qt5"><a href="#安装shadowsocks-qt5" class="headerlink" title="安装shadowsocks-qt5"></a>安装shadowsocks-qt5</h3><p>首先安装shadowsocks的图形化界面。在终端中依次输入以下三行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure>
<p>在开始菜单中搜索shadowsocks-qt5，图标如下图所示，点击打开。</p>
<p><img src="/2018/09/16/Ubuntu16-04配置shadowsocks-qt5客户端/ss-qt5.png" alt="image"></p>
<p>打开后，点击上方菜单栏Edit，在弹出框如图所示，在弹出框中依次填写相应的服务器IP地址和密码。</p>
<p><img src="/2018/09/16/Ubuntu16-04配置shadowsocks-qt5客户端/edit.png" alt="image"></p>
<p>配置完成后，点击Connect，即可连接成功。</p>
<p>注意，虽然此时已经翻墙，但是Ubuntu此时不会实现全局代理。这是因为shadowsocks只能代理SOCKS5的流量，但Ubuntu走的是https的流量。因此，还需要浏览器搭配相应的插件才能实现翻墙。这里只讲最常用的浏览器chrome。</p>
<p>若Ubuntu中尚未安装chrome，可以到<a href="http://www.ubuntuchrome.com/" target="_blank" rel="noopener">Ubuntu Chrome</a>下载安装。</p>
<p>Chrome需要安装相应的插件，最常用的是<a href="https://www.switchyomega.com/download/" target="_blank" rel="noopener">SwitchyOmega</a>。下载到本地后，将下载下来的crx文件拖动到Chrome浏览器中即可实现安装。安装完成后会自动弹出SwitchyOmega的配置界面。</p>
<p><img src="/2018/09/16/Ubuntu16-04配置shadowsocks-qt5客户端/swi.png" alt="image"></p>
<p>点击New Profile，命名可以随便取，这里笔者命名为vultr（为VPN供应商的名称），里面内容按上图中填写即可。最后点击Apply changes退出即可。</p>
<p>在shadowsocks中点击connect连接成功后，在浏览器中右上角插件中找到SwitchyOmega，单击后弹出以下界面：</p>
<p><img src="/2018/09/16/Ubuntu16-04配置shadowsocks-qt5客户端/switch.png" alt="image"></p>
<p>此时默认的是直接连接，不会走任何代理，在需要翻墙时，切换到相应的代理（笔者这里是vultr）即可实现翻墙。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>欢迎大家在评论区指正和评论。有任何问题也可以在评论区提出。</p>
]]></content>
      <categories>
        <category>Ubuntu装机</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>Shadowsocks GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法》知识点</title>
    <url>/2022/04/30/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>《计算机网络-自顶向下方法》的知识点整理。</p>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h2><p>协议分层具有概念化和结构化的特点，使得更新系统组件更为容易。</p>
<p><strong>因特网的协议栈</strong>由五个层次组成：应用层、运输层、网络层、链路层和物理层。</p>
<table>
<thead>
<tr>
<th style="text-align:center">层次</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center">网络应用程序及应用层协议存留的地方。<br>典型协议有：<strong>HTTP</strong>（web 报文），<strong>SMTP</strong>（电子邮件） 和 <strong>FTP</strong>（文件传输） 等</td>
</tr>
<tr>
<td style="text-align:center">运输层</td>
<td style="text-align:center">在应用程序端点之间传送应用层报文，有两种协议：<strong>TCP</strong> 和 <strong>UDP</strong></td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">运输层向网络层递交报文及目的 IP，网络层进行 <strong>IP</strong> 传输</td>
</tr>
<tr>
<td style="text-align:center">链路层</td>
<td style="text-align:center">主要包括<strong>以太网</strong>、<strong>WiFi</strong>、和<strong>电缆</strong>接入等，对数据进行<strong>分组传输</strong></td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">与实际传输介质相关，将一个一个<strong>比特</strong>通过链路（双绞线、光纤等）进行传输</td>
</tr>
</tbody>
</table>
<p>在 20 世纪 70 年代后期，国际标准化组成（ISO）提出计算机网络围绕 7 层进行组织，称为开放系统互联（OSI）模型。</p>
<p>OSI 七层模型分为是：应用层、表示层、会话层、运输层、网络层、链路层和物理层。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>体素拍摄调研</title>
    <url>/2022/05/04/%E4%BD%93%E7%B4%A0%E6%8B%8D%E6%91%84%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">公司</th>
<th style="text-align:center">设备</th>
<th style="text-align:center">价格</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>Intel Studios</strong></td>
<td style="text-align:center">120 路定制相机</td>
<td style="text-align:center">100K +</td>
</tr>
<tr>
<td style="text-align:center"><strong>8i</strong></td>
<td style="text-align:center">41 路定制相机</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>Dimension</strong></td>
<td style="text-align:center">106 路定制相机</td>
<td style="text-align:center">100K +</td>
</tr>
<tr>
<td style="text-align:center"><strong>DoubleMe</strong></td>
<td style="text-align:center">1 路定制相机</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p><a href="https://www.volumetric-video.com/volumetric-capture-companies/" target="_blank" rel="noopener">Top Volumetric Capture companies list</a></p>
<h2 id="Intel-Studios"><a href="#Intel-Studios" class="headerlink" title="Intel Studios"></a><strong>Intel Studios</strong></h2><p>Intel 在洛杉矶的体积捕捉工作室，拥有一个 4 层，10000 平方英尺的圆顶建筑。</p>
<p>于 2018 年初开放了该设施，其中心是一个巨大的圆形绿幕平台，上面装有 100 多台 8K 摄像机，所得数据能够用于创建 AR 体验所需要的的 3D 全息图或沉浸式的 VR 视频。目前已经于 2020 年 10 月关闭。</p>
<p><img src="/2022/05/04/体素拍摄调研/intel-studios-dome.png" alt="intel-studios-dome"></p>
<h2 id="8i"><a href="#8i" class="headerlink" title="8i"></a><a href="https://8i.com/" target="_blank" rel="noopener">8i</a></h2><h3 id="拍摄"><a href="#拍摄" class="headerlink" title="拍摄"></a>拍摄</h3><p>24 - 60 台同步相机，提供 2K 或 4K 分辨率。整个舞台的灯光控制。</p>
<p><img src="https://8i.com/wp-content/uploads/2021/06/CH5_5556-2048x1366.jpg" alt></p>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>重建 + 压缩 + 编辑，生成 3D 内容。</p>
<ul>
<li><p><strong>融合</strong>：使用机器学习，超快速深度求解和 CG 技术快速重建多个视频源。可通过任意数量的 GPU 进行扩展，并使用摄影测量方法确保准确重建人类、动物和道具，不需要任何人工干预</p>
</li>
<li><p><strong>压缩</strong>：超过 1000x 的压缩比，基于 mesh 的输出</p>
</li>
<li><strong>编辑</strong>：提供编辑软件，对 3D 内容进行编辑。</li>
</ul>
<p><img src="/2022/05/04/体素拍摄调研/8i.gif" alt></p>
<h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>支持 VOD，CDN 分发。还直接与 Unity、Unreal 和 8th Wall 集成。 </p>
<h2 id="Dimension"><a href="#Dimension" class="headerlink" title="Dimension"></a><a href="https://www.dimensionstudio.co/studios" target="_blank" rel="noopener">Dimension</a></h2><p>在各地都有工作室，包括华盛顿，伦敦，加州新城堡和移动工作室等。</p>
<p><img src="/2022/05/04/体素拍摄调研/dimension.png" alt></p>
<h2 id="DoubleMe"><a href="#DoubleMe" class="headerlink" title="DoubleMe"></a><a href="https://www.doubleme.me/" target="_blank" rel="noopener">DoubleMe</a></h2><p><img src="/2022/05/04/体素拍摄调研/doubleme.png" alt></p>
<p>三个产品：</p>
<ul>
<li><p><strong>HoloPort</strong>：</p>
<p>HoloPort™ 是一个简单的软件解决方案，可以记录和流式传输具有颜色和深度的人物。 使用任何 3D 相机和 PC 在世界任何地方使用 HoloPort™ - 就像在计算机上安装网络摄像头一样简单。</p>
</li>
<li><p><strong>Hologram Room</strong>：</p>
<p>全息图室，融合了真实与虚拟世界的体验中心。</p>
</li>
<li><p><strong>HoloPortal</strong>：</p>
<p>HoloPortal 位于伦敦和首尔，是一个身临其境的立体工作室，捕捉和流式传输 3D 人物和对象，为下一代媒体创建持久的数字内容。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>3D 视觉</category>
      </categories>
      <tags>
        <tag>3D 视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>《视觉SLAM十四讲》知识点</title>
    <url>/2021/04/30/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%E3%80%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>SLAM 是 Simultaneous Localization and Mapping 的缩写，中文译作“<strong>同时定位与**</strong>地图构建**” 。它是指搭载特定传感器的主体，在没有环境先验信息的情况下，于运动过程中建立环境的模型，同时估计自己的运动。</p>
<p>完整的 SLAM 分为以下几个模块：<strong>视觉里程计</strong>、<strong>后端优化</strong>、<strong>建图</strong>和<strong>回环检测</strong>。</p>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="三维空间刚体运动"><a href="#三维空间刚体运动" class="headerlink" title="三维空间刚体运动"></a>三维空间刚体运动</h2><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p>旋转矩阵 <strong>R</strong> 可以描述相机的旋转，它是一个<strong>正交阵</strong>，且<strong>行列式为1</strong>。在欧式变换中，除了旋转之外还有平移，考虑在世界坐标系中的向量 a ，经过一次旋转和一次平移之后，得到了 a’ ，则有表达式：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/1.png"></p>
<p>上面的变换不是一个线程关系，当进行多次变换之后，表达式会变得复杂，因此引入齐次坐标和变换矩阵重写：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/2.png" style="zoom:80%;"></p>
<p>这里的矩阵 <strong>T</strong> 称为<strong>变换矩阵</strong>。</p>
<h3 id="旋转向量"><a href="#旋转向量" class="headerlink" title="旋转向量"></a>旋转向量</h3><p>任何旋转都可以用一个<strong>旋转轴</strong>和一个<strong>旋转角</strong>来描述，可以使用一个向量，其方向与旋转轴一致，而长度等于旋转角，这个向量就称为<strong>旋转向量</strong>。</p>
<p>由旋转向量到旋转矩阵转移的过程由 罗德里格斯公式 给出。</p>
<h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>欧拉角将一个旋转分解成三次绕不同轴的旋转，例如航空中的“偏航-俯仰-滚转(yaw - pitch - roll)” 来描述一个旋转，相当于分别绕着 ZYX 轴进行旋转（正前方为 X，右侧为 Y，上方为 Z）。</p>
<p>欧拉角的重大缺点是会碰到著名的<strong>万向锁</strong>问题：例如在俯仰角为 ± 90° 时，第一次旋转和第三次旋转将使用同一个轴，这导致系统丢失了一个自由度。</p>
<h3 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h3><p>四元数既是紧凑的，也没有奇异性。</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/3.png" style="zoom:50%;"></p>
<p>假设某个旋转是绕着单位向量 <strong>n</strong> 进行了角度为 <strong>θ</strong> 的旋转，那么旋转的四元数形式为：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/4.png"></p>
<h3 id="相似、仿射、射影（透视）变换"><a href="#相似、仿射、射影（透视）变换" class="headerlink" title="相似、仿射、射影（透视）变换"></a>相似、仿射、射影（透视）变换</h3><p><strong>相似变换</strong>比欧式变化多了一个自由度，允许物体进行均匀的缩放。</p>
<p><strong>仿射变换</strong>是平移、旋转、放缩、反射和剪切变换的有机组合。</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/5.png"></p>
<p>射影变换是最一般的变换，从真实世界到相机照片的变换是一个射影变换，也叫作<strong>透视变换</strong>。</p>
<p><strong>正交变换</strong>：是线性空间的一种，欧式空间的正交变换只包括旋转、反射和他们的组合。</p>
<center>常见变换性质比较</center>

<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/6.png"></p>
<hr>
<h2 id="李群与李代数"><a href="#李群与李代数" class="headerlink" title="李群与李代数"></a>李群与李代数</h2><h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><p>群（Group）是一种 <strong>“一种集合 + 一种运算”</strong> 的代数结构，将集合记作 A，运算记作 · ，则群可以记作 G= （A, · )。群要求这个运算满足以下几个条件：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/7.png"></p>
<p>举例：旋转矩阵集合 和 矩阵乘法构成群，变换矩阵 和 矩阵乘法 也构成群，索引可以称为 旋转矩阵群和变换矩阵群。</p>
<p>常见的群有：</p>
<ul>
<li>一般线性群 <strong>GL(n)</strong>：指 n x n 的可逆矩阵，对矩阵乘法成群。</li>
<li>特殊正交群 <strong>SO(n)</strong>：旋转矩阵群，其中以 <strong>SO(2)</strong> 和 <strong>SO(3)</strong> 最为常见。</li>
<li>特殊欧式群 <strong>SE(n)</strong>：n 维欧式变换。</li>
</ul>
<p><strong>李群</strong>：具有连续（光滑）性质的群。SO(n) 和 SE(n) 都是连续的，因为我们能够直观地想象一个刚体能够连续地在空间中运动，因此他们都是李群。</p>
<h3 id="李代数"><a href="#李代数" class="headerlink" title="李代数"></a>李代数</h3><p>李代数由一个集合，一个数域 F 和一个二元运算 [, ] 组成，若他们满足：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/16.png"></p>
<p>则称集合，数域和二元运算为一个李代数。</p>
<p>考虑任意旋转矩阵 <strong>R</strong>，其随着时间连续的变化，记为 <strong>R(t)</strong> 满足：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/8.png"></p>
<p>两边求导，并整理：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/9.png"></p>
<p>可以看出<img src="/2021/04/30/《视觉SLAM十四讲》知识点/10.png"> 是一个<strong>反对称矩阵</strong>。已知任意一个反对称矩阵，我们可以找到一个向量，经过符号 <strong>^</strong> 运算后，与该矩阵相同。其中：</p>
<p> <strong>^</strong> 运算为：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/11.png"></p>
<p>由于<img src="/2021/04/30/《视觉SLAM十四讲》知识点/10.png">是反对称矩阵，因此可以找到一个三维向量 <strong>φ(t)</strong> ，满足： <strong>φ(t)</strong> = <img src="/2021/04/30/《视觉SLAM十四讲》知识点/10.png">。</p>
<p>整理得：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/12.png"></p>
<p>上述表达式表明，每对旋转矩阵求一次导数，只需要左乘一个矩阵即可。进一步，设 φ 在零时刻保持常数且为 φ0，则有：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/13.png"></p>
<p>这是一个关于 R(t) 的微分方程，其解的形式为：</p>
<p><img src="/2021/04/30/《视觉SLAM十四讲》知识点/15.png"></p>
<p>根据上式，给定某个时刻的 <strong>R</strong> ，我们可以求得一个 <strong>φ</strong>，它描述了 <strong>R</strong> 在局部的导数关系。</p>
<p> <strong>φ</strong> 事实上是一种李代数，SO(3) 对应的李代数是定义在 R^3^ 上的向量。</p>
]]></content>
      <categories>
        <category>3D 视觉</category>
      </categories>
      <tags>
        <tag>3D 视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>基于BASYS2的音乐盒的制作与调试</title>
    <url>/2018/07/03/%E5%9F%BA%E4%BA%8EBASYS2%E7%9A%84%E9%9F%B3%E4%B9%90%E7%9B%92%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>摘要：基于BASYS2开发板，外接蜂鸣器，设计、调试并制作一个简易音乐盒。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>关键词：BASYS2，Verilog，音乐发生器</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><ul>
<li>在基本掌握verilog语法和掌握BASYS2开发板的流程的基础上，通过自行设计、调试并制作一个简易音乐盒，进一步巩固自己所学的知识，掌握稍复杂电路的设计方法和制作流程，深化工程开发的体验，提高自身提出问题、分析问题和解决问题的能力。</li>
</ul>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul>
<li>基础部分:制作一个简易音乐盒，将BASYS2开发板外接蜂鸣器，可以通过蜂鸣器播放出音乐。</li>
<li>拓展部分：在实现音乐播放的基础上，增加音乐暂停功能和切歌功能。</li>
</ul>
<h2 id="实验原理与设计"><a href="#实验原理与设计" class="headerlink" title="实验原理与设计"></a>实验原理与设计</h2><h3 id="音乐播放原理"><a href="#音乐播放原理" class="headerlink" title="音乐播放原理"></a>音乐播放原理</h3><ul>
<li>音乐由音调和音长组成，其中。频率的高低决定了音调的高低，音符的持续时间和数目决定了音长。所以，只要将音调和音长控制好就能演奏出动听的乐曲。音乐播放的原理图如图所示。</li>
</ul>
<p><img src="/2018/07/03/基于BASYS2的音乐盒的制作/basys2_beep.png" alt="image"></p>
<h3 id="音调控制"><a href="#音调控制" class="headerlink" title="音调控制"></a>音调控制</h3><ul>
<li>限于BASYS2开发板中只提供50Hz的时钟信号，所有不同频率的信号都是从只能从基准频率分频得来。因此需要选择合适的基准频率以及每个音符对应的分频比。由于分频比只能是整数，若基准频率过低，则分频比太小，四舍五入取整后的误差较大。若基准频率过高，虽然误差变小，但分频数将变大。实际的设计应综合考虑两方面的因素，在尽量减小频率误差的前提下选取合适的基准频率与每个音符的分频比。</li>
<li>通过查阅资料，发现基准频率一般选取6MHz。对应每个音符的频率和相应的分频比如下表所示。分频比是从6MHz基准频率通过二分频得到的3MHz基础上计算得到的。对于乐曲中的休止符，分频系数为0。</li>
</ul>
<table>
<thead>
<tr>
<th>音调</th>
<th>低音</th>
<th>分频比</th>
<th>中音</th>
<th>分频比</th>
<th>高音</th>
<th>分频比</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>262</td>
<td>11450</td>
<td>523</td>
<td>5736</td>
<td>1046</td>
<td>2868</td>
</tr>
<tr>
<td>2</td>
<td>294</td>
<td>10204</td>
<td>587</td>
<td>5110</td>
<td>1175</td>
<td>2553</td>
</tr>
<tr>
<td>3</td>
<td>330</td>
<td>9090</td>
<td>659</td>
<td>4552</td>
<td>1318</td>
<td>2276</td>
</tr>
<tr>
<td>4</td>
<td>349</td>
<td>8595</td>
<td>698</td>
<td>4297</td>
<td>1397</td>
<td>2174</td>
</tr>
<tr>
<td>5</td>
<td>392</td>
<td>7653</td>
<td>784</td>
<td>3826</td>
<td>1568</td>
<td>1913</td>
</tr>
<tr>
<td>6</td>
<td>440</td>
<td>6818</td>
<td>880</td>
<td>3409</td>
<td>1760</td>
<td>1704</td>
</tr>
<tr>
<td>7</td>
<td>494</td>
<td>6072</td>
<td>988</td>
<td>3036</td>
<td>1967</td>
<td>1525</td>
</tr>
</tbody>
</table>
<h3 id="音长的控制"><a href="#音长的控制" class="headerlink" title="音长的控制"></a>音长的控制</h3><ul>
<li>由于每首歌的曲速和节拍的时间有一定的差异，所以每个音符的持续时间会有差异。假定节奏较慢的音乐最短的音符为四分音符，全音符的持续时间为1s，则需要提供一个4Hz的时钟信号。若最短的音符为8分音符，则同理需要提供一个8Hz的时钟信号。当然，如果曲速不同导致全音符的时间不是1s时，需要调整相应的参数使的音乐不会有较大的失真。由于本实验中不要求对音乐的精准控制，所以该参数根据实际的播放效果调节即可。</li>
</ul>
<h3 id="音乐暂停键的实现"><a href="#音乐暂停键的实现" class="headerlink" title="音乐暂停键的实现"></a>音乐暂停键的实现</h3><ul>
<li>音乐暂停键的实现较为简单，可以由一个条件语句实现。将输出端与指定的暂停键关联，当暂停键为真时，将输出端从音乐时钟信号脱离，反之则将音乐时钟信号输出。该功能实现代码可以由问号-冒号运算符简单实现</li>
</ul>
<h3 id="音乐切换的实现"><a href="#音乐切换的实现" class="headerlink" title="音乐切换的实现"></a>音乐切换的实现</h3><ul>
<li>本实验中内置了两首曲目，并且是两首曲速不同的曲目。其中一首最短的音符为四分音符，另一首的最短的音符为八分音符。鉴于两手歌的曲速有较大的差异，因此需要两个乐谱时钟频率。可以通过程序定义乐谱时钟频率的选择与开发板上的一个button对应。当button被按下时，会产生一个时钟上升沿，检测到该上升沿后接通不同的时钟频率，并且更改播放曲目的编号，由此便实现了音乐切换的功能。</li>
</ul>
<h2 id="调试问题分析与解决"><a href="#调试问题分析与解决" class="headerlink" title="调试问题分析与解决"></a>调试问题分析与解决</h2><h3 id="曲速控制"><a href="#曲速控制" class="headerlink" title="曲速控制"></a>曲速控制</h3><ul>
<li>曲速控制是一个比较麻烦的事情，需要不断调整分频比使的音乐基本不失真，并且，由于开发板上提供的时钟频率并不是严格的50MHz，所以对乐谱时钟频率的分频只能通过不断地尝试和3烧录后的结果来逐渐调整。尤其是两首歌的曲速不同需要不同的乐谱时钟频率，在确定该分频比的尝试中花费了不少时间。</li>
<li>当然，乐谱时钟频率也可以只使用一个，但是这样会导致曲速慢的曲目的音符大量重复，造成大量的冗余代码，所以两相权衡之下，还是选择了不同的乐谱时钟频率.</li>
</ul>
<h3 id="曲目切换"><a href="#曲目切换" class="headerlink" title="曲目切换"></a>曲目切换</h3><ul>
<li>按照实际的应用场景来看，曲目切换通常会提供两个button，分别对应上一首和下一首，由于本实验中只提供了两首内置歌曲，所以只提供了一个切换键。</li>
<li>当然，在实现本功能的过程中，也遇到了一个问题。即开始的时候通过检测button的状态为0或是为1来判定是否切换歌曲。但是后来发现每次button按下的时候，有时候歌曲切换但有时候又不切换，经过一定的debug之后，猛然反应过来每次button被按下时，在button状态为1时，可能里面有很多个时钟，所以切歌状态瞬间发生了很多次，最终导致歌曲切换发生问题。</li>
<li>解决办法也比较简单，即不检测button的0/1状态，而是检测button的上升沿，这样便解决了该问题。</li>
</ul>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><ul>
<li>通过本次实验，自己对verilog语言的特点和编程逻辑有了更深刻的认识。对BASYS2开发板的使用愈加娴熟。并且通过自行设计、调试并制作一个简易音乐盒，进一步巩固了自己所学的知识，掌握稍复杂电路的设计方法和制作流程，提高自身提出问题、分析问题和解决问题的能力。</li>
</ul>
]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>基于LSTM的2048游戏AI</title>
    <url>/2019/01/30/%E5%9F%BA%E4%BA%8ELSTM%E7%9A%842048%E6%B8%B8%E6%88%8FAI/</url>
    <content><![CDATA[<p>基于LSTM的2048游戏AI。</p>
<a id="more"></a>
<p>本项目在<a href="https://github.com/duducheng/2048-api" target="_blank" rel="noopener">duducheng</a>的基础上，通过循环卷积神经网络（RNN）的变体——训练了一个模型，实现了一个2048游戏AI。实测该模型平均可以达到1300分以上。</p>
<p>点击链接查看<a href="https://github.com/KayChou/2048-api" target="_blank" rel="noopener">项目源码</a></p>
<p>本文主要从以下几个方面说明该项目的方法和原理：</p>
<blockquote>
<ol>
<li>运行环境</li>
<li>数据集获取及定义</li>
<li>网络模型搭建</li>
<li>模型训练</li>
<li>结果测试</li>
</ol>
</blockquote>
<h3 id="运行环境说明"><a href="#运行环境说明" class="headerlink" title="运行环境说明"></a>运行环境说明</h3><p>本项目运行环境为python3 + torch。此外，数据集处理及存储需要使用pandas库。</p>
<h3 id="数据集获取及定义"><a href="#数据集获取及定义" class="headerlink" title="数据集获取及定义"></a>数据集获取及定义</h3><p>数据集主要从duducheng实现的基于决策实现的算法获取。这里我们称之其为“强Agent”。调用强Agent运行2048游戏，将当前棋盘的状态当做数据，强Agent的预测结果作为label。并且对棋盘数据进行取对数的预处理。存储格式如下图所示。其中每一行有17个数.前16个代表当前棋盘，最后一个为当前棋盘的预测结果。</p>
<p><img src="/2019/01/30/基于LSTM的2048游戏AI/2048_dataset.png" alt="image"></p>
<p>数据集定义方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataset</span><span class="params">(torch.utils.data.Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root, transform=None, target_transform=None)</span>:</span></span><br><span class="line">        dataframe = pd.read_csv(root)</span><br><span class="line">        data_array = dataframe.values</span><br><span class="line"></span><br><span class="line">        self.data = data_array[:, <span class="number">0</span>:<span class="number">16</span>]</span><br><span class="line">        self.label = data_array[:, <span class="number">16</span>]</span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.target_transform = target_transform</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        board = self.data[index].reshape((<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">        board = board[:, :, np.newaxis]</span><br><span class="line">        board = board/<span class="number">11.0</span></span><br><span class="line">        <span class="comment"># board = torch.from_numpy(board)</span></span><br><span class="line"></span><br><span class="line">        label = self.label[index]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            board = self.transform(board)</span><br><span class="line">        <span class="keyword">return</span> board, label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.label)</span><br></pre></td></tr></table></figure>
<p>导入数据集方式如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">	train_data = MyDataset(</span><br><span class="line">		root = <span class="string">'./Datasets/Train.csv'</span>,</span><br><span class="line">		transform=transforms.Compose(</span><br><span class="line">			[transforms.ToTensor()]))</span><br><span class="line">    train = torch.utils.data.DataLoader(</span><br><span class="line">        train_data,</span><br><span class="line">        batch_size=batch_size,</span><br><span class="line">        shuffle=<span class="literal">True</span>,</span><br><span class="line">        num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    test_data = MyDataset(</span><br><span class="line">        root = <span class="string">'./Datasets/Test.csv'</span>,</span><br><span class="line">        transform=transforms.Compose(</span><br><span class="line">            [transforms.ToTensor()]))</span><br><span class="line"></span><br><span class="line">    test = torch.utils.data.DataLoader(</span><br><span class="line">        test_data,</span><br><span class="line">        batch_size=batch_size,</span><br><span class="line">        shuffle=<span class="literal">True</span>,</span><br><span class="line">        num_workers=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> train, test</span><br></pre></td></tr></table></figure>
<h3 id="网络模型搭建"><a href="#网络模型搭建" class="headerlink" title="网络模型搭建"></a>网络模型搭建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		super(Net, self).__init__()</span><br><span class="line">    self.RNN = nn.LSTM(</span><br><span class="line">		input_size = <span class="number">4</span>,</span><br><span class="line">		hidden_size = <span class="number">300</span>,</span><br><span class="line">		num_layers = <span class="number">4</span>,</span><br><span class="line">		batch_first=<span class="literal">True</span>)</span><br><span class="line">	self.fc1 = nn.Linear(<span class="number">300</span>, <span class="number">64</span>)</span><br><span class="line">	self.fc2 = nn.Linear(<span class="number">64</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">	x, (h_n, h_c) = self.RNN(x, <span class="literal">None</span>)</span><br><span class="line">	x = x[:, <span class="number">-1</span> ,:]</span><br><span class="line">	x = self.fc1(x)</span><br><span class="line">	x = self.fc2(x)</span><br><span class="line">	<span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Train the net</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(model, epoch, train_loader, optimizer)</span>:</span></span><br><span class="line">	model.train()</span><br><span class="line">    <span class="keyword">for</span> idx, (data, target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line"></span><br><span class="line">        data = data.type(torch.float)</span><br><span class="line">        data = Variable(data.view(<span class="number">-1</span>,<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">            data = Variable(data).cuda()</span><br><span class="line">            target = Variable(target).cuda()</span><br><span class="line">            model.cuda()</span><br><span class="line"></span><br><span class="line">        output = model(data)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># target = target.repeat(12)</span></span><br><span class="line">        loss = F.nll_loss(output, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idx % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            predict = output.data.max(<span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">            num = predict.eq(target.data).sum()</span><br><span class="line">            correct = <span class="number">100.0</span>*num/batch_size</span><br><span class="line">            t = time.time()-start_time</span><br><span class="line">            print(<span class="string">'Train epoch: %d   Loss: %.3f    '</span> % (epoch+<span class="number">1</span>, loss), \</span><br><span class="line">				<span class="string">'Accuracy: %0.2f'</span> % correct, <span class="string">'%'</span>, <span class="string">'\tTotal Time: %0.2f'</span> % t)</span><br></pre></td></tr></table></figure>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="/2019/01/30/基于LSTM的2048游戏AI/2048.gif" alt="image"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Pytorch</tag>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法及其实践</title>
    <url>/2022/04/30/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>十种排序算法总结：算法描述 + 动图展示 + 代码实现</p>
<a id="more"></a>
<p><img src="https://notes.sjtu.edu.cn/uploads/upload_81618d545abaaed106904f33d1d8670e.png" alt></p>
<h2 id="算法描述与动图描述"><a href="#算法描述与动图描述" class="headerlink" title="算法描述与动图描述"></a>算法描述与动图描述</h2><table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:left">算法描述</th>
<th style="text-align:center">动图描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>冒泡排序</strong></td>
<td style="text-align:left">1. 比较相邻的元素，若前者大于后者，则交换位置。每次将未排序部分的最大值放在最后一个<br>2. 两层循环，第一层是排序数组个数，第二层逐次递减</td>
<td style="text-align:center"><img src="https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>选择排序</strong></td>
<td style="text-align:left">1. 在未排列的数组中找到最小的元素，然后放在开始的位置<br>2. 两层循环，第一层是当前的位置，第二层是在后面找到最小值</td>
<td style="text-align:center"><img src="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>插入排序</strong></td>
<td style="text-align:left">1. 初始时将第一个元素放在第一位<br>2. 对于后续的每个元素，依次与前面比较，放在合适的位置</td>
<td style="text-align:center"><img src="https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>堆排序</strong></td>
<td style="text-align:left">构建大顶堆，将堆顶元素取出，然后将剩余元素调整为大顶堆，然后重复，直到取出所有元素</td>
<td style="text-align:center"><img src="https://pic3.zhimg.com/v2-c66a7e83189427b6a5a5c378f73c17ca_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>归并排序</strong></td>
<td style="text-align:left">1. 将序列划分为两个子序列，对每个子序列进行归并排序，两个排序后的子序列存放在 temp 数组中<br>2. 将两个排序后的子序列合并到原数组</td>
<td style="text-align:center"><img src="https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>快速排序</strong></td>
<td style="text-align:left">1. 选择一个数作为基准（pivot），所有小于基准的放在前面，所有大于基准的放在后面<br>2. 递归的进行分区处理</td>
<td style="text-align:center"><img src="https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>希尔排序</strong></td>
<td style="text-align:left">1. 以一定的步长进行插入排序<br>2. 最后一个步长一定为1</td>
<td style="text-align:center"><img src="https://pic3.zhimg.com/v2-f14e4169ff39bad42c3dd6c385ad9c72_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>计数排序</strong></td>
<td style="text-align:left">1. 找到数组中的最大值和最小值<br>2. 统计数组中每个元素出现的次数，存储在一个计数数组中（或者存储在 map 中）</td>
<td style="text-align:center"><img src="https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.webp" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>桶排序</strong></td>
<td style="text-align:left">将数组分到有限数量的桶中，然后对每个桶再分别排序。计数排序可以看做是桶数量为 1 的桶排序</td>
<td style="text-align:center"><img src="https://pic1.zhimg.com/80/v2-465190477b7fb90d17aef27c2a213368_720w.jpg" alt></td>
</tr>
<tr>
<td style="text-align:center"><strong>基数排序</strong></td>
<td style="text-align:left">将整数按位数切割成不同的数字，然后按每个位数分别比较</td>
<td style="text-align:center"><img src="https://pic3.zhimg.com/v2-3a6f1e5059386523ed941f0d6c3a136e_b.webp" alt></td>
</tr>
</tbody>
</table>
<h2 id="源代码实现"><a href="#源代码实现" class="headerlink" title="源代码实现"></a>源代码实现</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">choose_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_idx = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[min_idx]) &#123;</span><br><span class="line">                min_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(min_idx != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[min_idx];</span><br><span class="line">            nums[min_idx] = nums[i];</span><br><span class="line">            nums[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">insert_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = i;</span><br><span class="line">        <span class="keyword">int</span> curr_num = nums[i];</span><br><span class="line">        <span class="keyword">while</span>(pos &gt; <span class="number">0</span> &amp;&amp; curr_num &lt; nums[pos - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[pos] = nums[pos - <span class="number">1</span>];</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[pos] = curr_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 简历父节点指针和子节点指针</span></span><br><span class="line">    <span class="keyword">int</span> dad = start;</span><br><span class="line">    <span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= <span class="built_in">end</span>) &#123; <span class="comment">// 若子节点指针在范围内才做比较</span></span><br><span class="line">        <span class="comment">// 先比较两个子节点大小，选择最大的</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= <span class="built_in">end</span> &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>])</span><br><span class="line">            son++;</span><br><span class="line">        <span class="comment">// 如果父节点大于子节点代表调整完成，跳出</span></span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">// 父亲节点大于子节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否则交换父子内容，然后继续子节点和孙节点比较</span></span><br><span class="line">            swap(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化，i 从最后一个父节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        max_heapify(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先将第一个元素和已经排好的元素前一位交换</span></span><br><span class="line">    <span class="comment">// 再重新调整（刚调整的元素之前的元素），直到排序完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    internel_merge_sort(nums, temp, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">internel_merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        internel_merge_sort(nums, temp, left, middle);</span><br><span class="line">        internel_merge_sort(nums, temp, middle + <span class="number">1</span>, right);</span><br><span class="line">        merge_sorted_array(nums, temp, left, middle, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sorted_array</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp, <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left;      </span><br><span class="line">    <span class="keyword">int</span> j = middle + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        temp[k++] = (nums[i] &lt;= nums[j]) ? nums[i++] : nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle)&#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( j&lt;= right)&#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把数据复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">        nums[left + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    qsort(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middle = partition(nums, left, right);</span><br><span class="line">    qsort(nums, left, middle - <span class="number">1</span>);</span><br><span class="line">    qsort(nums, middle + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= pivot) right--;</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= pivot) left++;</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">step</span> &lt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) &#123;<span class="comment">//generate delta</span></span><br><span class="line">        <span class="built_in">step</span> = <span class="built_in">step</span> * <span class="number">3</span> + <span class="number">1</span>;    <span class="comment">// &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">step</span> &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">step</span>; i &lt; nums.<span class="built_in">size</span>(); i += <span class="built_in">step</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">position</span> = i;</span><br><span class="line">            <span class="keyword">int</span> curr_num = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">position</span> &gt; <span class="number">0</span> &amp;&amp; nums[<span class="built_in">position</span> - <span class="built_in">step</span>] &gt; curr_num) &#123;</span><br><span class="line">                nums[<span class="built_in">position</span>] = nums[<span class="built_in">position</span> - <span class="built_in">step</span>];</span><br><span class="line">                <span class="built_in">position</span> -= <span class="built_in">step</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[<span class="built_in">position</span>] = curr_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">step</span> /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配的KMP算法-前缀和后缀的理解</title>
    <url>/2022/05/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%9A%84KMP%E7%AE%97%E6%B3%95-%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>字符串匹配是计算机的基本任务之一。许多算法可以完成这类任务，KMP 算法是最常用的之一。</p>
<a id="more"></a>
<h2 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h2><p>首先要明确两个概念：”前缀”和”后缀”。 </p>
<p><strong>“前缀”</strong>指除了最后一个字符以外，一个字符串的全部头部组合；<strong>“后缀”</strong>指除了第一个字符以外，一个字符串的全部尾部组合。例如：</p>
<ul>
<li>前缀：“Harry” 的前缀 包括：{“H”, “Ha”, “Har”, “Harr”}</li>
<li>后缀：”Harry” 的后缀包括：{“array”, “rry”, “ry”, “y”}</li>
</ul>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>KMP算法是一种字符串匹配算法，时间复杂度为 O(m + n)，具体实现通过一个 next 数组实现。</p>
<p>KMP算法的核心是一个成为部分匹配表（Partial Match Table，PMT）的数组，一般叫做 next 数组，next 数组长度与待匹配的模式字符串长度相同。</p>
<h3 id="next-数组的含义"><a href="#next-数组的含义" class="headerlink" title="next 数组的含义"></a>next 数组的含义</h3><ul>
<li>第一个含义：在当前位置 i 失配的情况下，跳到第 next[i] 个位置。 </li>
<li>第二个含义：next[i] 也是前缀和后缀最长的公共元素长度，从而使得当当前位置不匹配时，将前缀直接移动到后缀所在的位置。</li>
</ul>
<p><strong>例如：“abababca”</strong></p>
<ul>
<li>对于 index = 0，字符串为 “a”，前缀为 {}，后缀为 {}，没有相同的前缀和后缀，所以为 0； </li>
<li>对于 index = 1，字符串为”ab”，前缀为 {a}，后缀为 {b}，没有相同的前后缀，所以为 0；</li>
<li>对于 index = 2，字符串为”aba”，前缀为 {a, ab}，后缀为 {ba, a}，z相同的前后缀长度为 1，所以为 1；</li>
<li>对于 index = 3，字符串为”abab”，前缀为 {a, ab, aba}，后缀为 {bab, ba, a}，z相同的前后缀长度为 2，所以为 2；</li>
<li>对于 index = 4，字符串为”ababa”，前缀为 {a, ab, aba, abab}，后缀为 {baba, aba, ba, a}，z相同的前后缀长度为 3，所以为 3；</li>
<li>…..</li>
</ul>
<p>最终得到的 next 数组如下表所示：</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>char</strong></td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>a</td>
</tr>
<tr>
<td><strong>next</strong></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>对于一个模式串，求解 next 数组的算法为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// generate next for a pattern</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(s[i] != s[j] &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>]; <span class="comment">// prev elem</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="next-数组的构造规则："><a href="#next-数组的构造规则：" class="headerlink" title="next 数组的构造规则："></a>next 数组的构造规则：</h3><ul>
<li>初始化：next[0] = 0; j = 0; 然后从 1 遍历到模式串末尾。<ul>
<li>遍历索引 <strong>i</strong> 表示当前模式串的索引</li>
<li>索引 <strong>j</strong> 表示前面 j 个字符是已经匹配了的   </li>
</ul>
</li>
<li>若当前字符与前一个字符匹配，也就是 s[i] == s[j]<ul>
<li>当前位置的 next 值是前一个 字符的 next 加一：next[i] = j + 1;</li>
<li>更新 j : j++</li>
</ul>
</li>
<li>若当前字符与 j 对应的不匹配，则 j 跳到前一个字符匹配的位置：j = next[ j - 1 ]</li>
<li>若 j == 0，说明前面都不匹配，next[i] = 0</li>
</ul>
<h2 id="KMP-算法的典型题目"><a href="#KMP-算法的典型题目" class="headerlink" title="KMP 算法的典型题目"></a>KMP 算法的典型题目</h2><table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#467">467</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center">[环绕字符串中唯一的子字符串</td>
</tr>
</tbody>
</table>
<h3 id="467-环绕字符串中唯一的子字符串"><a href="#467-环绕字符串中唯一的子字符串" class="headerlink" title="467. 环绕字符串中唯一的子字符串"></a>467. 环绕字符串中唯一的子字符串<span id="467"></span></h3><p>把字符串 s 看作 “abcdefghijklmnopqrstuvwxyz” 的无限环绕字符串，所以 s 看起来是这样的：</p>
<p>“…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….” 。<br>现在给定另一个字符串 p 。返回 s 中 不同 的 p 的 非空子串 的数量 。 </p>
<p>题意：给定字符串 p ，对于 p 的所有子字符串，有多少个子字符串出现在 s 中。</p>
<p><strong>解法：双指针 + KMP匹配</strong></p>
<ul>
<li>使用双指针得到 p 的所有子字符串</li>
<li>使用 KMP 算法，对 p 的每个子字符串计算 next 数组，然后查找是否出现在 s 中</li>
<li>这种做法在一些用例上是可以通过的，但是无法表示无限环绕的 tgt, 因此给定一些长度很长的字符串是，这种做法不仅复杂度高，而且会出错。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(str[i] != str[j] &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == str[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> tgt = <span class="string">"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"</span>; <span class="comment">// 匹配的目标串</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; p.<span class="built_in">size</span>(); left++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> right = left; right &lt;= p.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">                <span class="built_in">string</span> sub_str = p.substr(left, right - left);</span><br><span class="line">                <span class="keyword">if</span>(sub_str != <span class="built_in">string</span>(<span class="string">""</span>)) <span class="built_in">set</span>.insert(sub_str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = <span class="built_in">set</span>.<span class="built_in">begin</span>(); it != <span class="built_in">set</span>.<span class="built_in">end</span>(); it++) &#123; <span class="comment">// 遍历 set 中的所有字符串</span></span><br><span class="line">            <span class="built_in">string</span> src = *it;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(src.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="comment">// 计算当前字符串 src 的 next 数组</span></span><br><span class="line">            getNext(src, next);</span><br><span class="line">            <span class="comment">// 判断 src 是否在 tgt 中出现</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tgt.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">while</span>(index &gt; <span class="number">0</span> &amp;&amp; src[index] != tgt[i]) &#123; <span class="comment">// 不匹配的时候</span></span><br><span class="line">                    index = next[index - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(src[index] == tgt[i]) &#123; <span class="comment">//匹配</span></span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(index &gt;= src.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    result++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：前缀和</strong></p>
<ul>
<li>统计以每个字符结尾的最长连续子串的长度，最后将长度进行相加</li>
<li>遍历字符串 p，若当前与前一个是连续的，则长度 + 1，若不连续，则长度置 1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSubstringInWraproundString</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length[<span class="number">26</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        length[p[<span class="number">0</span>] - <span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((p[i] - p[i - <span class="number">1</span>] + <span class="number">26</span>) % <span class="number">26</span> == <span class="number">1</span>) cnt++;</span><br><span class="line">            <span class="keyword">else</span> cnt = <span class="number">1</span>;</span><br><span class="line">            length[p[i] - <span class="string">'a'</span>] = <span class="built_in">max</span>(cnt, length[p[i] - <span class="string">'a'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) result += length[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket编程之TCP协议实现</title>
    <url>/2022/05/01/Socket%E7%BC%96%E7%A8%8B%E4%B9%8BTCP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Socket编程之实现一个简单的 TCP 通信。</p>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="Socket-理解"><a href="#Socket-理解" class="headerlink" title="Socket 理解"></a>Socket 理解</h2><p>Socket 即套接字，是网络编程的一个抽象概念。Socket 是一个抽象层，应用程序可以通过它发送或接收数据，可以对其<strong>像对文件一样的打开、读写和关闭</strong>等操作。Socket 允许应用程序将 I/O 插入到网络中，并与网络中的其他应用程序进行通信。通常我们用一个 socket 表示打开了一个网络连接，网络 socket 是 IP 地址与端口的组合，所以打开一个 socket 需要知道目标计算机的 IP 地址和端口号，并指定协议类型。</p>
<h2 id="什么是TCP协议？"><a href="#什么是TCP协议？" class="headerlink" title="什么是TCP协议？"></a>什么是TCP协议？</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，数据可以准确发送，数据丢失会重发。TCP是因特网中的<strong>传输层</strong>协议，使用<strong>三次握手</strong>协议建立连接。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p><strong>TCP 三次握手</strong>的过程如下：</p>
<ul>
<li><p>客户端发送 SYN （SEQ = x）报文给服务器端，进入 SYN_SEND 状态；</p>
</li>
<li><p>服务器端收到 SYN 报文，回应一个 SYN （SEQ = y）ACK（ACK = x+1）报文，进入 SYN_RECV 状态；</p>
</li>
<li>客户端收到服务器端的 SYN 报文，回应一个ACK（ACK = y+1）报文，进入 Established 状态。</li>
</ul>
<p><img src="/2022/05/01/Socket编程之TCP协议实现/TCP建立连接.png" alt="TCP建立连接"></p>
<h3 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止"></a>连接终止</h3><p>建立一个连接需要三次握手，而终止一次连接需要经过四次握手，这是由 TCP 的半关闭造成的，具体过程如下：</p>
<ul>
<li>某个应用进程首先调用 close，称该端执行“主动关闭”（active close）。该端的 TCP 于是发送一个 FIN 分节，表示数据发送完毕；</li>
<li>接收到这个 FIN 的对端执行 “被动关闭”（passive close），这个 FIN 由 TCP 确认；</li>
<li>一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的 TCP 也发送一个FIN</li>
<li>接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。</li>
</ul>
<p><img src="/2022/05/01/Socket编程之TCP协议实现/TCP结束连接.png" alt="TCP关闭连接"></p>
<h2 id="TCP-协议的实现"><a href="#TCP-协议的实现" class="headerlink" title="TCP 协议的实现"></a>TCP 协议的实现</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端主要包括以下几个步骤：</p>
<ul>
<li>创建&amp;设置套接字</li>
<li>绑定</li>
<li>监听</li>
<li>接收连接</li>
<li>接收数据</li>
<li>发送数据</li>
</ul>
<p>完整实现代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt)); <span class="comment">// 端口重用</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9000</span>);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">"0.0.0.0"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sockfd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有新连接时，该接口会阻塞</span></span><br><span class="line">    <span class="keyword">int</span> newsockfd = accept(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(newsockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"accept"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ret = recv(newsockfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"recv"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"peer shutdown\n"</span>); <span class="comment">// 对端关闭</span></span><br><span class="line">            <span class="built_in">close</span>(newsockfd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cli say: %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"i am server"</span>; <span class="comment">// str是临时变量</span></span><br><span class="line">        <span class="built_in">strncpy</span>(buf, str, <span class="built_in">strlen</span>(str)); <span class="comment">// 不会越界</span></span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ret = send(newsockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"send"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(newsockfd);</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建-amp-设置套接字"><a href="#创建-amp-设置套接字" class="headerlink" title="创建&amp;设置套接字"></a>创建&amp;设置套接字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// domain：该参数一般被设置为 AF_INET，表示使用的是 IPv4 地址。还有更多选项可以利用 man 查看该函数</span></span><br><span class="line"><span class="comment">// type：该参数也有很多选项，例如 SOCK_STREAM 表示面向流的传输协议，SOCK_DGRAM 表示数据报，我们这里实现的是 TCP，因此选用 SOCK_STREAM，如果实现 UDP 可选 SOCK_DGRAM</span></span><br><span class="line"><span class="comment">// protocol：协议类型，一般使用默认，设置为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span> <span class="params">(<span class="keyword">int</span> socket, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line"><span class="comment">// socket：被设置的套接字</span></span><br><span class="line"><span class="comment">// level：选项所在的协议层</span></span><br><span class="line"><span class="comment">// optname：需要访问的选项名</span></span><br><span class="line"><span class="comment">// optval：指向包含新选项值的缓冲</span></span><br><span class="line"><span class="comment">// optlen：选项值的长度</span></span><br></pre></td></tr></table></figure>
<h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：服务器打开的 sock</span></span><br><span class="line"><span class="comment">// addr：常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。</span></span><br><span class="line"><span class="comment">// addrlen：地址长度</span></span><br></pre></td></tr></table></figure>
<h4 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// sockfd 的含义与 bind 中的相同。</span></span><br><span class="line"><span class="comment">// backlog 参数解释为内核为次套接口排队的最大数量，这个大小一般为 5~10，不宜太大（是为了防止 SYN 攻击）</span></span><br></pre></td></tr></table></figure>
<h4 id="接收连接"><a href="#接收连接" class="headerlink" title="接收连接"></a>接收连接</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* addr,<span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="comment">// addrlen是一个传入传出型参数，传入的是调用者的缓冲区 cliaddr 的长度，以避免缓冲区溢出问题；传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给 cliaddr 参数传 NULL，表示不关心客户端的地址。</span></span><br></pre></td></tr></table></figure>
<p>当没有新连接时，该接口会阻塞。</p>
<h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 接收对方发送的数据</span></span><br><span class="line"><span class="comment">// sockfd: 通信文件描述符</span></span><br><span class="line"><span class="comment">// buf: 缓存，用于存放要发送的数据</span></span><br><span class="line"><span class="comment">// len: buf 的大小</span></span><br><span class="line"><span class="comment">// flags: 一般设置为 0，此时为阻塞式发送，即发送不成功会直接阻塞。</span></span><br></pre></td></tr></table></figure>
<h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span> <span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 向对方发送数据</span></span><br><span class="line"><span class="comment">// sockfd: 通信文件描述符</span></span><br><span class="line"><span class="comment">// buf: 缓存，用于存放要发送的数据</span></span><br><span class="line"><span class="comment">// len: buf 的大小</span></span><br><span class="line"><span class="comment">// flags: 一般设置为 0，此时为阻塞式发送，即发送不成功会直接阻塞。</span></span><br></pre></td></tr></table></figure>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端完整实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_addr</span>;</span></span><br><span class="line">    dest_addr.sin_family = AF_INET;</span><br><span class="line">    dest_addr.sin_port = htons(<span class="number">9000</span>);</span><br><span class="line">    dest_addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">connect</span>(sockfd, (struct sockaddr*)&amp;dest_addr, <span class="keyword">sizeof</span>(dest_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"connect"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, <span class="string">"i am client"</span>);</span><br><span class="line">        ret = send(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"send"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        ret = recv(sockfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"recv"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"peer shutdown\n"</span>);</span><br><span class="line">            <span class="built_in">close</span>(sockfd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"svr say: %s\n"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
</search>
