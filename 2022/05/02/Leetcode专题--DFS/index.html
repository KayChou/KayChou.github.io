<!DOCTYPE html>



  




<script type="text/javascript" src="https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js"></script>
<link rel="stylesheet" href="/photos/photos.css">
<script type="text/javascript" src="/photos/photo.js"></script>

<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="XEbi44FzbCJmo0LFV4g2U6Eu3cO_r-aJozAG6Ukd8Ks">



  <meta name="baidu-site-verification" content="FWZNZcRNiz">











  
  
    
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,DFS,">










<meta name="description" content="Leetcode 专题训练：数组深度优先搜索（DFS）。    题号 难度 题目     94 简单 二叉树的中序遍历   98 中等 验证二叉搜索树   99 中等 恢复二叉搜索树   113 中等 路径总和 II   114 中等 二叉树展开为链表   116 中等 填充每个节点的下一个右侧节点指针   124 困难 二叉树中的最大路径和   297 困难 二叉树的序列化与反序列化   329">
<meta name="keywords" content="Leetcode,DFS">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode专题--DFS">
<meta property="og:url" content="https://kaychou.github.io/2022/05/02/Leetcode专题--DFS/index.html">
<meta property="og:site_name" content="Kaiser&#39;s Blog">
<meta property="og:description" content="Leetcode 专题训练：数组深度优先搜索（DFS）。    题号 难度 题目     94 简单 二叉树的中序遍历   98 中等 验证二叉搜索树   99 中等 恢复二叉搜索树   113 中等 路径总和 II   114 中等 二叉树展开为链表   116 中等 填充每个节点的下一个右侧节点指针   124 困难 二叉树中的最大路径和   297 困难 二叉树的序列化与反序列化   329">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-05-24T09:01:56.347Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode专题--DFS">
<meta name="twitter:description" content="Leetcode 专题训练：数组深度优先搜索（DFS）。    题号 难度 题目     94 简单 二叉树的中序遍历   98 中等 验证二叉搜索树   99 中等 恢复二叉搜索树   113 中等 路径总和 II   114 中等 二叉树展开为链表   116 中等 填充每个节点的下一个右侧节点指针   124 困难 二叉树中的最大路径和   297 困难 二叉树的序列化与反序列化   329">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://kaychou.github.io/2022/05/02/Leetcode专题--DFS/">





  <title>Leetcode专题--DFS | Kaiser's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  


  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kaiser's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">低配程序猿</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kaychou.github.io/2022/05/02/Leetcode专题--DFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Benjamin Zhou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaiser's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode专题--DFS</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-05-02T22:35:27+08:00">
                2022-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Leetcode 专题训练：<strong>数组深度优先搜索（DFS）</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#94">94</a></td>
<td style="text-align:center"><font color="green">简单</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#98">98</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#99">99</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">恢复二叉搜索树</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#113">113</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">路径总和 II</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#114">114</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#116">116</a></td>
<td style="text-align:center"><font color="orange">中等</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">填充每个节点的下一个右侧节点指针</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#124">124</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">二叉树中的最大路径和</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#297">297</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化与反序列化</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#329">329</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener"> 矩阵中的最长递增路径</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#332">332</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/reconstruct-itinerary/" target="_blank" rel="noopener">重新安排行程</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#685">685</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/redundant-connection-ii/" target="_blank" rel="noopener">冗余连接 II</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#753">753</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/cracking-the-safe/" target="_blank" rel="noopener">破解保险箱</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#765">765</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/couples-holding-hands/" target="_blank" rel="noopener">情侣牵手</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#675">675</a></td>
<td style="text-align:center"><font color="red">困难</font></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/cut-off-trees-for-golf-event/" target="_blank" rel="noopener">为高尔夫比赛砍树</a></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历<span id="94"></span></h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<p>解法：<strong>递归（DFS）</strong></p>
<ul>
<li>先递归遍历左子树，将当前节点加入 vector，然后递归遍历右子树</li>
<li>终止条件：当前节点为 NULL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        traverse(node-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        result.push_back(node-&gt;val); <span class="comment">// 将当前值加入到 vector</span></span><br><span class="line">        traverse(node-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树<span id="98"></span></h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 小于 当前节点的数。</li>
<li>节点的右子树只包含 大于 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p>解法：<strong>中序遍历</strong></p>
<ul>
<li>注意到二叉搜索树 BST 的中序遍历序列是升序的</li>
<li>不需要记录整个遍历序列，只需要依次比较当前值与前一个值即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre_val = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> left = check(node-&gt;left); <span class="comment">// 检查左子树是不是 BST</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &gt; pre_val) &#123; <span class="comment">// 若中序遍历序列不是升序，则 false</span></span><br><span class="line">            pre_val = node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> right = check(node-&gt;right); <span class="comment">// 检查右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树<span id="99"></span></h2><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。</p>
<p><strong>解法：中序遍历</strong></p>
<ul>
<li>中序遍历 BST，得到的数组原本应该是有序的，由于交换了两个位置：<ul>
<li>交换位置相邻：则有一个逆序对</li>
<li>交换位置不相邻：则有两个逆序对</li>
</ul>
</li>
<li>使用 pair&lt; TreeNode*, TreeNode*&gt; rev_pair 来记录逆序对<ul>
<li>若有一对，则交换两个 node 的值</li>
<li>若有两对，则交换第一对的第一个，和第二对的第二个节点值 </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre_node = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;TreeNode*, TreeNode*&gt;&gt; rev_pair; <span class="comment">// 存储逆序的节点对</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        traverse_inorder(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rev_pair.size() == <span class="number">1</span>) &#123; <span class="comment">// 相邻的位置被交换，只有一对逆序对</span></span><br><span class="line">            TreeNode* node1 = rev_pair[<span class="number">0</span>].first;</span><br><span class="line">            TreeNode* node2 = rev_pair[<span class="number">0</span>].second;</span><br><span class="line">            swap(node1-&gt;val, node2-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rev_pair.size() == <span class="number">2</span>) &#123; <span class="comment">// 不相邻的位置被交换，有两个逆序对</span></span><br><span class="line">            TreeNode* node1 = rev_pair[<span class="number">0</span>].first;</span><br><span class="line">            TreeNode* node2 = rev_pair[<span class="number">1</span>].second;</span><br><span class="line">            swap(node1-&gt;val, node2-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse_inorder</span><span class="params">(TreeNode* node)</span> </span>&#123; <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        traverse_inorder(node-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre_node &amp;&amp; node-&gt;val &lt; pre_node-&gt;val) &#123;</span><br><span class="line">            rev_pair.push_back(&#123;pre_node, node&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        pre_node = node;</span><br><span class="line"></span><br><span class="line">        traverse_inorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a>路径总和 II<span id="113"></span></h2><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p><strong>解法：DFS + 递归</strong></p>
<ul>
<li>定义路径 path 和 当前路径总和 sum，以及 返回值 result</li>
<li>若 当前节点为 NULL，return，若当前为叶子节点，特殊处理</li>
<li>否则，遍历左节点，回溯一次</li>
<li>遍历右节点，回溯</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 记录遍历的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        traverse(root, <span class="number">0</span>, targetSum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="keyword">int</span> sum, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 叶子节点，终止迭代</span></span><br><span class="line">            sum += node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(sum == targetSum) &#123;</span><br><span class="line">                path.emplace_back(node-&gt;val);</span><br><span class="line">                result.emplace_back(path);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) traverse(node-&gt;left, sum + node-&gt;val, targetSum);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) traverse(node-&gt;right, sum + node-&gt;val, targetSum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表<span id="114"></span></h2><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>
<p><strong>解法一：前序遍历</strong></p>
<ul>
<li>使用前序遍历，将遍历的数组保存下来</li>
<li>将遍历的数组重建成单链表</li>
<li>空间复杂度 O(N)，与 O(1) 要求不符</li>
</ul>
<p><strong>解法二：前序遍历 + 同步展开</strong></p>
<ul>
<li>前序遍历使用 stack 进行辅助，每次从栈中 pop 出一个节点，如果当前节点不为空，则<ul>
<li>将右节点 push 到栈中</li>
<li>将左节点 push 到栈中</li>
</ul>
</li>
<li>同步展开，维护上一个访问的节点 prev，每次访问一个节点 curr<ul>
<li>prev 左节点设置为 NULL，右节点指向 curr</li>
<li>更新 prev</li>
</ul>
</li>
<li>时间复杂度 O(N)，空间复杂度 O(n)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line"></span><br><span class="line">        TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty()) &#123;</span><br><span class="line">            TreeNode* curr = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right) stk.push(curr-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left) stk.push(curr-&gt;left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                prev-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                prev-&gt;right = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法三：寻找前驱结点</strong></p>
<p>前序遍历都需要存储节点，因此不满足空间复杂度 O(1) 的要求。</p>
<ul>
<li>对于当前节点，如果其左子树不为空，则在其左子树中找到最右边的节点，作为<strong><em>前驱结点</em></strong></li>
<li>将当前节点 curr 的右指针指向前驱结点的右子节点</li>
<li>然后将 curr 的左节点 变成 右节点，并将左节点置空</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                TreeNode* pre_node = curr-&gt;left;</span><br><span class="line">                <span class="keyword">while</span>(pre_node-&gt;right != <span class="literal">NULL</span>) &#123; <span class="comment">// 找到左子树的最右节点（前驱结点）</span></span><br><span class="line">                    pre_node = pre_node-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pre_node-&gt;right = curr-&gt;right; <span class="comment">// 将右子树接到前驱结点</span></span><br><span class="line">                curr-&gt;right = curr-&gt;left; <span class="comment">// 左子树换到右边</span></span><br><span class="line">                curr-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针<span id="116"></span></h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<p><strong>解法一：层序遍历</strong></p>
<ul>
<li>借助队列，进行层序遍历</li>
<li>时间复杂度 O(N)，空间复杂度 O(1)</li>
</ul>
<p><strong>解法二：借助 next 指针</strong></p>
<ul>
<li>对于当前节点<ul>
<li>有两个子节点的情况，将下一层的左节点指向右节点</li>
<li>当前 next 不为 NULL 的情况，将 curr 右节点 指向 curr-&gt;next 的左节点</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        Node* left_first = root; <span class="comment">// 每一层最左边的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left_first-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Node* head = left_first;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                head-&gt;left-&gt;next = head-&gt;right; <span class="comment">// 同一个父节点的两个节点</span></span><br><span class="line">                <span class="keyword">if</span>(head-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">// 不同父节点的两个相邻节点</span></span><br><span class="line">                    head-&gt;right-&gt;next = head-&gt;next-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            left_first = left_first-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和<span id="124"></span></h2><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p><strong>解法：递归</strong></p>
<ul>
<li>递推关系式：当前节点的路径最长 = max( 当前 val, 左节点最长 + val，val + 右节点最长，左节点最长 + val + 右节点最长)</li>
<li>对于当前节点，如果是叶子节点，则返回当前 val</li>
<li>计算左子树最长路径 left 和右子树最长路径 right</li>
<li>结果取 max(result, val, val + left, val + right, val + left + right) 的最大值</li>
<li>返回值取 max(val, val + left, val + right) 的最大值，这是因为一旦返回，意味着当前不能左右子树都访问而只能选择一路</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> result = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        longest_path(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longest_path</span><span class="params">(TreeNode* node)</span> </span>&#123; <span class="comment">// 以 node 为中间节点的最长路径</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 叶子节点返回当前 val</span></span><br><span class="line">            result = max(node-&gt;val, result);</span><br><span class="line">            <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) left = longest_path(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) right = longest_path(node-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = max(node-&gt;val, max(node-&gt;val + left, max(node-&gt;val + right, node-&gt;val + left + right)));</span><br><span class="line">        result = max(length, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(node-&gt;val, max(node-&gt;val + left, node-&gt;val + right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化<span id="297"></span></h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>解法：层次遍历</strong></p>
<ul>
<li>使用队列辅助进行层次遍历，不同元素用 “,” 分隔，空节点用 # 标识</li>
<li>序列化<ul>
<li>前序遍历整个树，先存当前节点，再存左节点，然后是右节点</li>
</ul>
</li>
<li>反序列化<ul>
<li>根据 “,” 分割当前 string，以 list 存储</li>
<li>以 list 第一个元素为当前节点，新建一个节点</li>
<li>去除首个元素后，递归建立左子树和右子树</li>
<li>遇到 “#” 后返回 NULL</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str + <span class="string">","</span> + serialize(root-&gt;left) + <span class="string">","</span> + serialize(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123; <span class="comment">// 将序列化字符串转成字符串数组</span></span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; nums; </span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] == <span class="string">','</span>) &#123;</span><br><span class="line">                nums.push_back(str);</span><br><span class="line">                str.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> str += data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!str.empty()) &#123; <span class="comment">// 将最后一个元素放入数组</span></span><br><span class="line">            nums.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; &amp;data)</span> </span>&#123; <span class="comment">// 对字符串数组反序列化</span></span><br><span class="line">        <span class="keyword">if</span>(data.front() == <span class="string">"#"</span>) &#123;</span><br><span class="line">            data.erase(data.begin());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* curr = <span class="keyword">new</span> TreeNode(stoi(data.front()));</span><br><span class="line">        data.erase(data.begin());</span><br><span class="line">        curr-&gt;left = deserialize(data);</span><br><span class="line">        curr-&gt;right = deserialize(data);</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a>矩阵中的最长递增路径<span id="329"></span></h2><p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p>
<p><strong>解法：记忆化 DFS</strong></p>
<ul>
<li>从矩阵中每一个单元格进行 DFS，即找到从当前单元格开始的最长递增路径</li>
<li>对于当前单元格，尝试遍历四个方向，在每一个合理的方向上：<ul>
<li>若移动后的值 大于 当前值，则返回 移动后的最大路径 + 1</li>
<li>在遍历时，使用 length 矩阵进行记忆，若当前单元格已经遍历过，直接返回当前单元格的最长路径</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">length</span><span class="params">(matrix.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                result = max(result, dfs(matrix, i, j, length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回以单元格 (row, col) 为起点的最长递增路径</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length[row][col] &gt; <span class="number">0</span>) <span class="keyword">return</span> length[row][col]; <span class="comment">// 若当前已经遍历过，则直接返回</span></span><br><span class="line">        length[row][col]++; <span class="comment">// 长度至少为 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next_row = row + direction[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> next_col = col + direction[i][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(next_row &gt;= <span class="number">0</span> &amp;&amp; next_row &lt; matrix.size() &amp;&amp; next_col &gt;= <span class="number">0</span> &amp;&amp; next_col &lt; matrix[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[next_row][next_col] &gt; matrix[row][col]) &#123;</span><br><span class="line">                    length[row][col] = max(length[row][col], <span class="number">1</span> + dfs(matrix, next_row, next_col, length));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程<span id="332"></span></h2><p>给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<p>例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前。<br>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>
<p><strong>解法：求解欧拉回路 + DFS</strong></p>
<ul>
<li>Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：<ul>
<li>从起点出发，进行深度优先搜索。</li>
<li>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</li>
<li>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</li>
</ul>
</li>
<li>首先构建 <code>unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, std::greater&lt;string&gt;&gt;</code> ，key 值表示出发机场，val 是一个优先级队列，其中按照字典序从小到大记录了目的地的航班，这样每次从优先级队列中取出一个目的地，都能保证是字典序最小的</li>
<li>从起始点开始 <strong>DFS</strong><ul>
<li>对于当前节点，从它的每一个非死胡同（出度与入度差1）分支出发进行 DFS</li>
<li>遍历与当前节点相连的所有节点后，再将当前节点入栈，这能保证死胡同节点是第一个入栈的</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stk; <span class="comment">// 存储遍历的各个顶点（机场）</span></span><br><span class="line">    <span class="comment">// key 表示起点，val 表示终点列表</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, priority_queue&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="built_in">string</span>&gt;&gt;&gt; <span class="built_in">map</span>; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findItinerary</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tickets) &#123;</span><br><span class="line">            <span class="built_in">map</span>[it[<span class="number">0</span>]].push(it[<span class="number">1</span>]); <span class="comment">// 构建 map</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="string">"JFK"</span>);</span><br><span class="line"></span><br><span class="line">        reverse(stk.begin(), stk.end());</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">map</span>.find(curr) != <span class="built_in">map</span>.end() &amp;&amp; <span class="built_in">map</span>[curr].size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">string</span> str = <span class="built_in">map</span>[curr].top(); <span class="comment">//</span></span><br><span class="line">            <span class="built_in">map</span>[curr].pop();</span><br><span class="line">            dfs(str);</span><br><span class="line">        &#125; <span class="comment">// 遍历所有节点后再入栈，可以保证死胡同节点是第一个入栈的</span></span><br><span class="line">        stk.push_back(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="冗余连接-II"><a href="#冗余连接-II" class="headerlink" title="冗余连接 II"></a>冗余连接 II<span id="685"></span></h2><p>在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
<p><strong>解法：并查集</strong></p>
<ul>
<li>分析题目：本质上是一颗有方向的树，添加了一条多余的边，添加的边可能有两种情况：<ul>
<li>指向 root 节点：这会导致一条环路出现</li>
<li>不指向 root 节点：这会导致有一个节点有两个父节点，可能有环，也可能没有环</li>
</ul>
</li>
<li>使用<strong>并查集</strong>来判断是否存在环路以及父节点<ul>
<li>每个节点 i 初始化父亲节点 parent[i] = i</li>
<li>每添加一条边 [u, v]，若 v 节点父亲节点不是 v(说明已经有别的父节点)，则将当前边记为冲突的边</li>
<li>若 u 的父节点和 v 的父节点相同，则说明存在环路</li>
</ul>
</li>
<li>判断该删除哪条边<ul>
<li>若没有冲突的边（两个父节点），则直接删除环路中的最后一条边即可</li>
<li>若存在冲突的边 [u, v]：<ul>
<li>若有环，则不可能是 [u, v]，因为一条边不可能同时是冲突边和环路出现的边，这时候直接删除另一条指向 v 的边即可，所以附加的边是 [parent[v], v]</li>
<li>若没有环，则直接删除冲突的边 [u, v]</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span> <span class="comment">// 并查集实现</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line">        UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">            parent.resize(n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) parent[i] = i; <span class="comment">// 初始化，每个人的父节点都是自己</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查找 x 节点的最终父节点，也即其所在的集合</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == parent[x]) <span class="keyword">return</span> x; <span class="comment">// 若该节点的最终父节点是自己，返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> find(parent[x]); <span class="comment">// 否则不断去查找父节点的最终父节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            parent[find(u)] = find(v); <span class="comment">// 认新的父节点，即让 u 的最终父节点认 v 的最终父节点当父亲</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(edges.size() + <span class="number">1</span>)</span></span>; <span class="comment">// 实例化并查集合</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">parent</span><span class="params">(edges.size() +<span class="number">1</span>)</span></span>; <span class="comment">// 记录每条边的父节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= edges.size(); i++) parent[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> conflict = <span class="number">-1</span>, cycle = <span class="number">-1</span>; <span class="comment">// 记录冲突的边和环形边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(parent[v] != v) &#123; <span class="comment">// 节点 v 已经有了父节点，当前为冲突边</span></span><br><span class="line">                conflict = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                <span class="keyword">if</span>(uf.find(u) == uf.find(v)) &#123; <span class="comment">// 存在环形边</span></span><br><span class="line">                    cycle = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    uf.merge(u, v); <span class="comment">// 没有环形边，将 u, v归为一类</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断该删除哪条边</span></span><br><span class="line">        <span class="keyword">if</span>(conflict == <span class="number">-1</span>) &#123; <span class="comment">// 没有冲突边，直接删除最后一个环形边</span></span><br><span class="line">            <span class="keyword">return</span> edges[cycle];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(cycle != <span class="number">-1</span>) &#123; <span class="comment">// 存在环形边</span></span><br><span class="line">                <span class="keyword">int</span> v = edges[conflict][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> &#123;parent[v], v&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> edges[conflict];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="破解保险箱"><a href="#破解保险箱" class="headerlink" title="破解保险箱"></a>破解保险箱<span id="753"></span></h2><p>有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, …, k-1 中的一个 。</p>
<p>你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。</p>
<p>举个例子，假设密码是 “345”，你可以输入 “012345” 来打开它，只是你输入了 6 个字符.</p>
<p>请返回一个能打开保险箱的最短字符串。</p>
<p><strong>题意分析：</strong></p>
<ul>
<li><code>n=1, k=2</code>的时候，就是说密码是1位，可能是0，也可能是1，那么这个答案就应该包含0，也包含1，顺序不重要，<strong>只要按照这答案输入，遇到对的情况自然会打开。</strong></li>
<li><code>n=2, k=2</code>，那么密码就可能是01、10、00、11，密码就应该包含这四种情况，看一下答案，”00110” , “01100”, “10011”, “11001”，是不是这四种答案每个里边都包含这个子串？</li>
<li><code>n=3, k=2</code>，那么密码就应该包含000、001、010、011…还有几个我就不写了，可以看一下答案，答案肯定是包含这几个串的：0011101000</li>
</ul>
<p><strong>解法：求解欧拉回路 + DFS</strong></p>
<p>建模：</p>
<ul>
<li>将 n - 1 位数看作节点，每一位可以填充 0 - (k - 1)，所以共有 K^(n - 1) 个节点</li>
<li>从每个节点出发，有 k 个出边，编号 0 - (k - 1)，编号对应第 n 位的数字。如果当前节点对应的点数为 a1a2…a(n - 1)，则第 x 条出边 对应的节点为 a2a3…a(n-1)x 节点。这样每个节点也有 k 个入边</li>
</ul>
<p><code>例如 k=4k=4，n=3n=3 时，节点分别为 00, 01, 02,..., 32, 3300,01,02,⋯,32,33，每个节点的出边的编号分别为 0, 1, 2, 30,1,2,3，那么 0000 和它的出边形成了 000, 001, 002, 003000,001,002,003 这 44 个 33 位数，3232 和它的出边形成了 320, 321, 322, 323320,321,322,323 这 44 个 33 位数。</code></p>
<p><strong>Hierholzer 算法：</strong></p>
<ul>
<li>从 000 节点 node（n - 1 个 0）出发，沿着 x : 0, 1, 2 ,… k - 1 移动到下一个节点（表示为 10 * node + x）% （10 ^ (n - 1)）</li>
<li>使用 set 记录经过的值，只有在 set 中没有这个值的时候，才进行下一轮迭代</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mod;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">    <span class="built_in">string</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123; <span class="comment">// 沿着 i 向下一个节点移动</span></span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">10</span> * node + i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.find(val) == <span class="built_in">set</span>.end()) &#123;</span><br><span class="line">                <span class="built_in">set</span>.insert(val);</span><br><span class="line">                dfs(val % mod); <span class="comment">// 递归下一个节点</span></span><br><span class="line">                result += (i + <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">crackSafe</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mod = <span class="built_in">pow</span>(<span class="number">10</span>, n - <span class="number">1</span>); <span class="comment">// 模 mod 用来得到 (n-1) 位数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        result += <span class="built_in">string</span>(n - <span class="number">1</span>, <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="情侣牵手"><a href="#情侣牵手" class="headerlink" title="情侣牵手"></a>情侣牵手<span id="765"></span></h2><p>n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。</p>
<p>人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。</p>
<p>返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次交换可选择任意两人，让他们站起来交换座位。</p>
<p><strong>解法一：并查集</strong></p>
<ul>
<li>对于坐在相邻位置上的两个人，构成一个连通分量</li>
<li>并查集初始化时有 N 对情侣（即 N 个联通分量），然后将两两相邻的两个人并在一起，联通分量数减一</li>
<li>最终最小的交换次数是 N - （联通分量数）</li>
</ul>
<h2 id="为高尔夫比赛砍树"><a href="#为高尔夫比赛砍树" class="headerlink" title="为高尔夫比赛砍树"></a>为高尔夫比赛砍树<span id="675"></span></h2><p>你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 m x n 的矩阵表示， 在这个矩阵中：</p>
<p>0 表示障碍，无法触碰<br>1 表示地面，可以行走<br>比 1 大的数 表示有树的单元格，可以行走，数值表示树的高度<br>每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。</p>
<p>你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 1（即变为地面）。</p>
<p>你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。</p>
<p>可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。</p>
<p><strong>解法：记忆化 DFS</strong></p>
<p>这题和 <a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener"> 329. 矩阵中的最长递增路径</a> 相似，从 (0, 0) 位置出发，找到一个最长递增路径。但是由于此题可能会舍近求远，即会先去砍一个更远地方的树，再回头砍近处的树。所以需要先将树节点排序，再对排序后的树两两之间去查找路径。</p>
<ul>
<li>遍历整个矩阵，记录每棵树的坐标，记录为 vector&lt;pair&lt;int, int&gt;&gt; 格式</li>
<li>对 trees 按照高度进行排序</li>
<li>对两两节点直接做路径查找</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; forest, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        m = forest.size();</span><br><span class="line">        n = forest[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; myQue;</span><br><span class="line">        <span class="keyword">int</span> directions[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>; </span><br><span class="line"></span><br><span class="line">        tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; root&#123;<span class="number">0</span>, x1, y1&#125;;</span><br><span class="line">        myQue.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!myQue.empty())&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myQue.size(); ++i)&#123;</span><br><span class="line">                tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; node = myQue.front();</span><br><span class="line">                myQue.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> d = get&lt;<span class="number">0</span>&gt;(node), x = get&lt;<span class="number">1</span>&gt;(node), y = get&lt;<span class="number">2</span>&gt;(node); </span><br><span class="line">                <span class="keyword">if</span> ((x == x2) <span class="keyword">and</span> (y == y2))&#123;</span><br><span class="line">                    <span class="keyword">return</span> d;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">int</span> n_x = x + directions[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> n_y = y + directions[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> ((n_x &gt;= <span class="number">0</span> &amp;&amp; n_x &lt; m) &amp;&amp; (n_y &gt;= <span class="number">0</span> &amp;&amp; n_y &lt; n) &amp;&amp; (forest[n_x][n_y] != <span class="number">0</span> &amp;&amp; (!visited[n_x][n_y])))&#123;</span><br><span class="line">                        visited[n_x][n_y] = <span class="literal">true</span>;</span><br><span class="line">                        myQue.emplace(tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&#123;d + <span class="number">1</span>, n_x, n_y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; forest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; trees;</span><br><span class="line"></span><br><span class="line">        m = forest.size();</span><br><span class="line">        n = forest[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (forest[i][j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_tree&#123;forest[i][j], i, j&#125;;</span><br><span class="line">                    trees.push_back(tmp_tree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(trees.begin(), trees.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start_x = <span class="number">0</span>, start_y = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trees.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> dist = bfs(forest, start_x, start_y, trees[i][<span class="number">1</span>], trees[i][<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (dist &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            start_x = trees[i][<span class="number">1</span>];</span><br><span class="line">            start_y = trees[i][<span class="number">2</span>];</span><br><span class="line">            res += dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
            <a href="/tags/DFS/" rel="tag"># DFS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/05/02/Leetcode专题--数组/" rel="next" title="Leetcode专题--数组">
                <i class="fa fa-chevron-left"></i> Leetcode专题--数组
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/05/04/体素拍摄调研/" rel="prev" title="体素拍摄调研">
                体素拍摄调研 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>
	
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Benjamin Zhou">
            
              <p class="site-author-name" itemprop="name">Benjamin Zhou</p>
              <p class="site-description motion-element" itemprop="description">感性与理性时常交融，收敛与放纵并行发生。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
		  
		  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1430319727&auto=1&height=66"></iframe>
			
			
          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的中序遍历"><span class="nav-number">1.</span> <span class="nav-text">二叉树的中序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#验证二叉搜索树"><span class="nav-number">2.</span> <span class="nav-text">验证二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#恢复二叉搜索树"><span class="nav-number">3.</span> <span class="nav-text">恢复二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路径总和-II"><span class="nav-number">4.</span> <span class="nav-text">路径总和 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树展开为链表"><span class="nav-number">5.</span> <span class="nav-text">二叉树展开为链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#填充每个节点的下一个右侧节点指针"><span class="nav-number">6.</span> <span class="nav-text">填充每个节点的下一个右侧节点指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树中的最大路径和"><span class="nav-number">7.</span> <span class="nav-text">二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的序列化与反序列化"><span class="nav-number">8.</span> <span class="nav-text">二叉树的序列化与反序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩阵中的最长递增路径"><span class="nav-number">9.</span> <span class="nav-text">矩阵中的最长递增路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重新安排行程"><span class="nav-number">10.</span> <span class="nav-text">重新安排行程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冗余连接-II"><span class="nav-number">11.</span> <span class="nav-text">冗余连接 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#破解保险箱"><span class="nav-number">12.</span> <span class="nav-text">破解保险箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#情侣牵手"><span class="nav-number">13.</span> <span class="nav-text">情侣牵手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为高尔夫比赛砍树"><span class="nav-number">14.</span> <span class="nav-text">为高尔夫比赛砍树</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Benjamin Zhou</span>

  
</div>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>









  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  
  <script src="/js/src/md5.min.js"></script>>
  
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: 'b3a8493c522161f624ba',
          clientSecret: '2c54b270a3783f9a77e93f2f8c7e9687cbad26f2',
          repo: 'KayChou.github.io',
          owner: 'KayChou',
          admin: ['KayChou'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
		
        gitalk.render('gitalk-container')  
		
       </script>




  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>


